/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/apexcharts/dist/apexcharts.common.js":
/*!***********************************************************!*\
  !*** ./node_modules/apexcharts/dist/apexcharts.common.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * ApexCharts v3.26.0
 * (c) 2018-2021 Juned Chhipa
 * Released under the MIT License.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function t(e) {
  return (t = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
    return _typeof(t);
  } : function (t) {
    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
  })(e);
}

function e(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function i(t, e) {
  for (var i = 0; i < e.length; i++) {
    var a = e[i];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a);
  }
}

function a(t, e, a) {
  return e && i(t.prototype, e), a && i(t, a), t;
}

function s(t, e, i) {
  return e in t ? Object.defineProperty(t, e, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = i, t;
}

function r(t, e) {
  var i = Object.keys(t);

  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function (e) {
      return Object.getOwnPropertyDescriptor(t, e).enumerable;
    })), i.push.apply(i, a);
  }

  return i;
}

function n(t) {
  for (var e = 1; e < arguments.length; e++) {
    var i = null != arguments[e] ? arguments[e] : {};
    e % 2 ? r(Object(i), !0).forEach(function (e) {
      s(t, e, i[e]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : r(Object(i)).forEach(function (e) {
      Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));
    });
  }

  return t;
}

function o(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), e && h(t, e);
}

function l(t) {
  return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  })(t);
}

function h(t, e) {
  return (h = Object.setPrototypeOf || function (t, e) {
    return t.__proto__ = e, t;
  })(t, e);
}

function c(t, e) {
  return !e || "object" != _typeof(e) && "function" != typeof e ? function (t) {
    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t;
  }(t) : e;
}

function d(t) {
  var e = function () {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;

    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;
    } catch (t) {
      return !1;
    }
  }();

  return function () {
    var i,
        a = l(t);

    if (e) {
      var s = l(this).constructor;
      i = Reflect.construct(a, arguments, s);
    } else i = a.apply(this, arguments);

    return c(this, i);
  };
}

function g(t) {
  return function (t) {
    if (Array.isArray(t)) return u(t);
  }(t) || function (t) {
    if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);
  }(t) || function (t, e) {
    if (!t) return;
    if ("string" == typeof t) return u(t, e);
    var i = Object.prototype.toString.call(t).slice(8, -1);
    "Object" === i && t.constructor && (i = t.constructor.name);
    if ("Map" === i || "Set" === i) return Array.from(t);
    if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return u(t, e);
  }(t) || function () {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}

function u(t, e) {
  (null == e || e > t.length) && (e = t.length);

  for (var i = 0, a = new Array(e); i < e; i++) {
    a[i] = t[i];
  }

  return a;
}

var f = function () {
  function i() {
    e(this, i);
  }

  return a(i, [{
    key: "shadeRGBColor",
    value: function value(t, e) {
      var i = e.split(","),
          a = t < 0 ? 0 : 255,
          s = t < 0 ? -1 * t : t,
          r = parseInt(i[0].slice(4), 10),
          n = parseInt(i[1], 10),
          o = parseInt(i[2], 10);
      return "rgb(" + (Math.round((a - r) * s) + r) + "," + (Math.round((a - n) * s) + n) + "," + (Math.round((a - o) * s) + o) + ")";
    }
  }, {
    key: "shadeHexColor",
    value: function value(t, e) {
      var i = parseInt(e.slice(1), 16),
          a = t < 0 ? 0 : 255,
          s = t < 0 ? -1 * t : t,
          r = i >> 16,
          n = i >> 8 & 255,
          o = 255 & i;
      return "#" + (16777216 + 65536 * (Math.round((a - r) * s) + r) + 256 * (Math.round((a - n) * s) + n) + (Math.round((a - o) * s) + o)).toString(16).slice(1);
    }
  }, {
    key: "shadeColor",
    value: function value(t, e) {
      return i.isColorHex(e) ? this.shadeHexColor(t, e) : this.shadeRGBColor(t, e);
    }
  }], [{
    key: "bind",
    value: function value(t, e) {
      return function () {
        return t.apply(e, arguments);
      };
    }
  }, {
    key: "isObject",
    value: function value(e) {
      return e && "object" === t(e) && !Array.isArray(e) && null != e;
    }
  }, {
    key: "listToArray",
    value: function value(t) {
      var e,
          i = [];

      for (e = 0; e < t.length; e++) {
        i[e] = t[e];
      }

      return i;
    }
  }, {
    key: "extend",
    value: function value(t, e) {
      var i = this;
      "function" != typeof Object.assign && (Object.assign = function (t) {
        if (null == t) throw new TypeError("Cannot convert undefined or null to object");

        for (var e = Object(t), i = 1; i < arguments.length; i++) {
          var a = arguments[i];
          if (null != a) for (var s in a) {
            a.hasOwnProperty(s) && (e[s] = a[s]);
          }
        }

        return e;
      });
      var a = Object.assign({}, t);
      return this.isObject(t) && this.isObject(e) && Object.keys(e).forEach(function (r) {
        i.isObject(e[r]) && r in t ? a[r] = i.extend(t[r], e[r]) : Object.assign(a, s({}, r, e[r]));
      }), a;
    }
  }, {
    key: "extendArray",
    value: function value(t, e) {
      var a = [];
      return t.map(function (t) {
        a.push(i.extend(e, t));
      }), t = a;
    }
  }, {
    key: "monthMod",
    value: function value(t) {
      return t % 12;
    }
  }, {
    key: "clone",
    value: function value(e) {
      if ("[object Array]" === Object.prototype.toString.call(e)) {
        for (var i = [], a = 0; a < e.length; a++) {
          i[a] = this.clone(e[a]);
        }

        return i;
      }

      if ("[object Null]" === Object.prototype.toString.call(e)) return null;
      if ("[object Date]" === Object.prototype.toString.call(e)) return e;

      if ("object" === t(e)) {
        var s = {};

        for (var r in e) {
          e.hasOwnProperty(r) && (s[r] = this.clone(e[r]));
        }

        return s;
      }

      return e;
    }
  }, {
    key: "log10",
    value: function value(t) {
      return Math.log(t) / Math.LN10;
    }
  }, {
    key: "roundToBase10",
    value: function value(t) {
      return Math.pow(10, Math.floor(Math.log10(t)));
    }
  }, {
    key: "roundToBase",
    value: function value(t, e) {
      return Math.pow(e, Math.floor(Math.log(t) / Math.log(e)));
    }
  }, {
    key: "parseNumber",
    value: function value(t) {
      return null === t ? t : parseFloat(t);
    }
  }, {
    key: "randomId",
    value: function value() {
      return (Math.random() + 1).toString(36).substring(4);
    }
  }, {
    key: "noExponents",
    value: function value(t) {
      var e = String(t).split(/[eE]/);
      if (1 === e.length) return e[0];
      var i = "",
          a = t < 0 ? "-" : "",
          s = e[0].replace(".", ""),
          r = Number(e[1]) + 1;

      if (r < 0) {
        for (i = a + "0."; r++;) {
          i += "0";
        }

        return i + s.replace(/^-/, "");
      }

      for (r -= s.length; r--;) {
        i += "0";
      }

      return s + i;
    }
  }, {
    key: "getDimensions",
    value: function value(t) {
      var e = getComputedStyle(t, null),
          i = t.clientHeight,
          a = t.clientWidth;
      return i -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), [a -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), i];
    }
  }, {
    key: "getBoundingClientRect",
    value: function value(t) {
      var e = t.getBoundingClientRect();
      return {
        top: e.top,
        right: e.right,
        bottom: e.bottom,
        left: e.left,
        width: t.clientWidth,
        height: t.clientHeight,
        x: e.left,
        y: e.top
      };
    }
  }, {
    key: "getLargestStringFromArr",
    value: function value(t) {
      return t.reduce(function (t, e) {
        return Array.isArray(e) && (e = e.reduce(function (t, e) {
          return t.length > e.length ? t : e;
        })), t.length > e.length ? t : e;
      }, 0);
    }
  }, {
    key: "hexToRgba",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999",
          e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
      "#" !== t.substring(0, 1) && (t = "#999999");
      var i = t.replace("#", "");
      i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));

      for (var a = 0; a < i.length; a++) {
        i[a] = parseInt(1 === i[a].length ? i[a] + i[a] : i[a], 16);
      }

      return void 0 !== e && i.push(e), "rgba(" + i.join(",") + ")";
    }
  }, {
    key: "getOpacityFromRGBA",
    value: function value(t) {
      return parseFloat(t.replace(/^.*,(.+)\)/, "$1"));
    }
  }, {
    key: "rgb2hex",
    value: function value(t) {
      return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t.length ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : "";
    }
  }, {
    key: "isColorHex",
    value: function value(t) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t);
    }
  }, {
    key: "getPolygonPos",
    value: function value(t, e) {
      for (var i = [], a = 2 * Math.PI / e, s = 0; s < e; s++) {
        var r = {};
        r.x = t * Math.sin(s * a), r.y = -t * Math.cos(s * a), i.push(r);
      }

      return i;
    }
  }, {
    key: "polarToCartesian",
    value: function value(t, e, i, a) {
      var s = (a - 90) * Math.PI / 180;
      return {
        x: t + i * Math.cos(s),
        y: e + i * Math.sin(s)
      };
    }
  }, {
    key: "escapeString",
    value: function value(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x",
          i = t.toString().slice();
      return i = i.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, e);
    }
  }, {
    key: "negToZero",
    value: function value(t) {
      return t < 0 ? 0 : t;
    }
  }, {
    key: "moveIndexInArray",
    value: function value(t, e, i) {
      if (i >= t.length) for (var a = i - t.length + 1; a--;) {
        t.push(void 0);
      }
      return t.splice(i, 0, t.splice(e, 1)[0]), t;
    }
  }, {
    key: "extractNumber",
    value: function value(t) {
      return parseFloat(t.replace(/[^\d.]*/g, ""));
    }
  }, {
    key: "findAncestor",
    value: function value(t, e) {
      for (; (t = t.parentElement) && !t.classList.contains(e);) {
        ;
      }

      return t;
    }
  }, {
    key: "setELstyles",
    value: function value(t, e) {
      for (var i in e) {
        e.hasOwnProperty(i) && (t.style.key = e[i]);
      }
    }
  }, {
    key: "isNumber",
    value: function value(t) {
      return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10));
    }
  }, {
    key: "isFloat",
    value: function value(t) {
      return Number(t) === t && t % 1 != 0;
    }
  }, {
    key: "isSafari",
    value: function value() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
  }, {
    key: "isFirefox",
    value: function value() {
      return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    }
  }, {
    key: "isIE11",
    value: function value() {
      if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return !0;
    }
  }, {
    key: "isIE",
    value: function value() {
      var t = window.navigator.userAgent,
          e = t.indexOf("MSIE ");
      if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);

      if (t.indexOf("Trident/") > 0) {
        var i = t.indexOf("rv:");
        return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10);
      }

      var a = t.indexOf("Edge/");
      return a > 0 && parseInt(t.substring(a + 5, t.indexOf(".", a)), 10);
    }
  }]), i;
}(),
    p = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.setEasingFunctions();
  }

  return a(t, [{
    key: "setEasingFunctions",
    value: function value() {
      var t;

      if (!this.w.globals.easing) {
        switch (this.w.config.chart.animations.easing) {
          case "linear":
            t = "-";
            break;

          case "easein":
            t = "<";
            break;

          case "easeout":
            t = ">";
            break;

          case "easeinout":
            t = "<>";
            break;

          case "swing":
            t = function t(_t) {
              var e = 1.70158;
              return (_t -= 1) * _t * ((e + 1) * _t + e) + 1;
            };

            break;

          case "bounce":
            t = function t(_t2) {
              return _t2 < 1 / 2.75 ? 7.5625 * _t2 * _t2 : _t2 < 2 / 2.75 ? 7.5625 * (_t2 -= 1.5 / 2.75) * _t2 + .75 : _t2 < 2.5 / 2.75 ? 7.5625 * (_t2 -= 2.25 / 2.75) * _t2 + .9375 : 7.5625 * (_t2 -= 2.625 / 2.75) * _t2 + .984375;
            };

            break;

          case "elastic":
            t = function t(_t3) {
              return _t3 === !!_t3 ? _t3 : Math.pow(2, -10 * _t3) * Math.sin((_t3 - .075) * (2 * Math.PI) / .3) + 1;
            };

            break;

          default:
            t = "<>";
        }

        this.w.globals.easing = t;
      }
    }
  }, {
    key: "animateLine",
    value: function value(t, e, i, a) {
      t.attr(e).animate(a).attr(i);
    }
  }, {
    key: "animateMarker",
    value: function value(t, e, i, a, s, r) {
      e || (e = 0), t.attr({
        r: e,
        width: e,
        height: e
      }).animate(a, s).attr({
        r: i,
        width: i.width,
        height: i.height
      }).afterAll(function () {
        r();
      });
    }
  }, {
    key: "animateCircle",
    value: function value(t, e, i, a, s) {
      t.attr({
        r: e.r,
        cx: e.cx,
        cy: e.cy
      }).animate(a, s).attr({
        r: i.r,
        cx: i.cx,
        cy: i.cy
      });
    }
  }, {
    key: "animateRect",
    value: function value(t, e, i, a, s) {
      t.attr(e).animate(a).attr(i).afterAll(function () {
        return s();
      });
    }
  }, {
    key: "animatePathsGradually",
    value: function value(t) {
      var e = t.el,
          i = t.realIndex,
          a = t.j,
          s = t.fill,
          r = t.pathFrom,
          n = t.pathTo,
          o = t.speed,
          l = t.delay,
          h = this.w,
          c = 0;
      h.config.chart.animations.animateGradually.enabled && (c = h.config.chart.animations.animateGradually.delay), h.config.chart.animations.dynamicAnimation.enabled && h.globals.dataChanged && "bar" !== h.config.chart.type && (c = 0), this.morphSVG(e, i, a, "line" !== h.config.chart.type || h.globals.comboCharts ? s : "stroke", r, n, o, l * c);
    }
  }, {
    key: "showDelayedElements",
    value: function value() {
      this.w.globals.delayedElements.forEach(function (t) {
        t.el.classList.remove("apexcharts-element-hidden");
      });
    }
  }, {
    key: "animationCompleted",
    value: function value(t) {
      var e = this.w;
      e.globals.animationEnded || (e.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof e.config.chart.events.animationEnd && e.config.chart.events.animationEnd(this.ctx, {
        el: t,
        w: e
      }));
    }
  }, {
    key: "morphSVG",
    value: function value(t, e, i, a, s, r, n, o) {
      var l = this,
          h = this.w;
      s || (s = t.attr("pathFrom")), r || (r = t.attr("pathTo"));

      var c = function c(t) {
        return "radar" === h.config.chart.type && (n = 1), "M 0 ".concat(h.globals.gridHeight);
      };

      (!s || s.indexOf("undefined") > -1 || s.indexOf("NaN") > -1) && (s = c()), (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = c()), h.globals.shouldAnimate || (n = 1), t.plot(s).animate(1, h.globals.easing, o).plot(s).animate(n, h.globals.easing, o).plot(r).afterAll(function () {
        f.isNumber(i) ? i === h.globals.series[h.globals.maxValsInArrayIndex].length - 2 && h.globals.shouldAnimate && l.animationCompleted(t) : "none" !== a && h.globals.shouldAnimate && (!h.globals.comboCharts && e === h.globals.series.length - 1 || h.globals.comboCharts) && l.animationCompleted(t), l.showDelayedElements();
      });
    }
  }]), t;
}(),
    x = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "getDefaultFilter",
    value: function value(t, e) {
      var i = this.w;
      t.unfilter(!0), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), "none" !== i.config.states.normal.filter ? this.applyFilter(t, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e);
    }
  }, {
    key: "addNormalFilter",
    value: function value(t, e) {
      var i = this.w;
      i.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, i.config.chart.dropShadow, e);
    }
  }, {
    key: "addLightenFilter",
    value: function value(t, e, i) {
      var a = this,
          s = this.w,
          r = i.intensity;
      t.unfilter(!0);
      new window.SVG.Filter();
      t.filter(function (t) {
        var i = s.config.chart.dropShadow;
        (i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({
          rgb: {
            type: "linear",
            slope: 1.5,
            intercept: r
          }
        });
      }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
    }
  }, {
    key: "addDarkenFilter",
    value: function value(t, e, i) {
      var a = this,
          s = this.w,
          r = i.intensity;
      t.unfilter(!0);
      new window.SVG.Filter();
      t.filter(function (t) {
        var i = s.config.chart.dropShadow;
        (i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({
          rgb: {
            type: "linear",
            slope: r
          }
        });
      }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
    }
  }, {
    key: "applyFilter",
    value: function value(t, e, i) {
      var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;

      switch (i) {
        case "none":
          this.addNormalFilter(t, e);
          break;

        case "lighten":
          this.addLightenFilter(t, e, {
            intensity: a
          });
          break;

        case "darken":
          this.addDarkenFilter(t, e, {
            intensity: a
          });
      }
    }
  }, {
    key: "addShadow",
    value: function value(t, e, i) {
      var a = i.blur,
          s = i.top,
          r = i.left,
          n = i.color,
          o = i.opacity,
          l = t.flood(Array.isArray(n) ? n[e] : n, o).composite(t.sourceAlpha, "in").offset(r, s).gaussianBlur(a).merge(t.source);
      return t.blend(t.source, l);
    }
  }, {
    key: "dropShadow",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
          a = e.top,
          s = e.left,
          r = e.blur,
          n = e.color,
          o = e.opacity,
          l = e.noUserSpaceOnUse,
          h = this.w;
      return t.unfilter(!0), f.isIE() && "radialBar" === h.config.chart.type || (n = Array.isArray(n) ? n[i] : n, t.filter(function (t) {
        var e = null;
        e = f.isSafari() || f.isFirefox() || f.isIE() ? t.flood(n, o).composite(t.sourceAlpha, "in").offset(s, a).gaussianBlur(r) : t.flood(n, o).composite(t.sourceAlpha, "in").offset(s, a).gaussianBlur(r).merge(t.source), t.blend(t.source, e);
      }), l || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t;
    }
  }, {
    key: "setSelectionFilter",
    value: function value(t, e, i) {
      var a = this.w;

      if (void 0 !== a.globals.selectedDataPoints[e] && a.globals.selectedDataPoints[e].indexOf(i) > -1) {
        t.node.setAttribute("selected", !0);
        var s = a.config.states.active.filter;
        "none" !== s && this.applyFilter(t, e, s.type, s.value);
      }
    }
  }, {
    key: "_scaleFilterSize",
    value: function value(t) {
      !function (e) {
        for (var i in e) {
          e.hasOwnProperty(i) && t.setAttribute(i, e[i]);
        }
      }({
        width: "200%",
        height: "200%",
        x: "-50%",
        y: "-50%"
      });
    }
  }]), t;
}(),
    b = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "drawLine",
    value: function value(t, e, i, a) {
      var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8",
          r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
          n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
          o = this.w,
          l = o.globals.dom.Paper.line().attr({
        x1: t,
        y1: e,
        x2: i,
        y2: a,
        stroke: s,
        "stroke-dasharray": r,
        "stroke-width": n
      });
      return l;
    }
  }, {
    key: "drawRect",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
          a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
          s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
          r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe",
          n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1,
          o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
          l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null,
          h = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0,
          c = this.w,
          d = c.globals.dom.Paper.rect();
      return d.attr({
        x: t,
        y: e,
        width: i > 0 ? i : 0,
        height: a > 0 ? a : 0,
        rx: s,
        ry: s,
        opacity: n,
        "stroke-width": null !== o ? o : 0,
        stroke: null !== l ? l : "none",
        "stroke-dasharray": h
      }), d.node.setAttribute("fill", r), d;
    }
  }, {
    key: "drawPolygon",
    value: function value(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1",
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
          a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none",
          s = this.w,
          r = s.globals.dom.Paper.polygon(t).attr({
        fill: a,
        stroke: e,
        "stroke-width": i
      });
      return r;
    }
  }, {
    key: "drawCircle",
    value: function value(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
          i = this.w,
          a = i.globals.dom.Paper.circle(2 * t);
      return null !== e && a.attr(e), a;
    }
  }, {
    key: "drawPath",
    value: function value(t) {
      var e = t.d,
          i = void 0 === e ? "" : e,
          a = t.stroke,
          s = void 0 === a ? "#a8a8a8" : a,
          r = t.strokeWidth,
          n = void 0 === r ? 1 : r,
          o = t.fill,
          l = t.fillOpacity,
          h = void 0 === l ? 1 : l,
          c = t.strokeOpacity,
          d = void 0 === c ? 1 : c,
          g = t.classes,
          u = t.strokeLinecap,
          f = void 0 === u ? null : u,
          p = t.strokeDashArray,
          x = void 0 === p ? 0 : p,
          b = this.w;
      return null === f && (f = b.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(b.globals.gridHeight)), b.globals.dom.Paper.path(i).attr({
        fill: o,
        "fill-opacity": h,
        stroke: s,
        "stroke-opacity": d,
        "stroke-linecap": f,
        "stroke-width": n,
        "stroke-dasharray": x,
        "class": g
      });
    }
  }, {
    key: "group",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
          e = this.w,
          i = e.globals.dom.Paper.group();
      return null !== t && i.attr(t), i;
    }
  }, {
    key: "move",
    value: function value(t, e) {
      var i = ["M", t, e].join(" ");
      return i;
    }
  }, {
    key: "line",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
          a = null;
      return null === i ? a = ["L", t, e].join(" ") : "H" === i ? a = ["H", t].join(" ") : "V" === i && (a = ["V", e].join(" ")), a;
    }
  }, {
    key: "curve",
    value: function value(t, e, i, a, s, r) {
      var n = ["C", t, e, i, a, s, r].join(" ");
      return n;
    }
  }, {
    key: "quadraticCurve",
    value: function value(t, e, i, a) {
      return ["Q", t, e, i, a].join(" ");
    }
  }, {
    key: "arc",
    value: function value(t, e, i, a, s, r, n) {
      var o = arguments.length > 7 && void 0 !== arguments[7] && arguments[7],
          l = "A";
      o && (l = "a");
      var h = [l, t, e, i, a, s, r, n].join(" ");
      return h;
    }
  }, {
    key: "renderPaths",
    value: function value(t) {
      var e,
          i = t.j,
          a = t.realIndex,
          s = t.pathFrom,
          r = t.pathTo,
          o = t.stroke,
          l = t.strokeWidth,
          h = t.strokeLinecap,
          c = t.fill,
          d = t.animationDelay,
          g = t.initialSpeed,
          u = t.dataChangeSpeed,
          f = t.className,
          b = t.shouldClipToGrid,
          m = void 0 === b || b,
          v = t.bindEventsOnPaths,
          y = void 0 === v || v,
          w = t.drawShadow,
          k = void 0 === w || w,
          A = this.w,
          S = new x(this.ctx),
          C = new p(this.ctx),
          L = this.w.config.chart.animations.enabled,
          P = L && this.w.config.chart.animations.dynamicAnimation.enabled,
          T = !!(L && !A.globals.resized || P && A.globals.dataChanged && A.globals.shouldAnimate);
      T ? e = s : (e = r, A.globals.animationEnded = !0);
      var z = A.config.stroke.dashArray,
          I = 0;
      I = Array.isArray(z) ? z[a] : A.config.stroke.dashArray;
      var M = this.drawPath({
        d: e,
        stroke: o,
        strokeWidth: l,
        fill: c,
        fillOpacity: 1,
        classes: f,
        strokeLinecap: h,
        strokeDashArray: I
      });
      if (M.attr("index", a), m && M.attr({
        "clip-path": "url(#gridRectMask".concat(A.globals.cuid, ")")
      }), "none" !== A.config.states.normal.filter.type) S.getDefaultFilter(M, a);else if (A.config.chart.dropShadow.enabled && k && (!A.config.chart.dropShadow.enabledOnSeries || A.config.chart.dropShadow.enabledOnSeries && -1 !== A.config.chart.dropShadow.enabledOnSeries.indexOf(a))) {
        var E = A.config.chart.dropShadow;
        S.dropShadow(M, E, a);
      }
      y && (M.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, M)), M.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, M)), M.node.addEventListener("mousedown", this.pathMouseDown.bind(this, M))), M.attr({
        pathTo: r,
        pathFrom: s
      });
      var X = {
        el: M,
        j: i,
        realIndex: a,
        pathFrom: s,
        pathTo: r,
        fill: c,
        strokeWidth: l,
        delay: d
      };
      return !L || A.globals.resized || A.globals.dataChanged ? !A.globals.resized && A.globals.dataChanged || C.showDelayedElements() : C.animatePathsGradually(n(n({}, X), {}, {
        speed: g
      })), A.globals.dataChanged && P && T && C.animatePathsGradually(n(n({}, X), {}, {
        speed: u
      })), M;
    }
  }, {
    key: "drawPattern",
    value: function value(t, e, i) {
      var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8",
          s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
          r = this.w,
          n = r.globals.dom.Paper.pattern(e, i, function (r) {
        "horizontalLines" === t ? r.line(0, 0, i, 0).stroke({
          color: a,
          width: s + 1
        }) : "verticalLines" === t ? r.line(0, 0, 0, e).stroke({
          color: a,
          width: s + 1
        }) : "slantedLines" === t ? r.line(0, 0, e, i).stroke({
          color: a,
          width: s
        }) : "squares" === t ? r.rect(e, i).fill("none").stroke({
          color: a,
          width: s
        }) : "circles" === t && r.circle(e).fill("none").stroke({
          color: a,
          width: s
        });
      });
      return n;
    }
  }, {
    key: "drawGradient",
    value: function value(t, e, i, a, s) {
      var r,
          n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
          o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
          l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
          h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
          c = this.w;
      e.length < 9 && 0 === e.indexOf("#") && (e = f.hexToRgba(e, a)), i.length < 9 && 0 === i.indexOf("#") && (i = f.hexToRgba(i, s));
      var d = 0,
          g = 1,
          u = 1,
          p = null;
      null !== o && (d = void 0 !== o[0] ? o[0] / 100 : 0, g = void 0 !== o[1] ? o[1] / 100 : 1, u = void 0 !== o[2] ? o[2] / 100 : 1, p = void 0 !== o[3] ? o[3] / 100 : null);
      var x = !("donut" !== c.config.chart.type && "pie" !== c.config.chart.type && "polarArea" !== c.config.chart.type && "bubble" !== c.config.chart.type);

      if (r = null === l || 0 === l.length ? c.globals.dom.Paper.gradient(x ? "radial" : "linear", function (t) {
        t.at(d, e, a), t.at(g, i, s), t.at(u, i, s), null !== p && t.at(p, e, a);
      }) : c.globals.dom.Paper.gradient(x ? "radial" : "linear", function (t) {
        (Array.isArray(l[h]) ? l[h] : l).forEach(function (e) {
          t.at(e.offset / 100, e.color, e.opacity);
        });
      }), x) {
        var b = c.globals.gridWidth / 2,
            m = c.globals.gridHeight / 2;
        "bubble" !== c.config.chart.type ? r.attr({
          gradientUnits: "userSpaceOnUse",
          cx: b,
          cy: m,
          r: n
        }) : r.attr({
          cx: .5,
          cy: .5,
          r: .8,
          fx: .2,
          fy: .2
        });
      } else "vertical" === t ? r.from(0, 0).to(0, 1) : "diagonal" === t ? r.from(0, 0).to(1, 1) : "horizontal" === t ? r.from(0, 1).to(1, 1) : "diagonal2" === t && r.from(1, 0).to(0, 1);

      return r;
    }
  }, {
    key: "drawText",
    value: function value(t) {
      var e,
          i = t.x,
          a = t.y,
          s = t.text,
          r = t.textAnchor,
          n = t.fontSize,
          o = t.fontFamily,
          l = t.fontWeight,
          h = t.foreColor,
          c = t.opacity,
          d = t.cssClass,
          g = void 0 === d ? "" : d,
          u = t.isPlainText,
          f = void 0 === u || u,
          p = this.w;
      return void 0 === s && (s = ""), r || (r = "start"), h && h.length || (h = p.config.chart.foreColor), o = o || p.config.chart.fontFamily, l = l || "regular", (e = Array.isArray(s) ? p.globals.dom.Paper.text(function (t) {
        for (var e = 0; e < s.length; e++) {
          0 === e ? t.tspan(s[e]) : t.tspan(s[e]).newLine();
        }
      }) : f ? p.globals.dom.Paper.plain(s) : p.globals.dom.Paper.text(function (t) {
        return t.tspan(s);
      })).attr({
        x: i,
        y: a,
        "text-anchor": r,
        "dominant-baseline": "auto",
        "font-size": n,
        "font-family": o,
        "font-weight": l,
        fill: h,
        "class": "apexcharts-text " + g
      }), e.node.style.fontFamily = o, e.node.style.opacity = c, e;
    }
  }, {
    key: "drawMarker",
    value: function value(t, e, i) {
      t = t || 0;
      var a = i.pSize || 0,
          s = null;

      if ("square" === i.shape || "rect" === i.shape) {
        var r = void 0 === i.pRadius ? a / 2 : i.pRadius;
        null !== e && a || (a = 0, r = 0);
        var n = 1.2 * a + r,
            o = this.drawRect(n, n, n, n, r);
        o.attr({
          x: t - n / 2,
          y: e - n / 2,
          cx: t,
          cy: e,
          "class": i["class"] ? i["class"] : "",
          fill: i.pointFillColor,
          "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
          stroke: i.pointStrokeColor,
          "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
          "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
        }), s = o;
      } else "circle" !== i.shape && i.shape || (f.isNumber(e) || (a = 0, e = 0), s = this.drawCircle(a, {
        cx: t,
        cy: e,
        "class": i["class"] ? i["class"] : "",
        stroke: i.pointStrokeColor,
        fill: i.pointFillColor,
        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
      }));

      return s;
    }
  }, {
    key: "pathMouseEnter",
    value: function value(t, e) {
      var i = this.w,
          a = new x(this.ctx),
          s = parseInt(t.node.getAttribute("index"), 10),
          r = parseInt(t.node.getAttribute("j"), 10);

      if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(e, this.ctx, {
        seriesIndex: s,
        dataPointIndex: r,
        w: i
      }), this.ctx.events.fireEvent("dataPointMouseEnter", [e, this.ctx, {
        seriesIndex: s,
        dataPointIndex: r,
        w: i
      }]), ("none" === i.config.states.active.filter.type || "true" !== t.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && "none" !== i.config.states.active.filter.type && !i.globals.isTouchDevice) {
        var n = i.config.states.hover.filter;
        a.applyFilter(t, s, n.type, n.value);
      }
    }
  }, {
    key: "pathMouseLeave",
    value: function value(t, e) {
      var i = this.w,
          a = new x(this.ctx),
          s = parseInt(t.node.getAttribute("index"), 10),
          r = parseInt(t.node.getAttribute("j"), 10);
      "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(e, this.ctx, {
        seriesIndex: s,
        dataPointIndex: r,
        w: i
      }), this.ctx.events.fireEvent("dataPointMouseLeave", [e, this.ctx, {
        seriesIndex: s,
        dataPointIndex: r,
        w: i
      }]), "none" !== i.config.states.active.filter.type && "true" === t.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && a.getDefaultFilter(t, s);
    }
  }, {
    key: "pathMouseDown",
    value: function value(t, e) {
      var i = this.w,
          a = new x(this.ctx),
          s = parseInt(t.node.getAttribute("index"), 10),
          r = parseInt(t.node.getAttribute("j"), 10),
          n = "false";

      if ("true" === t.node.getAttribute("selected")) {
        if (t.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[s].indexOf(r) > -1) {
          var o = i.globals.selectedDataPoints[s].indexOf(r);
          i.globals.selectedDataPoints[s].splice(o, 1);
        }
      } else {
        if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
          i.globals.selectedDataPoints = [];

          var l = i.globals.dom.Paper.select(".apexcharts-series path").members,
              h = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,
              c = function c(t) {
            Array.prototype.forEach.call(t, function (t) {
              t.node.setAttribute("selected", "false"), a.getDefaultFilter(t, s);
            });
          };

          c(l), c(h);
        }

        t.node.setAttribute("selected", "true"), n = "true", void 0 === i.globals.selectedDataPoints[s] && (i.globals.selectedDataPoints[s] = []), i.globals.selectedDataPoints[s].push(r);
      }

      if ("true" === n) {
        var d = i.config.states.active.filter;
        "none" !== d && a.applyFilter(t, s, d.type, d.value);
      } else "none" !== i.config.states.active.filter.type && a.getDefaultFilter(t, s);

      "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(e, this.ctx, {
        selectedDataPoints: i.globals.selectedDataPoints,
        seriesIndex: s,
        dataPointIndex: r,
        w: i
      }), e && this.ctx.events.fireEvent("dataPointSelection", [e, this.ctx, {
        selectedDataPoints: i.globals.selectedDataPoints,
        seriesIndex: s,
        dataPointIndex: r,
        w: i
      }]);
    }
  }, {
    key: "rotateAroundCenter",
    value: function value(t) {
      var e = t.getBBox();
      return {
        x: e.x + e.width / 2,
        y: e.y + e.height / 2
      };
    }
  }, {
    key: "getTextRects",
    value: function value(t, e, i, a) {
      var s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
          r = this.w,
          n = this.drawText({
        x: -200,
        y: -200,
        text: t,
        textAnchor: "start",
        fontSize: e,
        fontFamily: i,
        foreColor: "#fff",
        opacity: 0
      });
      a && n.attr("transform", a), r.globals.dom.Paper.add(n);
      var o = n.bbox();
      return s || (o = n.node.getBoundingClientRect()), n.remove(), {
        width: o.width,
        height: o.height
      };
    }
  }, {
    key: "placeTextWithEllipsis",
    value: function value(t, e, i) {
      if ("function" == typeof t.getComputedTextLength && (t.textContent = e, e.length > 0 && t.getComputedTextLength() >= i / 1.1)) {
        for (var a = e.length - 3; a > 0; a -= 3) {
          if (t.getSubStringLength(0, a) <= i / 1.1) return void (t.textContent = e.substring(0, a) + "...");
        }

        t.textContent = ".";
      }
    }
  }], [{
    key: "setAttrs",
    value: function value(t, e) {
      for (var i in e) {
        e.hasOwnProperty(i) && t.setAttribute(i, e[i]);
      }
    }
  }]), t;
}(),
    m = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.annoCtx = i;
  }

  return a(t, [{
    key: "setOrientations",
    value: function value(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
          i = this.w;

      if ("vertical" === t.label.orientation) {
        var a = null !== e ? e : 0,
            s = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a, "']"));

        if (null !== s) {
          var r = s.getBoundingClientRect();
          s.setAttribute("x", parseFloat(s.getAttribute("x")) - r.height + 4), "top" === t.label.position ? s.setAttribute("y", parseFloat(s.getAttribute("y")) + r.width) : s.setAttribute("y", parseFloat(s.getAttribute("y")) - r.width);
          var n = this.annoCtx.graphics.rotateAroundCenter(s),
              o = n.x,
              l = n.y;
          s.setAttribute("transform", "rotate(-90 ".concat(o, " ").concat(l, ")"));
        }
      }
    }
  }, {
    key: "addBackgroundToAnno",
    value: function value(t, e) {
      var i = this.w;
      if (!t || !e.label.text || e.label.text && !e.label.text.trim()) return null;
      var a = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),
          s = t.getBoundingClientRect(),
          r = e.label.style.padding.left,
          n = e.label.style.padding.right,
          o = e.label.style.padding.top,
          l = e.label.style.padding.bottom;
      "vertical" === e.label.orientation && (o = e.label.style.padding.left, l = e.label.style.padding.right, r = e.label.style.padding.top, n = e.label.style.padding.bottom);
      var h = s.left - a.left - r,
          c = s.top - a.top - o,
          d = this.annoCtx.graphics.drawRect(h - i.globals.barPadForNumericAxis, c, s.width + r + n, s.height + o + l, e.label.borderRadius, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0);
      return e.id && d.node.classList.add(e.id), d;
    }
  }, {
    key: "annotationsBackground",
    value: function value() {
      var t = this,
          e = this.w,
          i = function i(_i, a, s) {
        var r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(a, "']"));

        if (r) {
          var n = r.parentNode,
              o = t.addBackgroundToAnno(r, _i);
          o && n.insertBefore(o.node, r);
        }
      };

      e.config.annotations.xaxis.map(function (t, e) {
        i(t, e, "xaxis");
      }), e.config.annotations.yaxis.map(function (t, e) {
        i(t, e, "yaxis");
      }), e.config.annotations.points.map(function (t, e) {
        i(t, e, "point");
      });
    }
  }, {
    key: "getStringX",
    value: function value(t) {
      var e = this.w,
          i = t;
      e.config.xaxis.convertedCatToNumeric && e.globals.categoryLabels.length && (t = e.globals.categoryLabels.indexOf(t) + 1);
      var a = e.globals.labels.indexOf(t),
          s = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a + 1) + ")");
      return s && (i = parseFloat(s.getAttribute("x"))), i;
    }
  }]), t;
}(),
    v = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.annoCtx = i, this.invertAxis = this.annoCtx.invertAxis;
  }

  return a(t, [{
    key: "addXaxisAnnotation",
    value: function value(t, e, i) {
      var a = this.w,
          s = this.invertAxis ? a.globals.minY : a.globals.minX,
          r = this.invertAxis ? a.globals.maxY : a.globals.maxX,
          n = this.invertAxis ? a.globals.yRange[0] : a.globals.xRange,
          o = (t.x - s) / (n / a.globals.gridWidth);
      this.annoCtx.inversedReversedAxis && (o = (r - t.x) / (n / a.globals.gridWidth));
      var l = t.label.text;
      "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || a.globals.dataFormatXNumeric || (o = this.annoCtx.helpers.getStringX(t.x));
      var h = t.strokeDashArray;

      if (f.isNumber(o)) {
        if (null === t.x2 || void 0 === t.x2) {
          var c = this.annoCtx.graphics.drawLine(o + t.offsetX, 0 + t.offsetY, o + t.offsetX, a.globals.gridHeight + t.offsetY, t.borderColor, h, t.borderWidth);
          e.appendChild(c.node), t.id && c.node.classList.add(t.id);
        } else {
          var d = (t.x2 - s) / (n / a.globals.gridWidth);

          if (this.annoCtx.inversedReversedAxis && (d = (r - t.x2) / (n / a.globals.gridWidth)), "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || a.globals.dataFormatXNumeric || (d = this.annoCtx.helpers.getStringX(t.x2)), d < o) {
            var g = o;
            o = d, d = g;
          }

          var u = this.annoCtx.graphics.drawRect(o + t.offsetX, 0 + t.offsetY, d - o, a.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, h);
          u.node.classList.add("apexcharts-annotation-rect"), u.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")), e.appendChild(u.node), t.id && u.node.classList.add(t.id);
        }

        var p = "top" === t.label.position ? 4 : a.globals.gridHeight,
            x = this.annoCtx.graphics.getTextRects(l, parseFloat(t.label.style.fontSize)),
            b = this.annoCtx.graphics.drawText({
          x: o + t.label.offsetX,
          y: p + t.label.offsetY - ("vertical" === t.label.orientation ? "top" === t.label.position ? x.width / 2 - 12 : -x.width / 2 : 0),
          text: l,
          textAnchor: t.label.textAnchor,
          fontSize: t.label.style.fontSize,
          fontFamily: t.label.style.fontFamily,
          fontWeight: t.label.style.fontWeight,
          foreColor: t.label.style.color,
          cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
        });
        b.attr({
          rel: i
        }), e.appendChild(b.node), this.annoCtx.helpers.setOrientations(t, i);
      }
    }
  }, {
    key: "drawXAxisAnnotations",
    value: function value() {
      var t = this,
          e = this.w,
          i = this.annoCtx.graphics.group({
        "class": "apexcharts-xaxis-annotations"
      });
      return e.config.annotations.xaxis.map(function (e, a) {
        t.addXaxisAnnotation(e, i.node, a);
      }), i;
    }
  }]), t;
}(),
    y = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "getStackedSeriesTotals",
    value: function value() {
      var t = this.w,
          e = [];
      if (0 === t.globals.series.length) return e;

      for (var i = 0; i < t.globals.series[t.globals.maxValsInArrayIndex].length; i++) {
        for (var a = 0, s = 0; s < t.globals.series.length; s++) {
          void 0 !== t.globals.series[s][i] && (a += t.globals.series[s][i]);
        }

        e.push(a);
      }

      return t.globals.stackedSeriesTotals = e, e;
    }
  }, {
    key: "getSeriesTotalByIndex",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return null === t ? this.w.config.series.reduce(function (t, e) {
        return t + e;
      }, 0) : this.w.globals.series[t].reduce(function (t, e) {
        return t + e;
      }, 0);
    }
  }, {
    key: "isSeriesNull",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return 0 === (null === t ? this.w.config.series.filter(function (t) {
        return null !== t;
      }) : this.w.config.series[t].data.filter(function (t) {
        return null !== t;
      })).length;
    }
  }, {
    key: "seriesHaveSameValues",
    value: function value(t) {
      return this.w.globals.series[t].every(function (t, e, i) {
        return t === i[0];
      });
    }
  }, {
    key: "getCategoryLabels",
    value: function value(t) {
      var e = this.w,
          i = t.slice();
      return e.config.xaxis.convertedCatToNumeric && (i = t.map(function (t, i) {
        return e.config.xaxis.labels.formatter(t - e.globals.minX + 1);
      })), i;
    }
  }, {
    key: "getLargestSeries",
    value: function value() {
      var t = this.w;
      t.globals.maxValsInArrayIndex = t.globals.series.map(function (t) {
        return t.length;
      }).indexOf(Math.max.apply(Math, t.globals.series.map(function (t) {
        return t.length;
      })));
    }
  }, {
    key: "getLargestMarkerSize",
    value: function value() {
      var t = this.w,
          e = 0;
      return t.globals.markers.size.forEach(function (t) {
        e = Math.max(e, t);
      }), t.globals.markers.largestSize = e, e;
    }
  }, {
    key: "getSeriesTotals",
    value: function value() {
      var t = this.w;
      t.globals.seriesTotals = t.globals.series.map(function (t, e) {
        var i = 0;
        if (Array.isArray(t)) for (var a = 0; a < t.length; a++) {
          i += t[a];
        } else i += t;
        return i;
      });
    }
  }, {
    key: "getSeriesTotalsXRange",
    value: function value(t, e) {
      var i = this.w;
      return i.globals.series.map(function (a, s) {
        for (var r = 0, n = 0; n < a.length; n++) {
          i.globals.seriesX[s][n] > t && i.globals.seriesX[s][n] < e && (r += a[n]);
        }

        return r;
      });
    }
  }, {
    key: "getPercentSeries",
    value: function value() {
      var t = this.w;
      t.globals.seriesPercent = t.globals.series.map(function (e, i) {
        var a = [];
        if (Array.isArray(e)) for (var s = 0; s < e.length; s++) {
          var r = t.globals.stackedSeriesTotals[s],
              n = 0;
          r && (n = 100 * e[s] / r), a.push(n);
        } else {
          var o = 100 * e / t.globals.seriesTotals.reduce(function (t, e) {
            return t + e;
          }, 0);
          a.push(o);
        }
        return a;
      });
    }
  }, {
    key: "getCalculatedRatios",
    value: function value() {
      var t,
          e,
          i,
          a,
          s = this.w.globals,
          r = [],
          n = 0,
          o = [],
          l = .1,
          h = 0;
      if (s.yRange = [], s.isMultipleYAxis) for (var c = 0; c < s.minYArr.length; c++) {
        s.yRange.push(Math.abs(s.minYArr[c] - s.maxYArr[c])), o.push(0);
      } else s.yRange.push(Math.abs(s.minY - s.maxY));
      s.xRange = Math.abs(s.maxX - s.minX), s.zRange = Math.abs(s.maxZ - s.minZ);

      for (var d = 0; d < s.yRange.length; d++) {
        r.push(s.yRange[d] / s.gridHeight);
      }

      if (e = s.xRange / s.gridWidth, i = Math.abs(s.initialMaxX - s.initialMinX) / s.gridWidth, t = s.yRange / s.gridWidth, a = s.xRange / s.gridHeight, (n = s.zRange / s.gridHeight * 16) || (n = 1), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (s.hasNegs = !0), s.isMultipleYAxis) {
        o = [];

        for (var g = 0; g < r.length; g++) {
          o.push(-s.minYArr[g] / r[g]);
        }
      } else o.push(-s.minY / r[0]), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (l = -s.minY / t, h = s.minX / e);

      return {
        yRatio: r,
        invertedYRatio: t,
        zRatio: n,
        xRatio: e,
        initialXRatio: i,
        invertedXRatio: a,
        baseLineInvertedY: l,
        baseLineY: o,
        baseLineX: h
      };
    }
  }, {
    key: "getLogSeries",
    value: function value(t) {
      var e = this,
          i = this.w;
      return i.globals.seriesLog = t.map(function (t, a) {
        return i.config.yaxis[a] && i.config.yaxis[a].logarithmic ? t.map(function (t) {
          return null === t ? null : e.getLogVal(t, a);
        }) : t;
      }), i.globals.invalidLogScale ? t : i.globals.seriesLog;
    }
  }, {
    key: "getLogVal",
    value: function value(t, e) {
      var i = this.w;
      return (Math.log(t) - Math.log(i.globals.minYArr[e])) / (Math.log(i.globals.maxYArr[e]) - Math.log(i.globals.minYArr[e]));
    }
  }, {
    key: "getLogYRatios",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = this.w.globals;
      return a.yLogRatio = t.slice(), a.logYRange = a.yRange.map(function (t, s) {
        if (i.config.yaxis[s] && e.w.config.yaxis[s].logarithmic) {
          var r,
              n = -Number.MAX_VALUE,
              o = Number.MIN_VALUE;
          return a.seriesLog.forEach(function (t, e) {
            t.forEach(function (t) {
              i.config.yaxis[e] && i.config.yaxis[e].logarithmic && (n = Math.max(t, n), o = Math.min(t, o));
            });
          }), r = Math.pow(a.yRange[s], Math.abs(o - n) / a.yRange[s]), a.yLogRatio[s] = r / a.gridHeight, r;
        }
      }), a.invalidLogScale ? t.slice() : a.yLogRatio;
    }
  }], [{
    key: "checkComboSeries",
    value: function value(t) {
      var e = !1,
          i = 0,
          a = 0;
      return t.length && void 0 !== t[0].type && t.forEach(function (t) {
        "bar" !== t.type && "column" !== t.type && "candlestick" !== t.type && "boxPlot" !== t.type || i++, void 0 !== t.type && a++;
      }), a > 1 && (e = !0), {
        comboBarCount: i,
        comboCharts: e
      };
    }
  }, {
    key: "extendArrayProps",
    value: function value(t, e, i) {
      return e.yaxis && (e = t.extendYAxis(e, i)), e.annotations && (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)), e.annotations.points && (e = t.extendPointAnnotations(e))), e;
    }
  }]), t;
}(),
    w = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.annoCtx = i;
  }

  return a(t, [{
    key: "addYaxisAnnotation",
    value: function value(t, e, i) {
      var a,
          s = this.w,
          r = t.strokeDashArray,
          n = this._getY1Y2("y1", t),
          o = t.label.text;

      if (null === t.y2 || void 0 === t.y2) {
        var l = this.annoCtx.graphics.drawLine(0 + t.offsetX, n + t.offsetY, this._getYAxisAnnotationWidth(t), n + t.offsetY, t.borderColor, r, t.borderWidth);
        e.appendChild(l.node), t.id && l.node.classList.add(t.id);
      } else {
        if ((a = this._getY1Y2("y2", t)) > n) {
          var h = n;
          n = a, a = h;
        }

        var c = this.annoCtx.graphics.drawRect(0 + t.offsetX, a + t.offsetY, this._getYAxisAnnotationWidth(t), n - a, 0, t.fillColor, t.opacity, 1, t.borderColor, r);
        c.node.classList.add("apexcharts-annotation-rect"), c.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")), e.appendChild(c.node), t.id && c.node.classList.add(t.id);
      }

      var d = "right" === t.label.position ? s.globals.gridWidth : 0,
          g = this.annoCtx.graphics.drawText({
        x: d + t.label.offsetX,
        y: (a || n) + t.label.offsetY - 3,
        text: o,
        textAnchor: t.label.textAnchor,
        fontSize: t.label.style.fontSize,
        fontFamily: t.label.style.fontFamily,
        fontWeight: t.label.style.fontWeight,
        foreColor: t.label.style.color,
        cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
      });
      g.attr({
        rel: i
      }), e.appendChild(g.node);
    }
  }, {
    key: "_getY1Y2",
    value: function value(t, e) {
      var i,
          a = "y1" === t ? e.y : e.y2,
          s = this.w;

      if (this.annoCtx.invertAxis) {
        var r = s.globals.labels.indexOf(a);
        s.config.xaxis.convertedCatToNumeric && (r = s.globals.categoryLabels.indexOf(a));
        var n = s.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r + 1) + ")");
        n && (i = parseFloat(n.getAttribute("y")));
      } else {
        var o;
        if (s.config.yaxis[e.yAxisIndex].logarithmic) o = (a = new y(this.annoCtx.ctx).getLogVal(a, e.yAxisIndex)) / s.globals.yLogRatio[e.yAxisIndex];else o = (a - s.globals.minYArr[e.yAxisIndex]) / (s.globals.yRange[e.yAxisIndex] / s.globals.gridHeight);
        i = s.globals.gridHeight - o, s.config.yaxis[e.yAxisIndex] && s.config.yaxis[e.yAxisIndex].reversed && (i = o);
      }

      return i;
    }
  }, {
    key: "_getYAxisAnnotationWidth",
    value: function value(t) {
      var e = this.w;
      e.globals.gridWidth;
      return (t.width.indexOf("%") > -1 ? e.globals.gridWidth * parseInt(t.width, 10) / 100 : parseInt(t.width, 10)) + t.offsetX;
    }
  }, {
    key: "drawYAxisAnnotations",
    value: function value() {
      var t = this,
          e = this.w,
          i = this.annoCtx.graphics.group({
        "class": "apexcharts-yaxis-annotations"
      });
      return e.config.annotations.yaxis.map(function (e, a) {
        t.addYaxisAnnotation(e, i.node, a);
      }), i;
    }
  }]), t;
}(),
    k = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.annoCtx = i;
  }

  return a(t, [{
    key: "addPointAnnotation",
    value: function value(t, e, i) {
      var a = this.w,
          s = 0,
          r = 0,
          n = 0;
      this.annoCtx.invertAxis && console.warn("Point annotation is not supported in horizontal bar charts.");
      var o,
          l = parseFloat(t.y);

      if ("string" == typeof t.x) {
        var h = a.globals.labels.indexOf(t.x);
        a.config.xaxis.convertedCatToNumeric && (h = a.globals.categoryLabels.indexOf(t.x)), s = this.annoCtx.helpers.getStringX(t.x), null === t.y && (l = a.globals.series[t.seriesIndex][h]);
      } else s = (t.x - a.globals.minX) / (a.globals.xRange / a.globals.gridWidth);

      a.config.yaxis[t.yAxisIndex].logarithmic ? o = (l = new y(this.annoCtx.ctx).getLogVal(l, t.yAxisIndex)) / a.globals.yLogRatio[t.yAxisIndex] : o = (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight);

      if (r = a.globals.gridHeight - o - parseFloat(t.label.style.fontSize) - t.marker.size, n = a.globals.gridHeight - o, a.config.yaxis[t.yAxisIndex] && a.config.yaxis[t.yAxisIndex].reversed && (r = o + parseFloat(t.label.style.fontSize) + t.marker.size, n = o), f.isNumber(s)) {
        var c = {
          pSize: t.marker.size,
          pointStrokeWidth: t.marker.strokeWidth,
          pointFillColor: t.marker.fillColor,
          pointStrokeColor: t.marker.strokeColor,
          shape: t.marker.shape,
          pRadius: t.marker.radius,
          "class": "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "")
        },
            d = this.annoCtx.graphics.drawMarker(s + t.marker.offsetX, n + t.marker.offsetY, c);
        e.appendChild(d.node);
        var g = t.label.text ? t.label.text : "",
            u = this.annoCtx.graphics.drawText({
          x: s + t.label.offsetX,
          y: r + t.label.offsetY,
          text: g,
          textAnchor: t.label.textAnchor,
          fontSize: t.label.style.fontSize,
          fontFamily: t.label.style.fontFamily,
          fontWeight: t.label.style.fontWeight,
          foreColor: t.label.style.color,
          cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
        });

        if (u.attr({
          rel: i
        }), e.appendChild(u.node), t.customSVG.SVG) {
          var p = this.annoCtx.graphics.group({
            "class": "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass
          });
          p.attr({
            transform: "translate(".concat(s + t.customSVG.offsetX, ", ").concat(r + t.customSVG.offsetY, ")")
          }), p.node.innerHTML = t.customSVG.SVG, e.appendChild(p.node);
        }

        if (t.image.path) {
          var x = t.image.width ? t.image.width : 20,
              b = t.image.height ? t.image.height : 20;
          this.annoCtx.addImage({
            x: s + t.image.offsetX - x / 2,
            y: r + t.image.offsetY - b / 2,
            width: x,
            height: b,
            path: t.image.path,
            appendTo: ".apexcharts-point-annotations"
          });
        }
      }
    }
  }, {
    key: "drawPointAnnotations",
    value: function value() {
      var t = this,
          e = this.w,
          i = this.annoCtx.graphics.group({
        "class": "apexcharts-point-annotations"
      });
      return e.config.annotations.points.map(function (e, a) {
        t.addPointAnnotation(e, i.node, a);
      }), i;
    }
  }]), t;
}();

var A = {
  name: "en",
  options: {
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    toolbar: {
      exportToSVG: "Download SVG",
      exportToPNG: "Download PNG",
      exportToCSV: "Download CSV",
      menu: "Menu",
      selection: "Selection",
      selectionZoom: "Selection Zoom",
      zoomIn: "Zoom In",
      zoomOut: "Zoom Out",
      pan: "Panning",
      reset: "Reset Zoom"
    }
  }
},
    S = function () {
  function t() {
    e(this, t), this.yAxis = {
      show: !0,
      showAlways: !1,
      showForNullSeries: !0,
      seriesName: void 0,
      opposite: !1,
      reversed: !1,
      logarithmic: !1,
      tickAmount: void 0,
      forceNiceScale: !1,
      max: void 0,
      min: void 0,
      floating: !1,
      decimalsInFloat: void 0,
      labels: {
        show: !0,
        minWidth: 0,
        maxWidth: 160,
        offsetX: 0,
        offsetY: 0,
        align: void 0,
        rotate: 0,
        padding: 20,
        style: {
          colors: [],
          fontSize: "11px",
          fontWeight: 400,
          fontFamily: void 0,
          cssClass: ""
        },
        formatter: void 0
      },
      axisBorder: {
        show: !1,
        color: "#e0e0e0",
        width: 1,
        offsetX: 0,
        offsetY: 0
      },
      axisTicks: {
        show: !1,
        color: "#e0e0e0",
        width: 6,
        offsetX: 0,
        offsetY: 0
      },
      title: {
        text: void 0,
        rotate: -90,
        offsetY: 0,
        offsetX: 0,
        style: {
          color: void 0,
          fontSize: "11px",
          fontWeight: 900,
          fontFamily: void 0,
          cssClass: ""
        }
      },
      tooltip: {
        enabled: !1,
        offsetX: 0
      },
      crosshairs: {
        show: !0,
        position: "front",
        stroke: {
          color: "#b6b6b6",
          width: 1,
          dashArray: 0
        }
      }
    }, this.pointAnnotation = {
      x: 0,
      y: null,
      yAxisIndex: 0,
      seriesIndex: 0,
      marker: {
        size: 4,
        fillColor: "#fff",
        strokeWidth: 2,
        strokeColor: "#333",
        shape: "circle",
        offsetX: 0,
        offsetY: 0,
        radius: 2,
        cssClass: ""
      },
      label: {
        borderColor: "#c2c2c2",
        borderWidth: 1,
        borderRadius: 2,
        text: void 0,
        textAnchor: "middle",
        offsetX: 0,
        offsetY: 0,
        style: {
          background: "#fff",
          color: void 0,
          fontSize: "11px",
          fontFamily: void 0,
          fontWeight: 400,
          cssClass: "",
          padding: {
            left: 5,
            right: 5,
            top: 2,
            bottom: 2
          }
        }
      },
      customSVG: {
        SVG: void 0,
        cssClass: void 0,
        offsetX: 0,
        offsetY: 0
      },
      image: {
        path: void 0,
        width: 20,
        height: 20,
        offsetX: 0,
        offsetY: 0
      }
    }, this.yAxisAnnotation = {
      y: 0,
      y2: null,
      strokeDashArray: 1,
      fillColor: "#c2c2c2",
      borderColor: "#c2c2c2",
      borderWidth: 1,
      opacity: .3,
      offsetX: 0,
      offsetY: 0,
      width: "100%",
      yAxisIndex: 0,
      label: {
        borderColor: "#c2c2c2",
        borderWidth: 1,
        borderRadius: 2,
        text: void 0,
        textAnchor: "end",
        position: "right",
        offsetX: 0,
        offsetY: -3,
        style: {
          background: "#fff",
          color: void 0,
          fontSize: "11px",
          fontFamily: void 0,
          fontWeight: 400,
          cssClass: "",
          padding: {
            left: 5,
            right: 5,
            top: 2,
            bottom: 2
          }
        }
      }
    }, this.xAxisAnnotation = {
      x: 0,
      x2: null,
      strokeDashArray: 1,
      fillColor: "#c2c2c2",
      borderColor: "#c2c2c2",
      borderWidth: 1,
      opacity: .3,
      offsetX: 0,
      offsetY: 0,
      label: {
        borderColor: "#c2c2c2",
        borderWidth: 1,
        borderRadius: 2,
        text: void 0,
        textAnchor: "middle",
        orientation: "vertical",
        position: "top",
        offsetX: 0,
        offsetY: 0,
        style: {
          background: "#fff",
          color: void 0,
          fontSize: "11px",
          fontFamily: void 0,
          fontWeight: 400,
          cssClass: "",
          padding: {
            left: 5,
            right: 5,
            top: 2,
            bottom: 2
          }
        }
      }
    }, this.text = {
      x: 0,
      y: 0,
      text: "",
      textAnchor: "start",
      foreColor: void 0,
      fontSize: "13px",
      fontFamily: void 0,
      fontWeight: 400,
      appendTo: ".apexcharts-annotations",
      backgroundColor: "transparent",
      borderColor: "#c2c2c2",
      borderRadius: 0,
      borderWidth: 0,
      paddingLeft: 4,
      paddingRight: 4,
      paddingTop: 2,
      paddingBottom: 2
    };
  }

  return a(t, [{
    key: "init",
    value: function value() {
      return {
        annotations: {
          position: "front",
          yaxis: [this.yAxisAnnotation],
          xaxis: [this.xAxisAnnotation],
          points: [this.pointAnnotation],
          texts: [],
          images: [],
          shapes: []
        },
        chart: {
          animations: {
            enabled: !0,
            easing: "easeinout",
            speed: 800,
            animateGradually: {
              delay: 150,
              enabled: !0
            },
            dynamicAnimation: {
              enabled: !0,
              speed: 350
            }
          },
          background: "transparent",
          locales: [A],
          defaultLocale: "en",
          dropShadow: {
            enabled: !1,
            enabledOnSeries: void 0,
            top: 2,
            left: 2,
            blur: 4,
            color: "#000",
            opacity: .35
          },
          events: {
            animationEnd: void 0,
            beforeMount: void 0,
            mounted: void 0,
            updated: void 0,
            click: void 0,
            mouseMove: void 0,
            legendClick: void 0,
            markerClick: void 0,
            selection: void 0,
            dataPointSelection: void 0,
            dataPointMouseEnter: void 0,
            dataPointMouseLeave: void 0,
            beforeZoom: void 0,
            beforeResetZoom: void 0,
            zoomed: void 0,
            scrolled: void 0,
            brushScrolled: void 0
          },
          foreColor: "#373d3f",
          fontFamily: "Helvetica, Arial, sans-serif",
          height: "auto",
          parentHeightOffset: 15,
          redrawOnParentResize: !0,
          redrawOnWindowResize: !0,
          id: void 0,
          group: void 0,
          offsetX: 0,
          offsetY: 0,
          selection: {
            enabled: !1,
            type: "x",
            fill: {
              color: "#24292e",
              opacity: .1
            },
            stroke: {
              width: 1,
              color: "#24292e",
              opacity: .4,
              dashArray: 3
            },
            xaxis: {
              min: void 0,
              max: void 0
            },
            yaxis: {
              min: void 0,
              max: void 0
            }
          },
          sparkline: {
            enabled: !1
          },
          brush: {
            enabled: !1,
            autoScaleYaxis: !0,
            target: void 0
          },
          stacked: !1,
          stackType: "normal",
          toolbar: {
            show: !0,
            offsetX: 0,
            offsetY: 0,
            tools: {
              download: !0,
              selection: !0,
              zoom: !0,
              zoomin: !0,
              zoomout: !0,
              pan: !0,
              reset: !0,
              customIcons: []
            },
            "export": {
              csv: {
                filename: void 0,
                columnDelimiter: ",",
                headerCategory: "category",
                headerValue: "value",
                dateFormatter: function dateFormatter(t) {
                  return new Date(t).toDateString();
                }
              },
              png: {
                filename: void 0
              },
              svg: {
                filename: void 0
              }
            },
            autoSelected: "zoom"
          },
          type: "line",
          width: "100%",
          zoom: {
            enabled: !0,
            type: "x",
            autoScaleYaxis: !1,
            zoomedArea: {
              fill: {
                color: "#90CAF9",
                opacity: .4
              },
              stroke: {
                color: "#0D47A1",
                opacity: .4,
                width: 1
              }
            }
          }
        },
        plotOptions: {
          area: {
            fillTo: "origin"
          },
          bar: {
            horizontal: !1,
            columnWidth: "70%",
            barHeight: "70%",
            distributed: !1,
            borderRadius: 0,
            rangeBarOverlap: !0,
            rangeBarGroupRows: !1,
            colors: {
              ranges: [],
              backgroundBarColors: [],
              backgroundBarOpacity: 1,
              backgroundBarRadius: 0
            },
            dataLabels: {
              position: "top",
              maxItems: 100,
              hideOverflowingLabels: !0,
              orientation: "horizontal"
            }
          },
          bubble: {
            minBubbleRadius: void 0,
            maxBubbleRadius: void 0
          },
          candlestick: {
            colors: {
              upward: "#00B746",
              downward: "#EF403C"
            },
            wick: {
              useFillColor: !0
            }
          },
          boxPlot: {
            colors: {
              upper: "#00E396",
              lower: "#008FFB"
            }
          },
          heatmap: {
            radius: 2,
            enableShades: !0,
            shadeIntensity: .5,
            reverseNegativeShade: !1,
            distributed: !1,
            useFillColorAsStroke: !1,
            colorScale: {
              inverse: !1,
              ranges: [],
              min: void 0,
              max: void 0
            }
          },
          treemap: {
            enableShades: !0,
            shadeIntensity: .5,
            distributed: !1,
            reverseNegativeShade: !1,
            useFillColorAsStroke: !1,
            colorScale: {
              inverse: !1,
              ranges: [],
              min: void 0,
              max: void 0
            }
          },
          radialBar: {
            inverseOrder: !1,
            startAngle: 0,
            endAngle: 360,
            offsetX: 0,
            offsetY: 0,
            hollow: {
              margin: 5,
              size: "50%",
              background: "transparent",
              image: void 0,
              imageWidth: 150,
              imageHeight: 150,
              imageOffsetX: 0,
              imageOffsetY: 0,
              imageClipped: !0,
              position: "front",
              dropShadow: {
                enabled: !1,
                top: 0,
                left: 0,
                blur: 3,
                color: "#000",
                opacity: .5
              }
            },
            track: {
              show: !0,
              startAngle: void 0,
              endAngle: void 0,
              background: "#f2f2f2",
              strokeWidth: "97%",
              opacity: 1,
              margin: 5,
              dropShadow: {
                enabled: !1,
                top: 0,
                left: 0,
                blur: 3,
                color: "#000",
                opacity: .5
              }
            },
            dataLabels: {
              show: !0,
              name: {
                show: !0,
                fontSize: "16px",
                fontFamily: void 0,
                fontWeight: 600,
                color: void 0,
                offsetY: 0,
                formatter: function formatter(t) {
                  return t;
                }
              },
              value: {
                show: !0,
                fontSize: "14px",
                fontFamily: void 0,
                fontWeight: 400,
                color: void 0,
                offsetY: 16,
                formatter: function formatter(t) {
                  return t + "%";
                }
              },
              total: {
                show: !1,
                label: "Total",
                fontSize: "16px",
                fontWeight: 600,
                fontFamily: void 0,
                color: void 0,
                formatter: function formatter(t) {
                  return t.globals.seriesTotals.reduce(function (t, e) {
                    return t + e;
                  }, 0) / t.globals.series.length + "%";
                }
              }
            }
          },
          pie: {
            customScale: 1,
            offsetX: 0,
            offsetY: 0,
            startAngle: 0,
            endAngle: 360,
            expandOnClick: !0,
            dataLabels: {
              offset: 0,
              minAngleToShowLabel: 10
            },
            donut: {
              size: "65%",
              background: "transparent",
              labels: {
                show: !1,
                name: {
                  show: !0,
                  fontSize: "16px",
                  fontFamily: void 0,
                  fontWeight: 600,
                  color: void 0,
                  offsetY: -10,
                  formatter: function formatter(t) {
                    return t;
                  }
                },
                value: {
                  show: !0,
                  fontSize: "20px",
                  fontFamily: void 0,
                  fontWeight: 400,
                  color: void 0,
                  offsetY: 10,
                  formatter: function formatter(t) {
                    return t;
                  }
                },
                total: {
                  show: !1,
                  showAlways: !1,
                  label: "Total",
                  fontSize: "16px",
                  fontWeight: 400,
                  fontFamily: void 0,
                  color: void 0,
                  formatter: function formatter(t) {
                    return t.globals.seriesTotals.reduce(function (t, e) {
                      return t + e;
                    }, 0);
                  }
                }
              }
            }
          },
          polarArea: {
            rings: {
              strokeWidth: 1,
              strokeColor: "#e8e8e8"
            },
            spokes: {
              strokeWidth: 1,
              connectorColors: "#e8e8e8"
            }
          },
          radar: {
            size: void 0,
            offsetX: 0,
            offsetY: 0,
            polygons: {
              strokeWidth: 1,
              strokeColors: "#e8e8e8",
              connectorColors: "#e8e8e8",
              fill: {
                colors: void 0
              }
            }
          }
        },
        colors: void 0,
        dataLabels: {
          enabled: !0,
          enabledOnSeries: void 0,
          formatter: function formatter(t) {
            return null !== t ? t : "";
          },
          textAnchor: "middle",
          distributed: !1,
          offsetX: 0,
          offsetY: 0,
          style: {
            fontSize: "12px",
            fontFamily: void 0,
            fontWeight: 600,
            colors: void 0
          },
          background: {
            enabled: !0,
            foreColor: "#fff",
            borderRadius: 2,
            padding: 4,
            opacity: .9,
            borderWidth: 1,
            borderColor: "#fff",
            dropShadow: {
              enabled: !1,
              top: 1,
              left: 1,
              blur: 1,
              color: "#000",
              opacity: .45
            }
          },
          dropShadow: {
            enabled: !1,
            top: 1,
            left: 1,
            blur: 1,
            color: "#000",
            opacity: .45
          }
        },
        fill: {
          type: "solid",
          colors: void 0,
          opacity: .85,
          gradient: {
            shade: "dark",
            type: "horizontal",
            shadeIntensity: .5,
            gradientToColors: void 0,
            inverseColors: !0,
            opacityFrom: 1,
            opacityTo: 1,
            stops: [0, 50, 100],
            colorStops: []
          },
          image: {
            src: [],
            width: void 0,
            height: void 0
          },
          pattern: {
            style: "squares",
            width: 6,
            height: 6,
            strokeWidth: 2
          }
        },
        grid: {
          show: !0,
          borderColor: "#e0e0e0",
          strokeDashArray: 0,
          position: "back",
          xaxis: {
            lines: {
              show: !1
            }
          },
          yaxis: {
            lines: {
              show: !0
            }
          },
          row: {
            colors: void 0,
            opacity: .5
          },
          column: {
            colors: void 0,
            opacity: .5
          },
          padding: {
            top: 0,
            right: 10,
            bottom: 0,
            left: 12
          }
        },
        labels: [],
        legend: {
          show: !0,
          showForSingleSeries: !1,
          showForNullSeries: !0,
          showForZeroSeries: !0,
          floating: !1,
          position: "bottom",
          horizontalAlign: "center",
          inverseOrder: !1,
          fontSize: "12px",
          fontFamily: void 0,
          fontWeight: 400,
          width: void 0,
          height: void 0,
          formatter: void 0,
          tooltipHoverFormatter: void 0,
          offsetX: -20,
          offsetY: 4,
          labels: {
            colors: void 0,
            useSeriesColors: !1
          },
          markers: {
            width: 12,
            height: 12,
            strokeWidth: 0,
            fillColors: void 0,
            strokeColor: "#fff",
            radius: 12,
            customHTML: void 0,
            offsetX: 0,
            offsetY: 0,
            onClick: void 0
          },
          itemMargin: {
            horizontal: 5,
            vertical: 2
          },
          onItemClick: {
            toggleDataSeries: !0
          },
          onItemHover: {
            highlightDataSeries: !0
          }
        },
        markers: {
          discrete: [],
          size: 0,
          colors: void 0,
          strokeColors: "#fff",
          strokeWidth: 2,
          strokeOpacity: .9,
          strokeDashArray: 0,
          fillOpacity: 1,
          shape: "circle",
          width: 8,
          height: 8,
          radius: 2,
          offsetX: 0,
          offsetY: 0,
          onClick: void 0,
          onDblClick: void 0,
          showNullDataPoints: !0,
          hover: {
            size: void 0,
            sizeOffset: 3
          }
        },
        noData: {
          text: void 0,
          align: "center",
          verticalAlign: "middle",
          offsetX: 0,
          offsetY: 0,
          style: {
            color: void 0,
            fontSize: "14px",
            fontFamily: void 0
          }
        },
        responsive: [],
        series: void 0,
        states: {
          normal: {
            filter: {
              type: "none",
              value: 0
            }
          },
          hover: {
            filter: {
              type: "lighten",
              value: .1
            }
          },
          active: {
            allowMultipleDataPointsSelection: !1,
            filter: {
              type: "darken",
              value: .5
            }
          }
        },
        title: {
          text: void 0,
          align: "left",
          margin: 5,
          offsetX: 0,
          offsetY: 0,
          floating: !1,
          style: {
            fontSize: "14px",
            fontWeight: 900,
            fontFamily: void 0,
            color: void 0
          }
        },
        subtitle: {
          text: void 0,
          align: "left",
          margin: 5,
          offsetX: 0,
          offsetY: 30,
          floating: !1,
          style: {
            fontSize: "12px",
            fontWeight: 400,
            fontFamily: void 0,
            color: void 0
          }
        },
        stroke: {
          show: !0,
          curve: "smooth",
          lineCap: "butt",
          width: 2,
          colors: void 0,
          dashArray: 0
        },
        tooltip: {
          enabled: !0,
          enabledOnSeries: void 0,
          shared: !0,
          followCursor: !1,
          intersect: !1,
          inverseOrder: !1,
          custom: void 0,
          fillSeriesColor: !1,
          theme: "light",
          style: {
            fontSize: "12px",
            fontFamily: void 0
          },
          onDatasetHover: {
            highlightDataSeries: !1
          },
          x: {
            show: !0,
            format: "dd MMM",
            formatter: void 0
          },
          y: {
            formatter: void 0,
            title: {
              formatter: function formatter(t) {
                return t ? t + ": " : "";
              }
            }
          },
          z: {
            formatter: void 0,
            title: "Size: "
          },
          marker: {
            show: !0,
            fillColors: void 0
          },
          items: {
            display: "flex"
          },
          fixed: {
            enabled: !1,
            position: "topRight",
            offsetX: 0,
            offsetY: 0
          }
        },
        xaxis: {
          type: "category",
          categories: [],
          convertedCatToNumeric: !1,
          sorted: !1,
          offsetX: 0,
          offsetY: 0,
          labels: {
            show: !0,
            rotate: -45,
            rotateAlways: !1,
            hideOverlappingLabels: !0,
            trim: !1,
            minHeight: void 0,
            maxHeight: 120,
            showDuplicates: !0,
            style: {
              colors: [],
              fontSize: "12px",
              fontWeight: 400,
              fontFamily: void 0,
              cssClass: ""
            },
            offsetX: 0,
            offsetY: 0,
            format: void 0,
            formatter: void 0,
            datetimeUTC: !0,
            datetimeFormatter: {
              year: "yyyy",
              month: "MMM 'yy",
              day: "dd MMM",
              hour: "HH:mm",
              minute: "HH:mm:ss"
            }
          },
          axisBorder: {
            show: !0,
            color: "#e0e0e0",
            width: "100%",
            height: 1,
            offsetX: 0,
            offsetY: 0
          },
          axisTicks: {
            show: !0,
            color: "#e0e0e0",
            height: 6,
            offsetX: 0,
            offsetY: 0
          },
          tickAmount: void 0,
          tickPlacement: "on",
          min: void 0,
          max: void 0,
          range: void 0,
          floating: !1,
          position: "bottom",
          title: {
            text: void 0,
            offsetX: 0,
            offsetY: 0,
            style: {
              color: void 0,
              fontSize: "12px",
              fontWeight: 900,
              fontFamily: void 0,
              cssClass: ""
            }
          },
          crosshairs: {
            show: !0,
            width: 1,
            position: "back",
            opacity: .9,
            stroke: {
              color: "#b6b6b6",
              width: 1,
              dashArray: 3
            },
            fill: {
              type: "solid",
              color: "#B1B9C4",
              gradient: {
                colorFrom: "#D8E3F0",
                colorTo: "#BED1E6",
                stops: [0, 100],
                opacityFrom: .4,
                opacityTo: .5
              }
            },
            dropShadow: {
              enabled: !1,
              left: 0,
              top: 0,
              blur: 1,
              opacity: .4
            }
          },
          tooltip: {
            enabled: !0,
            offsetY: 0,
            formatter: void 0,
            style: {
              fontSize: "12px",
              fontFamily: void 0
            }
          }
        },
        yaxis: this.yAxis,
        theme: {
          mode: "light",
          palette: "palette1",
          monochrome: {
            enabled: !1,
            color: "#008FFB",
            shadeTo: "light",
            shadeIntensity: .65
          }
        }
      };
    }
  }]), t;
}(),
    C = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.graphics = new b(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new m(this), this.xAxisAnnotations = new v(this), this.yAxisAnnotations = new w(this), this.pointsAnnotations = new k(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }

  return a(t, [{
    key: "drawAxesAnnotations",
    value: function value() {
      var t = this.w;

      if (t.globals.axisCharts) {
        for (var e = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), a = this.pointsAnnotations.drawPointAnnotations(), s = t.config.chart.animations.enabled, r = [e, i, a], n = [i.node, e.node, a.node], o = 0; o < 3; o++) {
          t.globals.dom.elGraphical.add(r[o]), !s || t.globals.resized || t.globals.dataChanged || "scatter" !== t.config.chart.type && "bubble" !== t.config.chart.type && t.globals.dataPoints > 1 && n[o].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({
            el: n[o],
            index: 0
          });
        }

        this.helpers.annotationsBackground();
      }
    }
  }, {
    key: "drawImageAnnos",
    value: function value() {
      var t = this;
      this.w.config.annotations.images.map(function (e, i) {
        t.addImage(e, i);
      });
    }
  }, {
    key: "drawTextAnnos",
    value: function value() {
      var t = this;
      this.w.config.annotations.texts.map(function (e, i) {
        t.addText(e, i);
      });
    }
  }, {
    key: "addXaxisAnnotation",
    value: function value(t, e, i) {
      this.xAxisAnnotations.addXaxisAnnotation(t, e, i);
    }
  }, {
    key: "addYaxisAnnotation",
    value: function value(t, e, i) {
      this.yAxisAnnotations.addYaxisAnnotation(t, e, i);
    }
  }, {
    key: "addPointAnnotation",
    value: function value(t, e, i) {
      this.pointsAnnotations.addPointAnnotation(t, e, i);
    }
  }, {
    key: "addText",
    value: function value(t, e) {
      var i = t.x,
          a = t.y,
          s = t.text,
          r = t.textAnchor,
          n = t.foreColor,
          o = t.fontSize,
          l = t.fontFamily,
          h = t.fontWeight,
          c = t.cssClass,
          d = t.backgroundColor,
          g = t.borderWidth,
          u = t.strokeDashArray,
          f = t.borderRadius,
          p = t.borderColor,
          x = t.appendTo,
          b = void 0 === x ? ".apexcharts-annotations" : x,
          m = t.paddingLeft,
          v = void 0 === m ? 4 : m,
          y = t.paddingRight,
          w = void 0 === y ? 4 : y,
          k = t.paddingBottom,
          A = void 0 === k ? 2 : k,
          S = t.paddingTop,
          C = void 0 === S ? 2 : S,
          L = this.w,
          P = this.graphics.drawText({
        x: i,
        y: a,
        text: s,
        textAnchor: r || "start",
        fontSize: o || "12px",
        fontWeight: h || "regular",
        fontFamily: l || L.config.chart.fontFamily,
        foreColor: n || L.config.chart.foreColor,
        cssClass: c
      }),
          T = L.globals.dom.baseEl.querySelector(b);
      T && T.appendChild(P.node);
      var z = P.bbox();

      if (s) {
        var I = this.graphics.drawRect(z.x - v, z.y - C, z.width + v + w, z.height + A + C, f, d || "transparent", 1, g, p, u);
        T.insertBefore(I.node, P.node);
      }
    }
  }, {
    key: "addImage",
    value: function value(t, e) {
      var i = this.w,
          a = t.path,
          s = t.x,
          r = void 0 === s ? 0 : s,
          n = t.y,
          o = void 0 === n ? 0 : n,
          l = t.width,
          h = void 0 === l ? 20 : l,
          c = t.height,
          d = void 0 === c ? 20 : c,
          g = t.appendTo,
          u = void 0 === g ? ".apexcharts-annotations" : g,
          f = i.globals.dom.Paper.image(a);
      f.size(h, d).move(r, o);
      var p = i.globals.dom.baseEl.querySelector(u);
      p && p.appendChild(f.node);
    }
  }, {
    key: "addXaxisAnnotationExternal",
    value: function value(t, e, i) {
      return this.addAnnotationExternal({
        params: t,
        pushToMemory: e,
        context: i,
        type: "xaxis",
        contextMethod: i.addXaxisAnnotation
      }), i;
    }
  }, {
    key: "addYaxisAnnotationExternal",
    value: function value(t, e, i) {
      return this.addAnnotationExternal({
        params: t,
        pushToMemory: e,
        context: i,
        type: "yaxis",
        contextMethod: i.addYaxisAnnotation
      }), i;
    }
  }, {
    key: "addPointAnnotationExternal",
    value: function value(t, e, i) {
      return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
        params: t,
        pushToMemory: e,
        context: i,
        type: "point",
        contextMethod: i.addPointAnnotation
      }), i;
    }
  }, {
    key: "addAnnotationExternal",
    value: function value(t) {
      var e = t.params,
          i = t.pushToMemory,
          a = t.context,
          s = t.type,
          r = t.contextMethod,
          n = a,
          o = n.w,
          l = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations")),
          h = l.childNodes.length + 1,
          c = new S(),
          d = Object.assign({}, "xaxis" === s ? c.xAxisAnnotation : "yaxis" === s ? c.yAxisAnnotation : c.pointAnnotation),
          g = f.extend(d, e);

      switch (s) {
        case "xaxis":
          this.addXaxisAnnotation(g, l, h);
          break;

        case "yaxis":
          this.addYaxisAnnotation(g, l, h);
          break;

        case "point":
          this.addPointAnnotation(g, l, h);
      }

      var u = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(h, "']")),
          p = this.helpers.addBackgroundToAnno(u, g);
      return p && l.insertBefore(p.node, u), i && o.globals.memory.methodsToExec.push({
        context: n,
        id: g.id ? g.id : f.randomId(),
        method: r,
        label: "addAnnotation",
        params: e
      }), a;
    }
  }, {
    key: "clearAnnotations",
    value: function value(t) {
      var e = t.w,
          i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
      e.globals.memory.methodsToExec.map(function (t, i) {
        "addText" !== t.label && "addAnnotation" !== t.label || e.globals.memory.methodsToExec.splice(i, 1);
      }), i = f.listToArray(i), Array.prototype.forEach.call(i, function (t) {
        for (; t.firstChild;) {
          t.removeChild(t.firstChild);
        }
      });
    }
  }, {
    key: "removeAnnotation",
    value: function value(t, e) {
      var i = t.w,
          a = i.globals.dom.baseEl.querySelectorAll(".".concat(e));
      a && (i.globals.memory.methodsToExec.map(function (t, a) {
        t.id === e && i.globals.memory.methodsToExec.splice(a, 1);
      }), Array.prototype.forEach.call(a, function (t) {
        t.parentElement.removeChild(t);
      }));
    }
  }]), t;
}(),
    L = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.opts = null, this.seriesIndex = 0;
  }

  return a(t, [{
    key: "clippedImgArea",
    value: function value(t) {
      var e = this.w,
          i = e.config,
          a = parseInt(e.globals.gridWidth, 10),
          s = parseInt(e.globals.gridHeight, 10),
          r = a > s ? a : s,
          n = t.image,
          o = 0,
          l = 0;
      void 0 === t.width && void 0 === t.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1, l = i.fill.image.height) : (o = r + 1, l = r) : (o = t.width, l = t.height);
      var h = document.createElementNS(e.globals.SVGNS, "pattern");
      b.setAttrs(h, {
        id: t.patternID,
        patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse",
        width: o + "px",
        height: l + "px"
      });
      var c = document.createElementNS(e.globals.SVGNS, "image");
      h.appendChild(c), c.setAttributeNS(window.SVG.xlink, "href", n), b.setAttrs(c, {
        x: 0,
        y: 0,
        preserveAspectRatio: "none",
        width: o + "px",
        height: l + "px"
      }), c.style.opacity = t.opacity, e.globals.dom.elDefs.node.appendChild(h);
    }
  }, {
    key: "getSeriesIndex",
    value: function value(t) {
      var e = this.w;
      return ("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || "heatmap" === e.config.chart.type || "treemap" === e.config.chart.type ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % e.globals.series.length, this.seriesIndex;
    }
  }, {
    key: "fillPath",
    value: function value(t) {
      var e = this.w;
      this.opts = t;
      var i,
          a,
          s,
          r = this.w.config;
      this.seriesIndex = this.getSeriesIndex(t);
      var n = this.getFillColors()[this.seriesIndex];
      void 0 !== e.globals.seriesColors[this.seriesIndex] && (n = e.globals.seriesColors[this.seriesIndex]), "function" == typeof n && (n = n({
        seriesIndex: this.seriesIndex,
        dataPointIndex: t.dataPointIndex,
        value: t.value,
        w: e
      }));
      var o = this.getFillType(this.seriesIndex),
          l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity;
      t.color && (n = t.color);
      var h = n;

      if (-1 === n.indexOf("rgb") ? n.length < 9 && (h = f.hexToRgba(n, l)) : n.indexOf("rgba") > -1 && (l = f.getOpacityFromRGBA(n)), t.opacity && (l = t.opacity), "pattern" === o && (a = this.handlePatternFill(a, n, l, h)), "gradient" === o && (s = this.handleGradientFill(n, l, this.seriesIndex)), "image" === o) {
        var c = r.fill.image.src,
            d = t.patternID ? t.patternID : "";
        this.clippedImgArea({
          opacity: l,
          image: Array.isArray(c) ? t.seriesNumber < c.length ? c[t.seriesNumber] : c[0] : c,
          width: t.width ? t.width : void 0,
          height: t.height ? t.height : void 0,
          patternUnits: t.patternUnits,
          patternID: "pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d)
        }), i = "url(#pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d, ")");
      } else i = "gradient" === o ? s : "pattern" === o ? a : h;

      return t.solid && (i = h), i;
    }
  }, {
    key: "getFillType",
    value: function value(t) {
      var e = this.w;
      return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type;
    }
  }, {
    key: "getFillColors",
    value: function value() {
      var t = this.w,
          e = t.config,
          i = this.opts,
          a = [];
      return t.globals.comboCharts ? "line" === t.config.series[this.seriesIndex].type ? Array.isArray(t.globals.stroke.colors) ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? a = t.globals.fill.colors : a.push(t.globals.fill.colors) : "line" === e.chart.type ? Array.isArray(t.globals.stroke.colors) ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? a = t.globals.fill.colors : a.push(t.globals.fill.colors), void 0 !== i.fillColors && (a = [], Array.isArray(i.fillColors) ? a = i.fillColors.slice() : a.push(i.fillColors)), a;
    }
  }, {
    key: "handlePatternFill",
    value: function value(t, e, i, a) {
      var s = this.w.config,
          r = this.opts,
          n = new b(this.ctx),
          o = void 0 === s.fill.pattern.strokeWidth ? Array.isArray(s.stroke.width) ? s.stroke.width[this.seriesIndex] : s.stroke.width : Array.isArray(s.fill.pattern.strokeWidth) ? s.fill.pattern.strokeWidth[this.seriesIndex] : s.fill.pattern.strokeWidth,
          l = e;
      Array.isArray(s.fill.pattern.style) ? t = void 0 !== s.fill.pattern.style[r.seriesNumber] ? n.drawPattern(s.fill.pattern.style[r.seriesNumber], s.fill.pattern.width, s.fill.pattern.height, l, o, i) : a : t = n.drawPattern(s.fill.pattern.style, s.fill.pattern.width, s.fill.pattern.height, l, o, i);
      return t;
    }
  }, {
    key: "handleGradientFill",
    value: function value(t, e, i) {
      var a,
          s = this.w.config,
          r = this.opts,
          n = new b(this.ctx),
          o = new f(),
          l = s.fill.gradient.type,
          h = t,
          c = void 0 === s.fill.gradient.opacityFrom ? e : Array.isArray(s.fill.gradient.opacityFrom) ? s.fill.gradient.opacityFrom[i] : s.fill.gradient.opacityFrom;
      h.indexOf("rgba") > -1 && (c = f.getOpacityFromRGBA(h));
      var d = void 0 === s.fill.gradient.opacityTo ? e : Array.isArray(s.fill.gradient.opacityTo) ? s.fill.gradient.opacityTo[i] : s.fill.gradient.opacityTo;
      if (void 0 === s.fill.gradient.gradientToColors || 0 === s.fill.gradient.gradientToColors.length) a = "dark" === s.fill.gradient.shade ? o.shadeColor(-1 * parseFloat(s.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? f.rgb2hex(t) : t) : o.shadeColor(parseFloat(s.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? f.rgb2hex(t) : t);else if (s.fill.gradient.gradientToColors[r.seriesNumber]) {
        var g = s.fill.gradient.gradientToColors[r.seriesNumber];
        a = g, g.indexOf("rgba") > -1 && (d = f.getOpacityFromRGBA(g));
      } else a = t;

      if (s.fill.gradient.inverseColors) {
        var u = h;
        h = a, a = u;
      }

      return h.indexOf("rgb") > -1 && (h = f.rgb2hex(h)), a.indexOf("rgb") > -1 && (a = f.rgb2hex(a)), n.drawGradient(l, h, a, c, d, r.size, s.fill.gradient.stops, s.fill.gradient.colorStops, i);
    }
  }]), t;
}(),
    P = function () {
  function t(i, a) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "setGlobalMarkerSize",
    value: function value() {
      var t = this.w;

      if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
        if (t.globals.markers.size.length < t.globals.series.length + 1) for (var e = 0; e <= t.globals.series.length; e++) {
          void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0]);
        }
      } else t.globals.markers.size = t.config.series.map(function (e) {
        return t.config.markers.size;
      });
    }
  }, {
    key: "plotChartMarkers",
    value: function value(t, e, i, a) {
      var s,
          r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
          n = this.w,
          o = e,
          l = t,
          h = null,
          c = new b(this.ctx);
      if ((n.globals.markers.size[e] > 0 || r) && (h = c.group({
        "class": r ? "" : "apexcharts-series-markers"
      })).attr("clip-path", "url(#gridRectMarkerMask".concat(n.globals.cuid, ")")), Array.isArray(l.x)) for (var d = 0; d < l.x.length; d++) {
        var g = i;
        1 === i && 0 === d && (g = 0), 1 === i && 1 === d && (g = 1);
        var u = "apexcharts-marker";
        "line" !== n.config.chart.type && "area" !== n.config.chart.type || n.globals.comboCharts || n.config.tooltip.intersect || (u += " no-pointer-events");
        var p = Array.isArray(n.config.markers.size) ? n.globals.markers.size[e] > 0 : n.config.markers.size > 0;

        if (p || r) {
          f.isNumber(l.y[d]) ? u += " w".concat(f.randomId()) : u = "apexcharts-nullpoint";
          var m = this.getMarkerConfig(u, e, g);
          n.config.series[o].data[g] && (n.config.series[o].data[g].fillColor && (m.pointFillColor = n.config.series[o].data[g].fillColor), n.config.series[o].data[g].strokeColor && (m.pointStrokeColor = n.config.series[o].data[g].strokeColor)), a && (m.pSize = a), (s = c.drawMarker(l.x[d], l.y[d], m)).attr("rel", g), s.attr("j", g), s.attr("index", e), s.node.setAttribute("default-marker-size", m.pSize);
          var v = new x(this.ctx);
          v.setSelectionFilter(s, e, g), this.addEvents(s), h && h.add(s);
        } else void 0 === n.globals.pointsArray[e] && (n.globals.pointsArray[e] = []), n.globals.pointsArray[e].push([l.x[d], l.y[d]]);
      }
      return h;
    }
  }, {
    key: "getMarkerConfig",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
          a = this.w,
          s = this.getMarkerStyle(e),
          r = a.globals.markers.size[e],
          n = a.config.markers;
      return null !== i && n.discrete.length && n.discrete.map(function (t) {
        t.seriesIndex === e && t.dataPointIndex === i && (s.pointStrokeColor = t.strokeColor, s.pointFillColor = t.fillColor, r = t.size);
      }), {
        pSize: r,
        pRadius: n.radius,
        width: Array.isArray(n.width) ? n.width[e] : n.width,
        height: Array.isArray(n.height) ? n.height[e] : n.height,
        pointStrokeWidth: Array.isArray(n.strokeWidth) ? n.strokeWidth[e] : n.strokeWidth,
        pointStrokeColor: s.pointStrokeColor,
        pointFillColor: s.pointFillColor,
        shape: Array.isArray(n.shape) ? n.shape[e] : n.shape,
        "class": t,
        pointStrokeOpacity: Array.isArray(n.strokeOpacity) ? n.strokeOpacity[e] : n.strokeOpacity,
        pointStrokeDashArray: Array.isArray(n.strokeDashArray) ? n.strokeDashArray[e] : n.strokeDashArray,
        pointFillOpacity: Array.isArray(n.fillOpacity) ? n.fillOpacity[e] : n.fillOpacity,
        seriesIndex: e
      };
    }
  }, {
    key: "addEvents",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx);
      t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", e.config.markers.onClick), t.node.addEventListener("dblclick", e.config.markers.onDblClick), t.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t), {
        passive: !0
      });
    }
  }, {
    key: "getMarkerStyle",
    value: function value(t) {
      var e = this.w,
          i = e.globals.markers.colors,
          a = e.config.markers.strokeColor || e.config.markers.strokeColors;
      return {
        pointStrokeColor: Array.isArray(a) ? a[t] : a,
        pointFillColor: Array.isArray(i) ? i[t] : i
      };
    }
  }]), t;
}(),
    T = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
  }

  return a(t, [{
    key: "draw",
    value: function value(t, e, i) {
      var a = this.w,
          s = new b(this.ctx),
          r = i.realIndex,
          n = i.pointsPos,
          o = i.zRatio,
          l = i.elParent,
          h = s.group({
        "class": "apexcharts-series-markers apexcharts-series-".concat(a.config.chart.type)
      });
      if (h.attr("clip-path", "url(#gridRectMarkerMask".concat(a.globals.cuid, ")")), Array.isArray(n.x)) for (var c = 0; c < n.x.length; c++) {
        var d = e + 1,
            g = !0;
        0 === e && 0 === c && (d = 0), 0 === e && 1 === c && (d = 1);
        var u = 0,
            f = a.globals.markers.size[r];

        if (o !== 1 / 0) {
          f = a.globals.seriesZ[r][d] / o;
          var p = a.config.plotOptions.bubble;
          p.minBubbleRadius && f < p.minBubbleRadius && (f = p.minBubbleRadius), p.maxBubbleRadius && f > p.maxBubbleRadius && (f = p.maxBubbleRadius);
        }

        a.config.chart.animations.enabled || (u = f);
        var x = n.x[c],
            m = n.y[c];

        if (u = u || 0, null !== m && void 0 !== a.globals.series[r][d] || (g = !1), g) {
          var v = this.drawPoint(x, m, u, f, r, d, e);
          h.add(v);
        }

        l.add(h);
      }
    }
  }, {
    key: "drawPoint",
    value: function value(t, e, i, a, s, r, n) {
      var o,
          l = this.w,
          h = s,
          c = new p(this.ctx),
          d = new x(this.ctx),
          g = new L(this.ctx),
          u = new P(this.ctx),
          f = new b(this.ctx),
          m = u.getMarkerConfig("apexcharts-marker", h),
          v = g.fillPath({
        seriesNumber: s,
        dataPointIndex: r,
        patternUnits: "objectBoundingBox",
        value: l.globals.series[s][n]
      });

      if ("circle" === m.shape ? o = f.drawCircle(i) : "square" !== m.shape && "rect" !== m.shape || (o = f.drawRect(0, 0, m.width - m.pointStrokeWidth / 2, m.height - m.pointStrokeWidth / 2, m.pRadius)), l.config.series[h].data[r] && l.config.series[h].data[r].fillColor && (v = l.config.series[h].data[r].fillColor), o.attr({
        x: t - m.width / 2 - m.pointStrokeWidth / 2,
        y: e - m.height / 2 - m.pointStrokeWidth / 2,
        cx: t,
        cy: e,
        fill: v,
        "fill-opacity": m.pointFillOpacity,
        stroke: m.pointStrokeColor,
        r: a,
        "stroke-width": m.pointStrokeWidth,
        "stroke-dasharray": m.pointStrokeDashArray,
        "stroke-opacity": m.pointStrokeOpacity
      }), l.config.chart.dropShadow.enabled) {
        var y = l.config.chart.dropShadow;
        d.dropShadow(o, y, s);
      }

      if (!this.initialAnim || l.globals.dataChanged || l.globals.resized) l.globals.animationEnded = !0;else {
        var w = l.config.chart.animations.speed;
        c.animateMarker(o, 0, "circle" === m.shape ? a : {
          width: m.width,
          height: m.height
        }, w, l.globals.easing, function () {
          window.setTimeout(function () {
            c.animationCompleted(o);
          }, 100);
        });
      }
      if (l.globals.dataChanged && "circle" === m.shape) if (this.dynamicAnim) {
        var k,
            A,
            S,
            C,
            T = l.config.chart.animations.dynamicAnimation.speed;
        null != (C = l.globals.previousPaths[s] && l.globals.previousPaths[s][n]) && (k = C.x, A = C.y, S = void 0 !== C.r ? C.r : a);

        for (var z = 0; z < l.globals.collapsedSeries.length; z++) {
          l.globals.collapsedSeries[z].index === s && (T = 1, a = 0);
        }

        0 === t && 0 === e && (a = 0), c.animateCircle(o, {
          cx: k,
          cy: A,
          r: S
        }, {
          cx: t,
          cy: e,
          r: a
        }, T, l.globals.easing);
      } else o.attr({
        r: a
      });
      return o.attr({
        rel: r,
        j: r,
        index: s,
        "default-marker-size": a
      }), d.setSelectionFilter(o, s, r), u.addEvents(o), o.node.classList.add("apexcharts-marker"), o;
    }
  }, {
    key: "centerTextInBubble",
    value: function value(t) {
      var e = this.w;
      return {
        y: t += parseInt(e.config.dataLabels.style.fontSize, 10) / 4
      };
    }
  }]), t;
}(),
    z = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "dataLabelsCorrection",
    value: function value(t, e, i, a, s, r, n) {
      var o = this.w,
          l = !1,
          h = new b(this.ctx).getTextRects(i, n),
          c = h.width,
          d = h.height;
      e < 0 && (e = 0), e > o.globals.gridHeight + d && (e = o.globals.gridHeight + d / 2), void 0 === o.globals.dataLabelsRects[a] && (o.globals.dataLabelsRects[a] = []), o.globals.dataLabelsRects[a].push({
        x: t,
        y: e,
        width: c,
        height: d
      });
      var g = o.globals.dataLabelsRects[a].length - 2,
          u = void 0 !== o.globals.lastDrawnDataLabelsIndexes[a] ? o.globals.lastDrawnDataLabelsIndexes[a][o.globals.lastDrawnDataLabelsIndexes[a].length - 1] : 0;

      if (void 0 !== o.globals.dataLabelsRects[a][g]) {
        var f = o.globals.dataLabelsRects[a][u];
        (t > f.x + f.width + 2 || e > f.y + f.height + 2 || t + c < f.x) && (l = !0);
      }

      return (0 === s || r) && (l = !0), {
        x: t,
        y: e,
        textRects: h,
        drawnextLabel: l
      };
    }
  }, {
    key: "drawDataLabel",
    value: function value(t, e, i) {
      var a = this,
          s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2,
          r = this.w,
          n = new b(this.ctx),
          o = r.config.dataLabels,
          l = 0,
          h = 0,
          c = i,
          d = null;
      if (!o.enabled || !Array.isArray(t.x)) return d;
      d = n.group({
        "class": "apexcharts-data-labels"
      });

      for (var g = 0; g < t.x.length; g++) {
        if (l = t.x[g] + o.offsetX, h = t.y[g] + o.offsetY + s, !isNaN(l)) {
          1 === i && 0 === g && (c = 0), 1 === i && 1 === g && (c = 1);

          var u = r.globals.series[e][c],
              f = "",
              p = function p(t) {
            return r.config.dataLabels.formatter(t, {
              ctx: a.ctx,
              seriesIndex: e,
              dataPointIndex: c,
              w: r
            });
          };

          if ("bubble" === r.config.chart.type) {
            f = p(u = r.globals.seriesZ[e][c]), h = t.y[g];
            var x = new T(this.ctx),
                m = x.centerTextInBubble(h, e, c);
            h = m.y;
          } else void 0 !== u && (f = p(u));

          this.plotDataLabelsText({
            x: l,
            y: h,
            text: f,
            i: e,
            j: c,
            parent: d,
            offsetCorrection: !0,
            dataLabelsConfig: r.config.dataLabels
          });
        }
      }

      return d;
    }
  }, {
    key: "plotDataLabelsText",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx),
          a = t.x,
          s = t.y,
          r = t.i,
          n = t.j,
          o = t.text,
          l = t.textAnchor,
          h = t.fontSize,
          c = t.parent,
          d = t.dataLabelsConfig,
          g = t.color,
          u = t.alwaysDrawDataLabel,
          f = t.offsetCorrection;

      if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
        var p = {
          x: a,
          y: s,
          drawnextLabel: !0
        };
        f && (p = this.dataLabelsCorrection(a, s, o, r, n, u, parseInt(d.style.fontSize, 10))), e.globals.zoomed || (a = p.x, s = p.y), p.textRects;
        var m = e.globals.dataLabels.style.colors[r];
        (("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || e.config.dataLabels.distributed) && (m = e.globals.dataLabels.style.colors[n]), "function" == typeof m && (m = m({
          series: e.globals.series,
          seriesIndex: r,
          dataPointIndex: n,
          w: e
        })), g && (m = g);
        var v = d.offsetX,
            y = d.offsetY;

        if ("bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type || (v = 0, y = 0), p.drawnextLabel) {
          var w = i.drawText({
            width: 100,
            height: parseInt(d.style.fontSize, 10),
            x: a + v,
            y: s + y,
            foreColor: m,
            textAnchor: l || d.textAnchor,
            text: o,
            fontSize: h || d.style.fontSize,
            fontFamily: d.style.fontFamily,
            fontWeight: d.style.fontWeight || "normal"
          });

          if (w.attr({
            "class": "apexcharts-datalabel",
            cx: a,
            cy: s
          }), d.dropShadow.enabled) {
            var k = d.dropShadow;
            new x(this.ctx).dropShadow(w, k);
          }

          c.add(w), void 0 === e.globals.lastDrawnDataLabelsIndexes[r] && (e.globals.lastDrawnDataLabelsIndexes[r] = []), e.globals.lastDrawnDataLabelsIndexes[r].push(n);
        }
      }
    }
  }, {
    key: "addBackgroundToDataLabel",
    value: function value(t, e) {
      var i = this.w,
          a = i.config.dataLabels.background,
          s = a.padding,
          r = a.padding / 2,
          n = e.width,
          o = e.height,
          l = new b(this.ctx).drawRect(e.x - s, e.y - r / 2, n + 2 * s, o + r, a.borderRadius, "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background, a.opacity, a.borderWidth, a.borderColor);
      a.dropShadow.enabled && new x(this.ctx).dropShadow(l, a.dropShadow);
      return l;
    }
  }, {
    key: "dataLabelsBackground",
    value: function value() {
      var t = this.w;
      if ("bubble" !== t.config.chart.type) for (var e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < e.length; i++) {
        var a = e[i],
            s = a.getBBox(),
            r = null;

        if (s.width && s.height && (r = this.addBackgroundToDataLabel(a, s)), r) {
          a.parentNode.insertBefore(r.node, a);
          var n = a.getAttribute("fill");
          t.config.chart.animations.enabled && !t.globals.resized && !t.globals.dataChanged ? r.animate().attr({
            fill: n
          }) : r.attr({
            fill: n
          }), a.setAttribute("fill", t.config.dataLabels.background.foreColor);
        }
      }
    }
  }, {
    key: "bringForward",
    value: function value() {
      for (var t = this.w, e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a = 0; a < e.length; a++) {
        i && i.insertBefore(e[a], i.nextSibling);
      }
    }
  }]), t;
}(),
    I = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.barCtx = i;
  }

  return a(t, [{
    key: "handleBarDataLabels",
    value: function value(t) {
      var e = t.x,
          i = t.y,
          a = t.y1,
          s = t.y2,
          r = t.i,
          n = t.j,
          o = t.realIndex,
          l = t.series,
          h = t.barHeight,
          c = t.barWidth,
          d = t.barYPosition,
          g = t.visibleSeries,
          u = t.renderedPath,
          f = this.w,
          p = new b(this.barCtx.ctx),
          x = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth,
          m = e + parseFloat(c * g),
          v = i + parseFloat(h * g);
      f.globals.isXNumeric && !f.globals.isBarHorizontal && (m = e + parseFloat(c * (g + 1)), v = i + parseFloat(h * (g + 1)) - x);
      var y = e,
          w = i,
          k = {},
          A = f.config.dataLabels,
          S = this.barCtx.barOptions.dataLabels;
      void 0 !== d && this.barCtx.isTimelineBar && (v = d, w = d);
      var C = A.offsetX,
          L = A.offsetY,
          P = {
        width: 0,
        height: 0
      };

      if (f.config.dataLabels.enabled) {
        var T = this.barCtx.series[r][n];
        P = p.getTextRects(f.globals.yLabelFormatters[0](T), parseFloat(A.style.fontSize));
      }

      var z = {
        x: e,
        y: i,
        i: r,
        j: n,
        renderedPath: u,
        bcx: m,
        bcy: v,
        barHeight: h,
        barWidth: c,
        textRects: P,
        strokeWidth: x,
        dataLabelsX: y,
        dataLabelsY: w,
        barDataLabelsConfig: S,
        offX: C,
        offY: L
      };
      return k = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(z) : this.calculateColumnsDataLabelsPosition(z), u.attr({
        cy: k.bcy,
        cx: k.bcx,
        j: n,
        val: l[r][n],
        barHeight: h,
        barWidth: c
      }), this.drawCalculatedDataLabels({
        x: k.dataLabelsX,
        y: k.dataLabelsY,
        val: this.barCtx.isTimelineBar ? [a, s] : l[r][n],
        i: o,
        j: n,
        barWidth: c,
        barHeight: h,
        textRects: P,
        dataLabelsConfig: A
      });
    }
  }, {
    key: "calculateColumnsDataLabelsPosition",
    value: function value(t) {
      var e,
          i = this.w,
          a = t.i,
          s = t.j,
          r = t.y,
          n = t.bcx,
          o = t.barWidth,
          l = t.barHeight,
          h = t.textRects,
          c = t.dataLabelsY,
          d = t.barDataLabelsConfig,
          g = t.strokeWidth,
          u = t.offX,
          f = t.offY;
      l = Math.abs(l);
      var p = "vertical" === i.config.plotOptions.bar.dataLabels.orientation;
      n -= g / 2;
      var x = i.globals.gridWidth / i.globals.dataPoints;

      if (e = i.globals.isXNumeric ? n - o / 2 + u : n - x + o / 2 + u, p) {
        e = e + h.height / 2 - g / 2 - 2;
      }

      var b = this.barCtx.series[a][s] < 0,
          m = r;

      switch (this.barCtx.isReversed && (m = r - l + (b ? 2 * l : 0), r -= l), d.position) {
        case "center":
          c = p ? b ? m + l / 2 + f : m + l / 2 - f : b ? m - l / 2 + h.height / 2 + f : m + l / 2 + h.height / 2 - f;
          break;

        case "bottom":
          c = p ? b ? m + l + f : m + l - f : b ? m - l + h.height + g + f : m + l - h.height / 2 + g - f;
          break;

        case "top":
          c = p ? b ? m + f : m - f : b ? m - h.height / 2 - f : m + h.height + f;
      }

      return i.config.chart.stacked || (c < 0 ? c = 0 + g : c + h.height / 3 > i.globals.gridHeight && (c = i.globals.gridHeight - g)), {
        bcx: n,
        bcy: r,
        dataLabelsX: e,
        dataLabelsY: c
      };
    }
  }, {
    key: "calculateBarsDataLabelsPosition",
    value: function value(t) {
      var e = this.w,
          i = t.x,
          a = t.i,
          s = t.j,
          r = t.bcy,
          n = t.barHeight,
          o = t.barWidth,
          l = t.textRects,
          h = t.dataLabelsX,
          c = t.strokeWidth,
          d = t.barDataLabelsConfig,
          g = t.offX,
          u = t.offY,
          f = e.globals.gridHeight / e.globals.dataPoints;
      o = Math.abs(o);
      var p = r - (this.barCtx.isTimelineBar ? 0 : f) + n / 2 + l.height / 2 + u - 3,
          x = this.barCtx.series[a][s] < 0,
          b = i;

      switch (this.barCtx.isReversed && (b = i + o - (x ? 2 * o : 0), i = e.globals.gridWidth - o), d.position) {
        case "center":
          h = x ? b + o / 2 - g : Math.max(l.width / 2, b - o / 2) + g;
          break;

        case "bottom":
          h = x ? b + o - c - Math.round(l.width / 2) - g : b - o + c + Math.round(l.width / 2) + g;
          break;

        case "top":
          h = x ? b - c + Math.round(l.width / 2) - g : b - c - Math.round(l.width / 2) + g;
      }

      return e.config.chart.stacked || (h < 0 ? h = h + l.width + c : h + l.width / 2 > e.globals.gridWidth && (h = e.globals.gridWidth - l.width - c)), {
        bcx: i,
        bcy: r,
        dataLabelsX: h,
        dataLabelsY: p
      };
    }
  }, {
    key: "drawCalculatedDataLabels",
    value: function value(t) {
      var e = t.x,
          i = t.y,
          a = t.val,
          s = t.i,
          r = t.j,
          o = t.textRects,
          l = t.barHeight,
          h = t.barWidth,
          c = t.dataLabelsConfig,
          d = this.w,
          g = "rotate(0)";
      "vertical" === d.config.plotOptions.bar.dataLabels.orientation && (g = "rotate(-90, ".concat(e, ", ").concat(i, ")"));
      var u = new z(this.barCtx.ctx),
          f = new b(this.barCtx.ctx),
          p = c.formatter,
          x = null,
          m = d.globals.collapsedSeriesIndices.indexOf(s) > -1;

      if (c.enabled && !m) {
        x = f.group({
          "class": "apexcharts-data-labels",
          transform: g
        });
        var v = "";
        void 0 !== a && (v = p(a, {
          seriesIndex: s,
          dataPointIndex: r,
          w: d
        })), 0 === a && d.config.chart.stacked && (v = "");
        var y = d.globals.series[s][r] <= 0,
            w = d.config.plotOptions.bar.dataLabels.position;
        if ("vertical" === d.config.plotOptions.bar.dataLabels.orientation && ("top" === w && (c.textAnchor = y ? "end" : "start"), "center" === w && (c.textAnchor = "middle"), "bottom" === w && (c.textAnchor = y ? "end" : "start")), this.barCtx.isTimelineBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) h < f.getTextRects(v, parseFloat(c.style.fontSize)).width && (v = "");
        d.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? (h > 0 && o.width / 1.6 > h || h < 0 && o.width / 1.6 < h) && (v = "") : o.height / 1.6 > l && (v = ""));
        var k = n({}, c);
        this.barCtx.isHorizontal && a < 0 && ("start" === c.textAnchor ? k.textAnchor = "end" : "end" === c.textAnchor && (k.textAnchor = "start")), u.plotDataLabelsText({
          x: e,
          y: i,
          text: v,
          i: s,
          j: r,
          parent: x,
          dataLabelsConfig: k,
          alwaysDrawDataLabel: !0,
          offsetCorrection: !0
        });
      }

      return x;
    }
  }]), t;
}(),
    M = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.legendInactiveClass = "legend-mouseover-inactive";
  }

  return a(t, [{
    key: "getAllSeriesEls",
    value: function value() {
      return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
    }
  }, {
    key: "getSeriesByName",
    value: function value(t) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(f.escapeString(t), "']"));
    }
  }, {
    key: "isSeriesHidden",
    value: function value(t) {
      var e = this.getSeriesByName(t),
          i = parseInt(e.getAttribute("data:realIndex"), 10);
      return {
        isHidden: e.classList.contains("apexcharts-series-collapsed"),
        realIndex: i
      };
    }
  }, {
    key: "addCollapsedClassToSeries",
    value: function value(t, e) {
      var i = this.w;

      function a(i) {
        for (var a = 0; a < i.length; a++) {
          i[a].index === e && t.node.classList.add("apexcharts-series-collapsed");
        }
      }

      a(i.globals.collapsedSeries), a(i.globals.ancillaryCollapsedSeries);
    }
  }, {
    key: "toggleSeries",
    value: function value(t) {
      var e = this.isSeriesHidden(t);
      return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden;
    }
  }, {
    key: "showSeries",
    value: function value(t) {
      var e = this.isSeriesHidden(t);
      e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0);
    }
  }, {
    key: "hideSeries",
    value: function value(t) {
      var e = this.isSeriesHidden(t);
      e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1);
    }
  }, {
    key: "resetSeries",
    value: function value() {
      var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
          e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
          a = this.w,
          s = f.clone(a.globals.initialSeries);
      a.globals.previousPaths = [], i ? (a.globals.collapsedSeries = [], a.globals.ancillaryCollapsedSeries = [], a.globals.collapsedSeriesIndices = [], a.globals.ancillaryCollapsedSeriesIndices = []) : s = this.emptyCollapsedSeries(s), a.config.series = s, t && (e && (a.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled));
    }
  }, {
    key: "emptyCollapsedSeries",
    value: function value(t) {
      for (var e = this.w, i = 0; i < t.length; i++) {
        e.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t[i].data = []);
      }

      return t;
    }
  }, {
    key: "toggleSeriesOnHover",
    value: function value(t, e) {
      var i = this.w,
          a = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");

      if ("mousemove" === t.type) {
        var s = parseInt(e.getAttribute("rel"), 10) - 1,
            r = null,
            n = null;
        i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? (r = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s, "']")), n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s, "']"))) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "']")) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "'] path"));

        for (var o = 0; o < a.length; o++) {
          a[o].classList.add(this.legendInactiveClass);
        }

        null !== r && (i.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass), r.classList.remove(this.legendInactiveClass), null !== n && n.classList.remove(this.legendInactiveClass));
      } else if ("mouseout" === t.type) for (var l = 0; l < a.length; l++) {
        a[l].classList.remove(this.legendInactiveClass);
      }
    }
  }, {
    key: "highlightRangeInSeries",
    value: function value(t, e) {
      var i = this,
          a = this.w,
          s = a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),
          r = function r(t) {
        for (var e = 0; e < s.length; e++) {
          s[e].classList[t](i.legendInactiveClass);
        }
      };

      if ("mousemove" === t.type) {
        var n = parseInt(e.getAttribute("rel"), 10) - 1;
        r("add"), function (t) {
          for (var e = 0; e < s.length; e++) {
            var a = parseInt(s[e].getAttribute("val"), 10);
            a >= t.from && a <= t.to && s[e].classList.remove(i.legendInactiveClass);
          }
        }(a.config.plotOptions.heatmap.colorScale.ranges[n]);
      } else "mouseout" === t.type && r("remove");
    }
  }, {
    key: "getActiveConfigSeriesIndex",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
          e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc",
          i = this.w,
          a = 0;
      if (i.config.series.length > 1) for (var s = i.config.series.map(function (e, a) {
        var s = !1;
        return t && (s = "bar" === i.config.series[a].type || "column" === i.config.series[a].type), e.data && e.data.length > 0 && !s ? a : -1;
      }), r = "asc" === e ? 0 : s.length - 1; "asc" === e ? r < s.length : r >= 0; "asc" === e ? r++ : r--) {
        if (-1 !== s[r]) {
          a = s[r];
          break;
        }
      }
      return a;
    }
  }, {
    key: "getPreviousPaths",
    value: function value() {
      var t = this.w;

      function e(e, i, a) {
        for (var s = e[i].childNodes, r = {
          type: a,
          paths: [],
          realIndex: e[i].getAttribute("data:realIndex")
        }, n = 0; n < s.length; n++) {
          if (s[n].hasAttribute("pathTo")) {
            var o = s[n].getAttribute("pathTo");
            r.paths.push({
              d: o
            });
          }
        }

        t.globals.previousPaths.push(r);
      }

      t.globals.previousPaths = [];
      ["line", "area", "bar", "rangebar", "candlestick", "radar"].forEach(function (i) {
        for (var a, s = (a = i, t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a, "-series .apexcharts-series"))), r = 0; r < s.length; r++) {
          e(s, r, i);
        }
      }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
      var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series"));
      if (i.length > 0) for (var a = function a(e) {
        for (var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e, "'] rect")), a = [], s = function s(t) {
          var e = function e(_e) {
            return i[t].getAttribute(_e);
          },
              s = {
            x: parseFloat(e("x")),
            y: parseFloat(e("y")),
            width: parseFloat(e("width")),
            height: parseFloat(e("height"))
          };

          a.push({
            rect: s,
            color: i[t].getAttribute("color")
          });
        }, r = 0; r < i.length; r++) {
          s(r);
        }

        t.globals.previousPaths.push(a);
      }, s = 0; s < i.length; s++) {
        a(s);
      }
      t.globals.axisCharts || (t.globals.previousPaths = t.globals.series);
    }
  }, {
    key: "handlePrevBubbleScatterPaths",
    value: function value(t) {
      var e = this.w,
          i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
      if (i.length > 0) for (var a = 0; a < i.length; a++) {
        for (var s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(a, "'] circle")), r = [], n = 0; n < s.length; n++) {
          r.push({
            x: s[n].getAttribute("cx"),
            y: s[n].getAttribute("cy"),
            r: s[n].getAttribute("r")
          });
        }

        e.globals.previousPaths.push(r);
      }
    }
  }, {
    key: "clearPreviousPaths",
    value: function value() {
      var t = this.w;
      t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1;
    }
  }, {
    key: "handleNoData",
    value: function value() {
      var t = this.w,
          e = t.config.noData,
          i = new b(this.ctx),
          a = t.globals.svgWidth / 2,
          s = t.globals.svgHeight / 2,
          r = "middle";

      if (t.globals.noData = !0, t.globals.animationEnded = !0, "left" === e.align ? (a = 10, r = "start") : "right" === e.align && (a = t.globals.svgWidth - 10, r = "end"), "top" === e.verticalAlign ? s = 50 : "bottom" === e.verticalAlign && (s = t.globals.svgHeight - 50), a += e.offsetX, s = s + parseInt(e.style.fontSize, 10) + 2 + e.offsetY, void 0 !== e.text && "" !== e.text) {
        var n = i.drawText({
          x: a,
          y: s,
          text: e.text,
          textAnchor: r,
          fontSize: e.style.fontSize,
          fontFamily: e.style.fontFamily,
          foreColor: e.style.color,
          opacity: 1,
          "class": "apexcharts-text-nodata"
        });
        t.globals.dom.Paper.add(n);
      }
    }
  }, {
    key: "setNullSeriesToZeroValues",
    value: function value(t) {
      for (var e = this.w, i = 0; i < t.length; i++) {
        if (0 === t[i].length) for (var a = 0; a < t[e.globals.maxValsInArrayIndex].length; a++) {
          t[i].push(0);
        }
      }

      return t;
    }
  }, {
    key: "hasAllSeriesEqualX",
    value: function value() {
      for (var t = !0, e = this.w, i = this.filteredSeriesX(), a = 0; a < i.length - 1; a++) {
        if (i[a][0] !== i[a + 1][0]) {
          t = !1;
          break;
        }
      }

      return e.globals.allSeriesHasEqualX = t, t;
    }
  }, {
    key: "filteredSeriesX",
    value: function value() {
      var t = this.w.globals.seriesX.map(function (t) {
        return t.length > 0 ? t : [];
      });
      return t;
    }
  }]), t;
}(),
    E = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.barCtx = i;
  }

  return a(t, [{
    key: "initVariables",
    value: function value(t) {
      var e = this.w;
      this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;

      for (var i = 0; i < t.length; i++) {
        if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), e.globals.isXNumeric) for (var a = 0; a < t[i].length; a++) {
          e.globals.seriesX[i][a] > e.globals.minX && e.globals.seriesX[i][a] < e.globals.maxX && this.barCtx.visibleItems++;
        } else this.barCtx.visibleItems = e.globals.dataPoints;
      }

      0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], this.barCtx.radiusOnSeriesNumber = t.length - 1, e.globals.comboCharts || this.checkZeroSeries({
        series: t
      });
    }
  }, {
    key: "initialPositions",
    value: function value() {
      var t,
          e,
          i,
          a,
          s,
          r,
          n,
          o,
          l = this.w,
          h = l.globals.dataPoints;
      this.barCtx.isTimelineBar && (h = l.globals.labels.length);
      var c = this.barCtx.seriesLen;
      if (l.config.plotOptions.bar.rangeBarGroupRows && (c = 1), this.barCtx.isHorizontal) s = (i = l.globals.gridHeight / h) / c, l.globals.isXNumeric && (s = (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s = s * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, o = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e = (i - s * this.barCtx.seriesLen) / 2;else {
        if (a = l.globals.gridWidth / this.barCtx.visibleItems, l.config.xaxis.convertedCatToNumeric && (a = l.globals.gridWidth / l.globals.dataPoints), r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l.globals.isXNumeric) {
          var d = this.barCtx.xRatio;
          l.config.xaxis.convertedCatToNumeric && (d = this.barCtx.initialXRatio), l.globals.minXDiff && .5 !== l.globals.minXDiff && l.globals.minXDiff / d > 0 && (a = l.globals.minXDiff / d), (r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1);
        }

        n = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = l.globals.padHorizontal + (a - r * this.barCtx.seriesLen) / 2;
      }
      return {
        x: t,
        y: e,
        yDivision: i,
        xDivision: a,
        barHeight: s,
        barWidth: r,
        zeroH: n,
        zeroW: o
      };
    }
  }, {
    key: "getPathFillColor",
    value: function value(t, e, i, a) {
      var s = this.w,
          r = new L(this.barCtx.ctx),
          n = null,
          o = this.barCtx.barOptions.distributed ? i : e;
      this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function (a) {
        t[e][i] >= a.from && t[e][i] <= a.to && (n = a.color);
      });
      return s.config.series[e].data[i] && s.config.series[e].data[i].fillColor && (n = s.config.series[e].data[i].fillColor), r.fillPath({
        seriesNumber: this.barCtx.barOptions.distributed ? o : a,
        dataPointIndex: i,
        color: n,
        value: t[e][i]
      });
    }
  }, {
    key: "getStrokeWidth",
    value: function value(t, e, i) {
      var a = 0,
          s = this.w;
      return void 0 === this.barCtx.series[t][e] || null === this.barCtx.series[t][e] ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, s.config.stroke.show && (this.barCtx.isNullValue || (a = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), a;
    }
  }, {
    key: "barBackground",
    value: function value(t) {
      var e = t.j,
          i = t.i,
          a = t.x1,
          s = t.x2,
          r = t.y1,
          n = t.y2,
          o = t.elSeries,
          l = this.w,
          h = new b(this.barCtx.ctx),
          c = new M(this.barCtx.ctx).getActiveConfigSeriesIndex();

      if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c === i) {
        e >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e -= this.barCtx.barOptions.colors.backgroundBarColors.length);
        var d = this.barCtx.barOptions.colors.backgroundBarColors[e],
            g = h.drawRect(void 0 !== a ? a : 0, void 0 !== r ? r : 0, void 0 !== s ? s : l.globals.gridWidth, void 0 !== n ? n : l.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d, this.barCtx.barOptions.colors.backgroundBarOpacity);
        o.add(g), g.node.classList.add("apexcharts-backgroundBar");
      }
    }
  }, {
    key: "getColumnPaths",
    value: function value(t) {
      var e = t.barWidth,
          i = t.barXPosition,
          a = t.yRatio,
          s = t.y1,
          r = t.y2,
          n = t.strokeWidth,
          o = t.series,
          l = t.realIndex,
          h = t.i,
          c = t.j,
          d = t.w,
          g = new b(this.barCtx.ctx);
      (n = Array.isArray(n) ? n[l] : n) || (n = 0);
      var u = {
        barWidth: e,
        strokeWidth: n,
        yRatio: a,
        barXPosition: i,
        y1: s,
        y2: r
      },
          f = this.getRoundedBars(d, u, o, h, c),
          p = i,
          x = i + e,
          m = g.move(p, s),
          v = g.move(p, s),
          y = g.line(x - n, s);
      return d.globals.previousPaths.length > 0 && (v = this.barCtx.getPreviousPath(l, c, !1)), m = m + g.line(p, f.y2) + f.pathWithRadius + g.line(x - n, f.y2) + y + y + "z", v = v + g.line(p, s) + y + y + y + y + y + g.line(p, s), d.config.chart.stacked && (this.barCtx.yArrj.push(f.y2), this.barCtx.yArrjF.push(Math.abs(s - f.y2)), this.barCtx.yArrjVal.push(this.barCtx.series[h][c])), {
        pathTo: m,
        pathFrom: v
      };
    }
  }, {
    key: "getBarpaths",
    value: function value(t) {
      var e = t.barYPosition,
          i = t.barHeight,
          a = t.x1,
          s = t.x2,
          r = t.strokeWidth,
          n = t.series,
          o = t.realIndex,
          l = t.i,
          h = t.j,
          c = t.w,
          d = new b(this.barCtx.ctx);
      (r = Array.isArray(r) ? r[o] : r) || (r = 0);
      var g = {
        barHeight: i,
        strokeWidth: r,
        barYPosition: e,
        x2: s,
        x1: a
      },
          u = this.getRoundedBars(c, g, n, l, h),
          f = d.move(a, e),
          p = d.move(a, e);
      c.globals.previousPaths.length > 0 && (p = this.barCtx.getPreviousPath(o, h, !1));
      var x = e,
          m = e + i,
          v = d.line(a, m - r);
      return f = f + d.line(u.x2, x) + u.pathWithRadius + d.line(u.x2, m - r) + v + v + "z", p = p + d.line(a, x) + v + v + v + v + v + d.line(a, x), c.config.chart.stacked && (this.barCtx.xArrj.push(u.x2), this.barCtx.xArrjF.push(Math.abs(a - u.x2)), this.barCtx.xArrjVal.push(this.barCtx.series[l][h])), {
        pathTo: f,
        pathFrom: p
      };
    }
  }, {
    key: "getRoundedBars",
    value: function value(t, e, i, a, s) {
      var r = new b(this.barCtx.ctx),
          n = t.config.plotOptions.bar.borderRadius;

      if (t.config.chart.stacked && i.length > 1 && a !== this.barCtx.radiusOnSeriesNumber && (n = 0), this.barCtx.isHorizontal) {
        var o = "",
            l = e.x2;

        if (Math.abs(e.x1 - e.x2) < n && (n = Math.abs(e.x1 - e.x2)), void 0 !== i[a][s] || null !== i[a][s]) {
          var h = this.barCtx.isReversed ? i[a][s] > 0 : i[a][s] < 0;
          h && (n *= -1), l -= n, o = r.quadraticCurve(l + n, e.barYPosition, l + n, e.barYPosition + (h ? -1 * n : n)) + r.line(l + n, e.barYPosition + e.barHeight - e.strokeWidth - (h ? -1 * n : n)) + r.quadraticCurve(l + n, e.barYPosition + e.barHeight - e.strokeWidth, l, e.barYPosition + e.barHeight - e.strokeWidth);
        }

        return {
          pathWithRadius: o,
          x2: l
        };
      }

      var c = "",
          d = e.y2;

      if (Math.abs(e.y1 - e.y2) < n && (n = Math.abs(e.y1 - e.y2)), void 0 !== i[a][s] || null !== i[a][s]) {
        var g = i[a][s] < 0;
        g && (n *= -1), d += n, c = r.quadraticCurve(e.barXPosition, d - n, e.barXPosition + (g ? -1 * n : n), d - n) + r.line(e.barXPosition + e.barWidth - e.strokeWidth - (g ? -1 * n : n), d - n) + r.quadraticCurve(e.barXPosition + e.barWidth - e.strokeWidth, d - n, e.barXPosition + e.barWidth - e.strokeWidth, d);
      }

      return {
        pathWithRadius: c,
        y2: d
      };
    }
  }, {
    key: "checkZeroSeries",
    value: function value(t) {
      for (var e = t.series, i = this.w, a = 0; a < e.length; a++) {
        for (var s = 0, r = 0; r < e[i.globals.maxValsInArrayIndex].length; r++) {
          s += e[a][r];
        }

        0 === s && this.barCtx.zeroSerieses.push(a);
      }

      for (var n = e.length - 1; n >= 0; n--) {
        this.barCtx.zeroSerieses.indexOf(n) > -1 && n === this.radiusOnSeriesNumber && (this.barCtx.radiusOnSeriesNumber -= 1);
      }

      for (var o = e.length - 1; o >= 0; o--) {
        i.globals.collapsedSeriesIndices.indexOf(this.barCtx.radiusOnSeriesNumber) > -1 && (this.barCtx.radiusOnSeriesNumber -= 1);
      }
    }
  }]), t;
}(),
    X = function () {
  function t(i, a) {
    e(this, t), this.ctx = i, this.w = i.w;
    var s = this.w;
    this.barOptions = s.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s.config.stroke.width, this.isNullValue = !1, this.isTimelineBar = "datetime" === s.config.xaxis.type && s.globals.seriesRangeBarTimeline.length, this.xyRatios = a, null !== this.xyRatios && (this.xRatio = a.xRatio, this.initialXRatio = a.initialXRatio, this.yRatio = a.yRatio, this.invertedXRatio = a.invertedXRatio, this.invertedYRatio = a.invertedYRatio, this.baseLineY = a.baseLineY, this.baseLineInvertedY = a.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new E(this);
  }

  return a(t, [{
    key: "draw",
    value: function value(t, e) {
      var i = this.w,
          a = new b(this.ctx),
          s = new y(this.ctx, i);
      t = s.getLogSeries(t), this.series = t, this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
      var r = a.group({
        "class": "apexcharts-bar-series apexcharts-plot-series"
      });
      i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");

      for (var o = 0, l = 0; o < t.length; o++, l++) {
        var h,
            c,
            d,
            g,
            u = void 0,
            p = void 0,
            x = [],
            m = [],
            v = i.globals.comboCharts ? e[o] : o,
            w = a.group({
          "class": "apexcharts-series",
          rel: o + 1,
          seriesName: f.escapeString(i.globals.seriesNames[v]),
          "data:realIndex": v
        });
        this.ctx.series.addCollapsedClassToSeries(w, v), t[o].length > 0 && (this.visibleI = this.visibleI + 1);
        var k = 0,
            A = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = v), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
        var S = this.barHelpers.initialPositions();
        p = S.y, k = S.barHeight, c = S.yDivision, g = S.zeroW, u = S.x, A = S.barWidth, h = S.xDivision, d = S.zeroH, this.horizontal || m.push(u + A / 2);

        for (var C = a.group({
          "class": "apexcharts-datalabels",
          "data:realIndex": v
        }), L = 0; L < i.globals.dataPoints; L++) {
          var P = this.barHelpers.getStrokeWidth(o, L, v),
              T = null,
              z = {
            indexes: {
              i: o,
              j: L,
              realIndex: v,
              bc: l
            },
            x: u,
            y: p,
            strokeWidth: P,
            elSeries: w
          };
          this.isHorizontal ? (T = this.drawBarPaths(n(n({}, z), {}, {
            barHeight: k,
            zeroW: g,
            yDivision: c
          })), A = this.series[o][L] / this.invertedYRatio) : (T = this.drawColumnPaths(n(n({}, z), {}, {
            xDivision: h,
            barWidth: A,
            zeroH: d
          })), k = this.series[o][L] / this.yRatio[this.yaxisIndex]), p = T.y, u = T.x, L > 0 && m.push(u + A / 2), x.push(p);
          var I = this.barHelpers.getPathFillColor(t, o, L, v);
          this.renderSeries({
            realIndex: v,
            pathFill: I,
            j: L,
            i: o,
            pathFrom: T.pathFrom,
            pathTo: T.pathTo,
            strokeWidth: P,
            elSeries: w,
            x: u,
            y: p,
            series: t,
            barHeight: k,
            barWidth: A,
            elDataLabelsWrap: C,
            visibleSeries: this.visibleI,
            type: "bar"
          });
        }

        i.globals.seriesXvalues[v] = m, i.globals.seriesYvalues[v] = x, r.add(w);
      }

      return r;
    }
  }, {
    key: "renderSeries",
    value: function value(t) {
      var e = t.realIndex,
          i = t.pathFill,
          a = t.lineFill,
          s = t.j,
          r = t.i,
          n = t.pathFrom,
          o = t.pathTo,
          l = t.strokeWidth,
          h = t.elSeries,
          c = t.x,
          d = t.y,
          g = t.y1,
          u = t.y2,
          f = t.series,
          p = t.barHeight,
          m = t.barWidth,
          v = t.barYPosition,
          y = t.elDataLabelsWrap,
          w = t.visibleSeries,
          k = t.type,
          A = this.w,
          S = new b(this.ctx);
      a || (a = this.barOptions.distributed ? A.globals.stroke.colors[s] : A.globals.stroke.colors[e]), A.config.series[r].data[s] && A.config.series[r].data[s].strokeColor && (a = A.config.series[r].data[s].strokeColor), this.isNullValue && (i = "none");
      var C = s / A.config.chart.animations.animateGradually.delay * (A.config.chart.animations.speed / A.globals.dataPoints) / 2.4,
          L = S.renderPaths({
        i: r,
        j: s,
        realIndex: e,
        pathFrom: n,
        pathTo: o,
        stroke: a,
        strokeWidth: l,
        strokeLineCap: A.config.stroke.lineCap,
        fill: i,
        animationDelay: C,
        initialSpeed: A.config.chart.animations.speed,
        dataChangeSpeed: A.config.chart.animations.dynamicAnimation.speed,
        className: "apexcharts-".concat(k, "-area")
      });
      L.attr("clip-path", "url(#gridRectMask".concat(A.globals.cuid, ")")), void 0 !== g && void 0 !== u && (L.attr("data-range-y1", g), L.attr("data-range-y2", u)), new x(this.ctx).setSelectionFilter(L, e, s), h.add(L);
      var P = new I(this).handleBarDataLabels({
        x: c,
        y: d,
        y1: g,
        y2: u,
        i: r,
        j: s,
        series: f,
        realIndex: e,
        barHeight: p,
        barWidth: m,
        barYPosition: v,
        renderedPath: L,
        visibleSeries: w
      });
      return null !== P && y.add(P), h.add(y), h;
    }
  }, {
    key: "drawBarPaths",
    value: function value(t) {
      var e = t.indexes,
          i = t.barHeight,
          a = t.strokeWidth,
          s = t.zeroW,
          r = t.x,
          n = t.y,
          o = t.yDivision,
          l = t.elSeries,
          h = this.w,
          c = e.i,
          d = e.j;
      h.globals.isXNumeric && (n = (h.globals.seriesX[c][d] - h.globals.minX) / this.invertedXRatio - i);
      var g = n + i * this.visibleI;
      r = void 0 === this.series[c][d] || null === this.series[c][d] ? s : s + this.series[c][d] / this.invertedYRatio - 2 * (this.isReversed ? this.series[c][d] / this.invertedYRatio : 0);
      var u = this.barHelpers.getBarpaths({
        barYPosition: g,
        barHeight: i,
        x1: s,
        x2: r,
        strokeWidth: a,
        series: this.series,
        realIndex: e.realIndex,
        i: c,
        j: d,
        w: h
      });
      return h.globals.isXNumeric || (n += o), this.barHelpers.barBackground({
        j: d,
        i: c,
        y1: g - i * this.visibleI,
        y2: i * this.seriesLen,
        elSeries: l
      }), {
        pathTo: u.pathTo,
        pathFrom: u.pathFrom,
        x: r,
        y: n,
        barYPosition: g
      };
    }
  }, {
    key: "drawColumnPaths",
    value: function value(t) {
      var e = t.indexes,
          i = t.x,
          a = t.y,
          s = t.xDivision,
          r = t.barWidth,
          n = t.zeroH,
          o = t.strokeWidth,
          l = t.elSeries,
          h = this.w,
          c = e.realIndex,
          d = e.i,
          g = e.j,
          u = e.bc;

      if (h.globals.isXNumeric) {
        var f = c;
        h.globals.seriesX[c].length || (f = h.globals.maxValsInArrayIndex), i = (h.globals.seriesX[f][g] - h.globals.minX) / this.xRatio - r * this.seriesLen / 2;
      }

      var p = i + r * this.visibleI;
      a = void 0 === this.series[d][g] || null === this.series[d][g] ? n : n - this.series[d][g] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[d][g] / this.yRatio[this.yaxisIndex] : 0);
      var x = this.barHelpers.getColumnPaths({
        barXPosition: p,
        barWidth: r,
        y1: n,
        y2: a,
        strokeWidth: o,
        series: this.series,
        realIndex: e.realIndex,
        i: d,
        j: g,
        w: h
      });
      return h.globals.isXNumeric || (i += s), this.barHelpers.barBackground({
        bc: u,
        j: g,
        i: d,
        x1: p - o / 2 - r * this.visibleI,
        x2: r * this.seriesLen + o / 2,
        elSeries: l
      }), {
        pathTo: x.pathTo,
        pathFrom: x.pathFrom,
        x: i,
        y: a,
        barXPosition: p
      };
    }
  }, {
    key: "getPreviousPath",
    value: function value(t, e) {
      for (var i, a = this.w, s = 0; s < a.globals.previousPaths.length; s++) {
        var r = a.globals.previousPaths[s];
        r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(t, 10) && void 0 !== a.globals.previousPaths[s].paths[e] && (i = a.globals.previousPaths[s].paths[e].d);
      }

      return i;
    }
  }]), t;
}(),
    Y = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }

  return a(t, [{
    key: "isValidDate",
    value: function value(t) {
      return !isNaN(this.parseDate(t));
    }
  }, {
    key: "getTimeStamp",
    value: function value(t) {
      return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t;
    }
  }, {
    key: "getDate",
    value: function value(t) {
      return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t);
    }
  }, {
    key: "parseDate",
    value: function value(t) {
      var e = Date.parse(t);
      if (!isNaN(e)) return this.getTimeStamp(t);
      var i = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      return i = this.getTimeStamp(i);
    }
  }, {
    key: "parseDateWithTimezone",
    value: function value(t) {
      return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    }
  }, {
    key: "formatDate",
    value: function value(t, e) {
      var i = this.w.globals.locale,
          a = this.w.config.xaxis.labels.datetimeUTC,
          s = ["\0"].concat(g(i.months)),
          r = ["\x01"].concat(g(i.shortMonths)),
          n = ["\x02"].concat(g(i.days)),
          o = ["\x03"].concat(g(i.shortDays));

      function l(t, e) {
        var i = t + "";

        for (e = e || 2; i.length < e;) {
          i = "0" + i;
        }

        return i;
      }

      var h = a ? t.getUTCFullYear() : t.getFullYear();
      e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, "$1" + h)).replace(/(^|[^\\])yy/g, "$1" + h.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h);
      var c = (a ? t.getUTCMonth() : t.getMonth()) + 1;
      e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, "$1" + s[0])).replace(/(^|[^\\])MMM/g, "$1" + r[0])).replace(/(^|[^\\])MM/g, "$1" + l(c))).replace(/(^|[^\\])M/g, "$1" + c);
      var d = a ? t.getUTCDate() : t.getDate();
      e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, "$1" + n[0])).replace(/(^|[^\\])ddd/g, "$1" + o[0])).replace(/(^|[^\\])dd/g, "$1" + l(d))).replace(/(^|[^\\])d/g, "$1" + d);
      var u = a ? t.getUTCHours() : t.getHours(),
          f = u > 12 ? u - 12 : 0 === u ? 12 : u;
      e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, "$1" + l(u))).replace(/(^|[^\\])H/g, "$1" + u)).replace(/(^|[^\\])hh+/g, "$1" + l(f))).replace(/(^|[^\\])h/g, "$1" + f);
      var p = a ? t.getUTCMinutes() : t.getMinutes();
      e = (e = e.replace(/(^|[^\\])mm+/g, "$1" + l(p))).replace(/(^|[^\\])m/g, "$1" + p);
      var x = a ? t.getUTCSeconds() : t.getSeconds();
      e = (e = e.replace(/(^|[^\\])ss+/g, "$1" + l(x))).replace(/(^|[^\\])s/g, "$1" + x);
      var b = a ? t.getUTCMilliseconds() : t.getMilliseconds();
      e = e.replace(/(^|[^\\])fff+/g, "$1" + l(b, 3)), b = Math.round(b / 10), e = e.replace(/(^|[^\\])ff/g, "$1" + l(b)), b = Math.round(b / 10);
      var m = u < 12 ? "AM" : "PM";
      e = (e = (e = e.replace(/(^|[^\\])f/g, "$1" + b)).replace(/(^|[^\\])TT+/g, "$1" + m)).replace(/(^|[^\\])T/g, "$1" + m.charAt(0));
      var v = m.toLowerCase();
      e = (e = e.replace(/(^|[^\\])tt+/g, "$1" + v)).replace(/(^|[^\\])t/g, "$1" + v.charAt(0));
      var y = -t.getTimezoneOffset(),
          w = a || !y ? "Z" : y > 0 ? "+" : "-";

      if (!a) {
        var k = (y = Math.abs(y)) % 60;
        w += l(Math.floor(y / 60)) + ":" + l(k);
      }

      e = e.replace(/(^|[^\\])K/g, "$1" + w);
      var A = (a ? t.getUTCDay() : t.getDay()) + 1;
      return e = (e = (e = (e = (e = e.replace(new RegExp(n[0], "g"), n[A])).replace(new RegExp(o[0], "g"), o[A])).replace(new RegExp(s[0], "g"), s[c])).replace(new RegExp(r[0], "g"), r[c])).replace(/\\(.)/g, "$1");
    }
  }, {
    key: "getTimeUnitsfromTimestamp",
    value: function value(t, e, i) {
      var a = this.w;
      void 0 !== a.config.xaxis.min && (t = a.config.xaxis.min), void 0 !== a.config.xaxis.max && (e = a.config.xaxis.max);
      var s = this.getDate(t),
          r = this.getDate(e),
          n = this.formatDate(s, "yyyy MM dd HH mm ss").split(" "),
          o = this.formatDate(r, "yyyy MM dd HH mm ss").split(" ");
      return {
        minSecond: parseInt(n[5], 10),
        maxSecond: parseInt(o[5], 10),
        minMinute: parseInt(n[4], 10),
        maxMinute: parseInt(o[4], 10),
        minHour: parseInt(n[3], 10),
        maxHour: parseInt(o[3], 10),
        minDate: parseInt(n[2], 10),
        maxDate: parseInt(o[2], 10),
        minMonth: parseInt(n[1], 10) - 1,
        maxMonth: parseInt(o[1], 10) - 1,
        minYear: parseInt(n[0], 10),
        maxYear: parseInt(o[0], 10)
      };
    }
  }, {
    key: "isLeapYear",
    value: function value(t) {
      return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
    }
  }, {
    key: "calculcateLastDaysOfMonth",
    value: function value(t, e, i) {
      return this.determineDaysOfMonths(t, e) - i;
    }
  }, {
    key: "determineDaysOfYear",
    value: function value(t) {
      var e = 365;
      return this.isLeapYear(t) && (e = 366), e;
    }
  }, {
    key: "determineRemainingDaysOfYear",
    value: function value(t, e, i) {
      var a = this.daysCntOfYear[e] + i;
      return e > 1 && this.isLeapYear() && a++, a;
    }
  }, {
    key: "determineDaysOfMonths",
    value: function value(t, e) {
      var i = 30;

      switch (t = f.monthMod(t), !0) {
        case this.months30.indexOf(t) > -1:
          2 === t && (i = this.isLeapYear(e) ? 29 : 28);
          break;

        case this.months31.indexOf(t) > -1:
        default:
          i = 31;
      }

      return i;
    }
  }]), t;
}(),
    F = function (t) {
  o(s, X);
  var i = d(s);

  function s() {
    return e(this, s), i.apply(this, arguments);
  }

  return a(s, [{
    key: "draw",
    value: function value(t, e) {
      var i = this.w,
          a = new b(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(t);

      for (var s = a.group({
        "class": "apexcharts-rangebar-series apexcharts-plot-series"
      }), r = 0; r < t.length; r++) {
        var o,
            l,
            h,
            c = void 0,
            d = void 0,
            g = void 0,
            u = i.globals.comboCharts ? e[r] : r,
            p = a.group({
          "class": "apexcharts-series",
          seriesName: f.escapeString(i.globals.seriesNames[u]),
          rel: r + 1,
          "data:realIndex": u
        });
        t[r].length > 0 && (this.visibleI = this.visibleI + 1);
        var x = 0,
            m = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = u);
        var v = this.barHelpers.initialPositions();
        d = v.y, h = v.zeroW, c = v.x, m = v.barWidth, o = v.xDivision, l = v.zeroH;

        for (var y = a.group({
          "class": "apexcharts-datalabels",
          "data:realIndex": u
        }), w = 0; w < i.globals.dataPoints; w++) {
          var k = this.barHelpers.getStrokeWidth(r, w, u),
              A = this.seriesRangeStart[r][w],
              S = this.seriesRangeEnd[r][w],
              C = null,
              L = null,
              P = {
            x: c,
            y: d,
            strokeWidth: k,
            elSeries: p
          };

          if (g = v.yDivision, x = v.barHeight, this.isHorizontal) {
            L = d + x * this.visibleI;
            var T = this.seriesLen;
            i.config.plotOptions.bar.rangeBarGroupRows && (T = 1);
            var z = (g - x * T) / 2;
            if (void 0 === i.config.series[r].data[w]) break;

            if (this.isTimelineBar && i.config.series[r].data[w].x) {
              var I = this.detectOverlappingBars({
                i: r,
                j: w,
                barYPosition: L,
                srty: z,
                barHeight: x,
                yDivision: g,
                initPositions: v
              });
              x = I.barHeight, L = I.barYPosition;
            }

            m = (C = this.drawRangeBarPaths(n({
              indexes: {
                i: r,
                j: w,
                realIndex: u
              },
              barHeight: x,
              barYPosition: L,
              zeroW: h,
              yDivision: g,
              y1: A,
              y2: S
            }, P))).barWidth;
          } else x = (C = this.drawRangeColumnPaths(n({
            indexes: {
              i: r,
              j: w,
              realIndex: u
            },
            zeroH: l,
            barWidth: m,
            xDivision: o
          }, P))).barHeight;

          d = C.y, c = C.x;
          var M = this.barHelpers.getPathFillColor(t, r, w, u),
              E = i.globals.stroke.colors[u];
          this.renderSeries({
            realIndex: u,
            pathFill: M,
            lineFill: E,
            j: w,
            i: r,
            x: c,
            y: d,
            y1: A,
            y2: S,
            pathFrom: C.pathFrom,
            pathTo: C.pathTo,
            strokeWidth: k,
            elSeries: p,
            series: t,
            barHeight: x,
            barYPosition: L,
            barWidth: m,
            elDataLabelsWrap: y,
            visibleSeries: this.visibleI,
            type: "rangebar"
          });
        }

        s.add(p);
      }

      return s;
    }
  }, {
    key: "detectOverlappingBars",
    value: function value(t) {
      var e = t.i,
          i = t.j,
          a = t.barYPosition,
          s = t.srty,
          r = t.barHeight,
          n = t.yDivision,
          o = t.initPositions,
          l = this.w,
          h = [],
          c = l.config.series[e].data[i].rangeName,
          d = l.config.series[e].data[i].x,
          g = l.globals.labels.indexOf(d),
          u = l.globals.seriesRangeBarTimeline[e].findIndex(function (t) {
        return t.x === d && t.overlaps.length > 0;
      });
      return a = l.config.plotOptions.bar.rangeBarGroupRows ? s + n * g : s + r * this.visibleI + n * g, u > -1 && !l.config.plotOptions.bar.rangeBarOverlap && (h = l.globals.seriesRangeBarTimeline[e][u].overlaps).indexOf(c) > -1 && (a = (r = o.barHeight / h.length) * this.visibleI + n * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + r * (this.visibleI + h.indexOf(c)) + n * g), {
        barYPosition: a,
        barHeight: r
      };
    }
  }, {
    key: "drawRangeColumnPaths",
    value: function value(t) {
      var e = t.indexes,
          i = t.x,
          a = (t.strokeWidth, t.xDivision),
          s = t.barWidth,
          r = t.zeroH,
          n = this.w,
          o = e.i,
          l = e.j,
          h = this.yRatio[this.yaxisIndex],
          c = e.realIndex,
          d = this.getRangeValue(c, l),
          g = Math.min(d.start, d.end),
          u = Math.max(d.start, d.end);
      n.globals.isXNumeric && (i = (n.globals.seriesX[o][l] - n.globals.minX) / this.xRatio - s / 2);
      var f = i + s * this.visibleI;
      void 0 === this.series[o][l] || null === this.series[o][l] ? g = r : (g = r - g / h, u = r - u / h);
      var p = Math.abs(u - g),
          x = this.barHelpers.getColumnPaths({
        barXPosition: f,
        barWidth: s,
        y1: g,
        y2: u,
        strokeWidth: this.strokeWidth,
        series: this.seriesRangeEnd,
        realIndex: e.realIndex,
        i: c,
        j: l,
        w: n
      });
      return n.globals.isXNumeric || (i += a), {
        pathTo: x.pathTo,
        pathFrom: x.pathFrom,
        barHeight: p,
        x: i,
        y: u,
        barXPosition: f
      };
    }
  }, {
    key: "drawRangeBarPaths",
    value: function value(t) {
      var e = t.indexes,
          i = t.y,
          a = t.y1,
          s = t.y2,
          r = t.yDivision,
          n = t.barHeight,
          o = t.barYPosition,
          l = t.zeroW,
          h = this.w,
          c = l + a / this.invertedYRatio,
          d = l + s / this.invertedYRatio,
          g = Math.abs(d - c),
          u = this.barHelpers.getBarpaths({
        barYPosition: o,
        barHeight: n,
        x1: c,
        x2: d,
        strokeWidth: this.strokeWidth,
        series: this.seriesRangeEnd,
        i: e.realIndex,
        realIndex: e.realIndex,
        j: e.j,
        w: h
      });
      return h.globals.isXNumeric || (i += r), {
        pathTo: u.pathTo,
        pathFrom: u.pathFrom,
        barWidth: g,
        x: d,
        y: i
      };
    }
  }, {
    key: "getRangeValue",
    value: function value(t, e) {
      var i = this.w;
      return {
        start: i.globals.seriesRangeStart[t][e],
        end: i.globals.seriesRangeEnd[t][e]
      };
    }
  }, {
    key: "getTooltipValues",
    value: function value(t) {
      var e = t.ctx,
          i = t.seriesIndex,
          a = t.dataPointIndex,
          s = t.y1,
          r = t.y2,
          n = t.w,
          o = n.globals.seriesRangeStart[i][a],
          l = n.globals.seriesRangeEnd[i][a],
          h = n.globals.labels[a],
          c = n.config.series[i].name ? n.config.series[i].name : "",
          d = n.config.tooltip.y.formatter,
          g = n.config.tooltip.y.title.formatter,
          u = {
        w: n,
        seriesIndex: i,
        dataPointIndex: a
      };
      "function" == typeof g && (c = g(c, u)), Number.isFinite(s) && Number.isFinite(r) && (o = s, l = r, n.config.series[i].data[a].x && (h = n.config.series[i].data[a].x + ":"), "function" == typeof d && (h = d(h, u)));
      var f = "",
          p = "",
          x = n.globals.colors[i];
      if (void 0 === n.config.tooltip.x.formatter) {
        if ("datetime" === n.config.xaxis.type) {
          var b = new Y(e);
          f = b.formatDate(b.getDate(o), n.config.tooltip.x.format), p = b.formatDate(b.getDate(l), n.config.tooltip.x.format);
        } else f = o, p = l;
      } else f = n.config.tooltip.x.formatter(o), p = n.config.tooltip.x.formatter(l);
      return {
        start: o,
        end: l,
        startVal: f,
        endVal: p,
        ylabel: h,
        color: x,
        seriesName: c
      };
    }
  }, {
    key: "buildCustomTooltipHTML",
    value: function value(t) {
      var e = t.color,
          i = t.seriesName;
      return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e + '">' + (i || "") + '</span></div><div> <span class="category">' + t.ylabel + ' </span> <span class="value start-value">' + t.start + '</span> <span class="separator">-</span> <span class="value end-value">' + t.end + "</span></div></div>";
    }
  }]), s;
}(),
    R = function () {
  function t(i) {
    e(this, t), this.opts = i;
  }

  return a(t, [{
    key: "line",
    value: function value() {
      return {
        chart: {
          animations: {
            easing: "swing"
          }
        },
        dataLabels: {
          enabled: !1
        },
        stroke: {
          width: 5,
          curve: "straight"
        },
        markers: {
          size: 0,
          hover: {
            sizeOffset: 6
          }
        },
        xaxis: {
          crosshairs: {
            width: 1
          }
        }
      };
    }
  }, {
    key: "sparkline",
    value: function value(t) {
      this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
      return f.extend(t, {
        grid: {
          show: !1,
          padding: {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }
        },
        legend: {
          show: !1
        },
        xaxis: {
          labels: {
            show: !1
          },
          tooltip: {
            enabled: !1
          },
          axisBorder: {
            show: !1
          },
          axisTicks: {
            show: !1
          }
        },
        chart: {
          toolbar: {
            show: !1
          },
          zoom: {
            enabled: !1
          }
        },
        dataLabels: {
          enabled: !1
        }
      });
    }
  }, {
    key: "bar",
    value: function value() {
      return {
        chart: {
          stacked: !1,
          animations: {
            easing: "swing"
          }
        },
        plotOptions: {
          bar: {
            dataLabels: {
              position: "center"
            }
          }
        },
        dataLabels: {
          style: {
            colors: ["#fff"]
          },
          background: {
            enabled: !1
          }
        },
        stroke: {
          width: 0,
          lineCap: "round"
        },
        fill: {
          opacity: .85
        },
        legend: {
          markers: {
            shape: "square",
            radius: 2,
            size: 8
          }
        },
        tooltip: {
          shared: !1,
          intersect: !0
        },
        xaxis: {
          tooltip: {
            enabled: !1
          },
          tickPlacement: "between",
          crosshairs: {
            width: "barWidth",
            position: "back",
            fill: {
              type: "gradient"
            },
            dropShadow: {
              enabled: !1
            },
            stroke: {
              width: 0
            }
          }
        }
      };
    }
  }, {
    key: "candlestick",
    value: function value() {
      var t = this;
      return {
        stroke: {
          width: 1,
          colors: ["#333"]
        },
        fill: {
          opacity: 1
        },
        dataLabels: {
          enabled: !1
        },
        tooltip: {
          shared: !0,
          custom: function custom(e) {
            var i = e.seriesIndex,
                a = e.dataPointIndex,
                s = e.w;
            return t._getBoxTooltip(s, i, a, ["Open", "High", "", "Low", "Close"], "candlestick");
          }
        },
        states: {
          active: {
            filter: {
              type: "none"
            }
          }
        },
        xaxis: {
          crosshairs: {
            width: 1
          }
        }
      };
    }
  }, {
    key: "boxPlot",
    value: function value() {
      var t = this;
      return {
        chart: {
          animations: {
            dynamicAnimation: {
              enabled: !1
            }
          }
        },
        stroke: {
          width: 1,
          colors: ["#24292e"]
        },
        dataLabels: {
          enabled: !1
        },
        tooltip: {
          shared: !0,
          custom: function custom(e) {
            var i = e.seriesIndex,
                a = e.dataPointIndex,
                s = e.w;
            return t._getBoxTooltip(s, i, a, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
          }
        },
        markers: {
          size: 5,
          strokeWidth: 1,
          strokeColors: "#111"
        },
        xaxis: {
          crosshairs: {
            width: 1
          }
        }
      };
    }
  }, {
    key: "rangeBar",
    value: function value() {
      return {
        stroke: {
          width: 0,
          lineCap: "square"
        },
        plotOptions: {
          bar: {
            borderRadius: 0,
            dataLabels: {
              position: "center"
            }
          }
        },
        dataLabels: {
          enabled: !1,
          formatter: function formatter(t, e) {
            e.ctx;
            var i = e.seriesIndex,
                a = e.dataPointIndex,
                s = e.w,
                r = s.globals.seriesRangeStart[i][a];
            return s.globals.seriesRangeEnd[i][a] - r;
          },
          background: {
            enabled: !1
          },
          style: {
            colors: ["#fff"]
          }
        },
        tooltip: {
          shared: !1,
          followCursor: !0,
          custom: function custom(t) {
            return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? function (t) {
              var e = new F(t.ctx, null),
                  i = e.getTooltipValues(t),
                  a = i.color,
                  s = i.seriesName,
                  r = i.ylabel,
                  n = i.startVal,
                  o = i.endVal;
              return e.buildCustomTooltipHTML({
                color: a,
                seriesName: s,
                ylabel: r,
                start: n,
                end: o
              });
            }(t) : function (t) {
              var e = new F(t.ctx, null),
                  i = e.getTooltipValues(t),
                  a = i.color,
                  s = i.seriesName,
                  r = i.ylabel,
                  n = i.start,
                  o = i.end;
              return e.buildCustomTooltipHTML({
                color: a,
                seriesName: s,
                ylabel: r,
                start: n,
                end: o
              });
            }(t);
          }
        },
        xaxis: {
          tickPlacement: "between",
          tooltip: {
            enabled: !1
          },
          crosshairs: {
            stroke: {
              width: 0
            }
          }
        }
      };
    }
  }, {
    key: "area",
    value: function value() {
      return {
        stroke: {
          width: 4
        },
        fill: {
          type: "gradient",
          gradient: {
            inverseColors: !1,
            shade: "light",
            type: "vertical",
            opacityFrom: .65,
            opacityTo: .5,
            stops: [0, 100, 100]
          }
        },
        markers: {
          size: 0,
          hover: {
            sizeOffset: 6
          }
        },
        tooltip: {
          followCursor: !1
        }
      };
    }
  }, {
    key: "brush",
    value: function value(t) {
      return f.extend(t, {
        chart: {
          toolbar: {
            autoSelected: "selection",
            show: !1
          },
          zoom: {
            enabled: !1
          }
        },
        dataLabels: {
          enabled: !1
        },
        stroke: {
          width: 1
        },
        tooltip: {
          enabled: !1
        },
        xaxis: {
          tooltip: {
            enabled: !1
          }
        }
      });
    }
  }, {
    key: "stacked100",
    value: function value(t) {
      t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
      var e = t.dataLabels.formatter;
      return t.yaxis.forEach(function (e, i) {
        t.yaxis[i].min = 0, t.yaxis[i].max = 100;
      }), "bar" === t.chart.type && (t.dataLabels.formatter = e || function (t) {
        return "number" == typeof t && t ? t.toFixed(0) + "%" : t;
      }), t;
    }
  }, {
    key: "convertCatToNumeric",
    value: function value(t) {
      return t.xaxis.convertedCatToNumeric = !0, t;
    }
  }, {
    key: "convertCatToNumericXaxis",
    value: function value(t, e, i) {
      t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function (t) {
        return f.isNumber(t) ? Math.floor(t) : t;
      };
      var a = t.xaxis.labels.formatter,
          s = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
      return i && i.length && (s = i.map(function (t) {
        return Array.isArray(t) ? t : String(t);
      })), s && s.length && (t.xaxis.labels.formatter = function (t) {
        return f.isNumber(t) ? a(s[Math.floor(t) - 1]) : a(t);
      }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t;
    }
  }, {
    key: "bubble",
    value: function value() {
      return {
        dataLabels: {
          style: {
            colors: ["#fff"]
          }
        },
        tooltip: {
          shared: !1,
          intersect: !0
        },
        xaxis: {
          crosshairs: {
            width: 0
          }
        },
        fill: {
          type: "solid",
          gradient: {
            shade: "light",
            inverse: !0,
            shadeIntensity: .55,
            opacityFrom: .4,
            opacityTo: .8
          }
        }
      };
    }
  }, {
    key: "scatter",
    value: function value() {
      return {
        dataLabels: {
          enabled: !1
        },
        tooltip: {
          shared: !1,
          intersect: !0
        },
        markers: {
          size: 6,
          strokeWidth: 1,
          hover: {
            sizeOffset: 2
          }
        }
      };
    }
  }, {
    key: "heatmap",
    value: function value() {
      return {
        chart: {
          stacked: !1
        },
        fill: {
          opacity: 1
        },
        dataLabels: {
          style: {
            colors: ["#fff"]
          }
        },
        stroke: {
          colors: ["#fff"]
        },
        tooltip: {
          followCursor: !0,
          marker: {
            show: !1
          },
          x: {
            show: !1
          }
        },
        legend: {
          position: "top",
          markers: {
            shape: "square",
            size: 10,
            offsetY: 2
          }
        },
        grid: {
          padding: {
            right: 20
          }
        }
      };
    }
  }, {
    key: "treemap",
    value: function value() {
      return {
        chart: {
          zoom: {
            enabled: !1
          }
        },
        dataLabels: {
          style: {
            fontSize: 14,
            fontWeight: 600,
            colors: ["#fff"]
          }
        },
        stroke: {
          show: !0,
          width: 2,
          colors: ["#fff"]
        },
        legend: {
          show: !1
        },
        fill: {
          gradient: {
            stops: [0, 100]
          }
        },
        tooltip: {
          followCursor: !0,
          x: {
            show: !1
          }
        },
        grid: {
          padding: {
            left: 0,
            right: 0
          }
        },
        xaxis: {
          crosshairs: {
            show: !1
          },
          tooltip: {
            enabled: !1
          }
        }
      };
    }
  }, {
    key: "pie",
    value: function value() {
      return {
        chart: {
          toolbar: {
            show: !1
          }
        },
        plotOptions: {
          pie: {
            donut: {
              labels: {
                show: !1
              }
            }
          }
        },
        dataLabels: {
          formatter: function formatter(t) {
            return t.toFixed(1) + "%";
          },
          style: {
            colors: ["#fff"]
          },
          background: {
            enabled: !1
          },
          dropShadow: {
            enabled: !0
          }
        },
        stroke: {
          colors: ["#fff"]
        },
        fill: {
          opacity: 1,
          gradient: {
            shade: "light",
            stops: [0, 100]
          }
        },
        tooltip: {
          theme: "dark",
          fillSeriesColor: !0
        },
        legend: {
          position: "right"
        }
      };
    }
  }, {
    key: "donut",
    value: function value() {
      return {
        chart: {
          toolbar: {
            show: !1
          }
        },
        dataLabels: {
          formatter: function formatter(t) {
            return t.toFixed(1) + "%";
          },
          style: {
            colors: ["#fff"]
          },
          background: {
            enabled: !1
          },
          dropShadow: {
            enabled: !0
          }
        },
        stroke: {
          colors: ["#fff"]
        },
        fill: {
          opacity: 1,
          gradient: {
            shade: "light",
            shadeIntensity: .35,
            stops: [80, 100],
            opacityFrom: 1,
            opacityTo: 1
          }
        },
        tooltip: {
          theme: "dark",
          fillSeriesColor: !0
        },
        legend: {
          position: "right"
        }
      };
    }
  }, {
    key: "polarArea",
    value: function value() {
      return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, {
        chart: {
          toolbar: {
            show: !1
          }
        },
        dataLabels: {
          formatter: function formatter(t) {
            return t.toFixed(1) + "%";
          },
          enabled: !1
        },
        stroke: {
          show: !0,
          width: 2
        },
        fill: {
          opacity: .7
        },
        tooltip: {
          theme: "dark",
          fillSeriesColor: !0
        },
        legend: {
          position: "right"
        }
      };
    }
  }, {
    key: "radar",
    value: function value() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
        dataLabels: {
          enabled: !1,
          style: {
            fontSize: "11px"
          }
        },
        stroke: {
          width: 2
        },
        markers: {
          size: 3,
          strokeWidth: 1,
          strokeOpacity: 1
        },
        fill: {
          opacity: .2
        },
        tooltip: {
          shared: !1,
          intersect: !0,
          followCursor: !0
        },
        grid: {
          show: !1
        },
        xaxis: {
          labels: {
            formatter: function formatter(t) {
              return t;
            },
            style: {
              colors: ["#a8a8a8"],
              fontSize: "11px"
            }
          },
          tooltip: {
            enabled: !1
          },
          crosshairs: {
            show: !1
          }
        }
      };
    }
  }, {
    key: "radialBar",
    value: function value() {
      return {
        chart: {
          animations: {
            dynamicAnimation: {
              enabled: !0,
              speed: 800
            }
          },
          toolbar: {
            show: !1
          }
        },
        fill: {
          gradient: {
            shade: "dark",
            shadeIntensity: .4,
            inverseColors: !1,
            type: "diagonal2",
            opacityFrom: 1,
            opacityTo: 1,
            stops: [70, 98, 100]
          }
        },
        legend: {
          show: !1,
          position: "right"
        },
        tooltip: {
          enabled: !1,
          fillSeriesColor: !0
        }
      };
    }
  }, {
    key: "_getBoxTooltip",
    value: function value(t, e, i, a, s) {
      var r = t.globals.seriesCandleO[e][i],
          n = t.globals.seriesCandleH[e][i],
          o = t.globals.seriesCandleM[e][i],
          l = t.globals.seriesCandleL[e][i],
          h = t.globals.seriesCandleC[e][i];
      return t.config.series[e].type && t.config.series[e].type !== s ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t.config.series[e].name ? t.config.series[e].name : "series-" + (e + 1), ": <strong>").concat(t.globals.series[e][i], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type, '">') + "<div>".concat(a[0], ': <span class="value">') + r + "</span></div>" + "<div>".concat(a[1], ': <span class="value">') + n + "</span></div>" + (o ? "<div>".concat(a[2], ': <span class="value">') + o + "</span></div>" : "") + "<div>".concat(a[3], ': <span class="value">') + l + "</span></div>" + "<div>".concat(a[4], ': <span class="value">') + h + "</span></div></div>";
    }
  }]), t;
}(),
    D = function () {
  function i(t) {
    e(this, i), this.opts = t;
  }

  return a(i, [{
    key: "init",
    value: function value(e) {
      var i = e.responsiveOverride,
          a = this.opts,
          s = new S(),
          r = new R(a);
      this.chartType = a.chart.type, "histogram" === this.chartType && (a.chart.type = "bar", a = f.extend({
        plotOptions: {
          bar: {
            columnWidth: "99.99%"
          }
        }
      }, a)), a = this.extendYAxis(a), a = this.extendAnnotations(a);
      var n = s.init(),
          o = {};

      if (a && "object" === t(a)) {
        var l = {};
        l = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "histogram", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a.chart.type) ? r[a.chart.type]() : r.line(), a.chart.brush && a.chart.brush.enabled && (l = r.brush(l)), a.chart.stacked && "100%" === a.chart.stackType && (a = r.stacked100(a)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a), a.xaxis = a.xaxis || window.Apex.xaxis || {}, i || (a.xaxis.convertedCatToNumeric = !1), ((a = this.checkForCatToNumericXAxis(this.chartType, l, a)).chart.sparkline && a.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (l = r.sparkline(l)), o = f.extend(n, l);
      }

      var h = f.extend(o, window.Apex);
      return n = f.extend(h, a), n = this.handleUserInputErrors(n);
    }
  }, {
    key: "checkForCatToNumericXAxis",
    value: function value(t, e, i) {
      var a = new R(i),
          s = "bar" === t && i.plotOptions && i.plotOptions.bar && i.plotOptions.bar.horizontal,
          r = "pie" === t || "polarArea" === t || "donut" === t || "radar" === t || "radialBar" === t || "heatmap" === t,
          n = "datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type,
          o = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement;
      return s || r || !n || "between" === o || (i = a.convertCatToNumeric(i)), i;
    }
  }, {
    key: "extendYAxis",
    value: function value(t, e) {
      var i = new S();
      (void 0 === t.yaxis || !t.yaxis || Array.isArray(t.yaxis) && 0 === t.yaxis.length) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = f.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [f.extend(i.yAxis, t.yaxis)] : t.yaxis = f.extendArray(t.yaxis, i.yAxis);
      var a = !1;
      t.yaxis.forEach(function (t) {
        t.logarithmic && (a = !0);
      });
      var s = t.series;
      return e && !s && (s = e.config.series), a && s.length !== t.yaxis.length && s.length && (t.yaxis = s.map(function (e, a) {
        if (e.name || (s[a].name = "series-".concat(a + 1)), t.yaxis[a]) return t.yaxis[a].seriesName = s[a].name, t.yaxis[a];
        var r = f.extend(i.yAxis, t.yaxis[0]);
        return r.show = !1, r;
      })), a && s.length > 1 && s.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t;
    }
  }, {
    key: "extendAnnotations",
    value: function value(t) {
      return void 0 === t.annotations && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), t = this.extendPointAnnotations(t);
    }
  }, {
    key: "extendYAxisAnnotations",
    value: function value(t) {
      var e = new S();
      return t.annotations.yaxis = f.extendArray(void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [], e.yAxisAnnotation), t;
    }
  }, {
    key: "extendXAxisAnnotations",
    value: function value(t) {
      var e = new S();
      return t.annotations.xaxis = f.extendArray(void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [], e.xAxisAnnotation), t;
    }
  }, {
    key: "extendPointAnnotations",
    value: function value(t) {
      var e = new S();
      return t.annotations.points = f.extendArray(void 0 !== t.annotations.points ? t.annotations.points : [], e.pointAnnotation), t;
    }
  }, {
    key: "checkForDarkTheme",
    value: function value(t) {
      t.theme && "dark" === t.theme.mode && (t.tooltip || (t.tooltip = {}), "light" !== t.tooltip.theme && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"));
    }
  }, {
    key: "handleUserInputErrors",
    value: function value(t) {
      var e = t;
      if (e.tooltip.shared && e.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");

      if ("bar" === e.chart.type && e.plotOptions.bar.horizontal) {
        if (e.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
        e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1;
      }

      return "bar" !== e.chart.type && "rangeBar" !== e.chart.type || e.tooltip.shared && "barWidth" === e.xaxis.crosshairs.width && e.series.length > 1 && (console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.'), e.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e.chart.type && "boxPlot" !== e.chart.type || e.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e.chart.type, " chart is not supported.")), e.yaxis[0].reversed = !1), e.chart.group && 0 === e.yaxis[0].labels.minWidth && console.warn("It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour."), Array.isArray(e.stroke.width) && "line" !== e.chart.type && "area" !== e.chart.type && (console.warn("stroke.width option accepts array only for line and area charts. Reverted back to Number"), e.stroke.width = e.stroke.width[0]), e;
    }
  }]), i;
}(),
    H = function () {
  function t() {
    e(this, t);
  }

  return a(t, [{
    key: "initGlobalVars",
    value: function value(t) {
      t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleM = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRangeBarTimeline = [], t.seriesPercent = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.xaxisLabelsCount = 0, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0;
    }
  }, {
    key: "globalVars",
    value: function value(t) {
      return {
        chartID: null,
        cuid: null,
        events: {
          beforeMount: [],
          mounted: [],
          updated: [],
          clicked: [],
          selection: [],
          dataPointSelection: [],
          zoomed: [],
          scrolled: []
        },
        colors: [],
        clientX: null,
        clientY: null,
        fill: {
          colors: []
        },
        stroke: {
          colors: []
        },
        dataLabels: {
          style: {
            colors: []
          }
        },
        radarPolygons: {
          fill: {
            colors: []
          }
        },
        markers: {
          colors: [],
          size: t.markers.size,
          largestSize: 0
        },
        animationEnded: !1,
        isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
        isDirty: !1,
        isExecCalled: !1,
        initialConfig: null,
        initialSeries: [],
        lastXAxis: [],
        lastYAxis: [],
        columnSeries: null,
        labels: [],
        timescaleLabels: [],
        noLabelsProvided: !1,
        allSeriesCollapsed: !1,
        collapsedSeries: [],
        collapsedSeriesIndices: [],
        ancillaryCollapsedSeries: [],
        ancillaryCollapsedSeriesIndices: [],
        risingSeries: [],
        dataFormatXNumeric: !1,
        capturedSeriesIndex: -1,
        capturedDataPointIndex: -1,
        selectedDataPoints: [],
        goldenPadding: 35,
        invalidLogScale: !1,
        ignoreYAxisIndexes: [],
        yAxisSameScaleIndices: [],
        maxValsInArrayIndex: 0,
        radialSize: 0,
        selection: void 0,
        zoomEnabled: "zoom" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
        panEnabled: "pan" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.pan,
        selectionEnabled: "selection" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.selection,
        yaxis: null,
        mousedown: !1,
        lastClientPosition: {},
        visibleXRange: void 0,
        yValueDecimal: 0,
        total: 0,
        SVGNS: "http://www.w3.org/2000/svg",
        svgWidth: 0,
        svgHeight: 0,
        noData: !1,
        locale: {},
        dom: {},
        memory: {
          methodsToExec: []
        },
        shouldAnimate: !0,
        skipLastTimelinelabel: !1,
        skipFirstTimelinelabel: !1,
        delayedElements: [],
        axisCharts: !0,
        isDataXYZ: !1,
        resized: !1,
        resizeTimer: null,
        comboCharts: !1,
        dataChanged: !1,
        previousPaths: [],
        allSeriesHasEqualX: !0,
        pointsArray: [],
        dataLabelsRects: [],
        lastDrawnDataLabelsIndexes: [],
        hasNullValues: !1,
        easing: null,
        zoomed: !1,
        gridWidth: 0,
        gridHeight: 0,
        rotateXLabels: !1,
        defaultLabels: !1,
        xLabelFormatter: void 0,
        yLabelFormatters: [],
        xaxisTooltipFormatter: void 0,
        ttKeyFormatter: void 0,
        ttVal: void 0,
        ttZFormatter: void 0,
        LINE_HEIGHT_RATIO: 1.618,
        xAxisLabelsHeight: 0,
        xAxisLabelsWidth: 0,
        yAxisLabelsWidth: 0,
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0,
        translateYAxisX: [],
        yAxisWidths: [],
        translateXAxisY: 0,
        translateXAxisX: 0,
        tooltip: null
      };
    }
  }, {
    key: "init",
    value: function value(t) {
      var e = this.globalVars(t);
      return this.initGlobalVars(e), e.initialConfig = f.extend({}, t), e.initialSeries = f.clone(t.series), e.lastXAxis = f.clone(e.initialConfig.xaxis), e.lastYAxis = f.clone(e.initialConfig.yaxis), e;
    }
  }]), t;
}(),
    O = function () {
  function t(i) {
    e(this, t), this.opts = i;
  }

  return a(t, [{
    key: "init",
    value: function value() {
      var t = new D(this.opts).init({
        responsiveOverride: !1
      });
      return {
        config: t,
        globals: new H().init(t)
      };
    }
  }]), t;
}(),
    N = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.coreUtils = new y(this.ctx);
  }

  return a(t, [{
    key: "isMultiFormat",
    value: function value() {
      return this.isFormatXY() || this.isFormat2DArray();
    }
  }, {
    key: "isFormatXY",
    value: function value() {
      var t = this.w.config.series.slice(),
          e = new M(this.ctx);
      if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && null !== t[this.activeSeriesIndex].data[0] && void 0 !== t[this.activeSeriesIndex].data[0].x && null !== t[this.activeSeriesIndex].data[0]) return !0;
    }
  }, {
    key: "isFormat2DArray",
    value: function value() {
      var t = this.w.config.series.slice(),
          e = new M(this.ctx);
      if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && void 0 !== t[this.activeSeriesIndex].data[0] && null !== t[this.activeSeriesIndex].data[0] && t[this.activeSeriesIndex].data[0].constructor === Array) return !0;
    }
  }, {
    key: "handleFormat2DArray",
    value: function value(t, e) {
      var i = this.w.config,
          a = this.w.globals,
          s = "boxPlot" === i.chart.type || "boxPlot" === i.series[e].type;
      i.xaxis.sorted && ("datetime" === i.xaxis.type ? t[e].data.sort(function (t, e) {
        return new Date(t[0]).getTime() - new Date(e[0]).getTime();
      }) : "numeric" === i.xaxis.type && t[e].data.sort(function (t, e) {
        return t[0] - e[0];
      }));

      for (var r = 0; r < t[e].data.length; r++) {
        if (void 0 !== t[e].data[r][1] && (Array.isArray(t[e].data[r][1]) && 4 === t[e].data[r][1].length && !s ? this.twoDSeries.push(f.parseNumber(t[e].data[r][1][3])) : t[e].data[r].length >= 5 ? this.twoDSeries.push(f.parseNumber(t[e].data[r][4])) : this.twoDSeries.push(f.parseNumber(t[e].data[r][1])), a.dataFormatXNumeric = !0), "datetime" === i.xaxis.type) {
          var n = new Date(t[e].data[r][0]);
          n = new Date(n).getTime(), this.twoDSeriesX.push(n);
        } else this.twoDSeriesX.push(t[e].data[r][0]);
      }

      for (var o = 0; o < t[e].data.length; o++) {
        void 0 !== t[e].data[o][2] && (this.threeDSeries.push(t[e].data[o][2]), a.isDataXYZ = !0);
      }
    }
  }, {
    key: "handleFormatXY",
    value: function value(t, e) {
      var i = this.w.config,
          a = this.w.globals,
          s = new Y(this.ctx),
          r = e;
      a.collapsedSeriesIndices.indexOf(e) > -1 && (r = this.activeSeriesIndex), i.xaxis.sorted && ("datetime" === i.xaxis.type ? t[e].data.sort(function (t, e) {
        return new Date(t.x).getTime() - new Date(e.x).getTime();
      }) : "numeric" === i.xaxis.type && t[e].data.sort(function (t, e) {
        return t.x - e.x;
      }));

      for (var n = 0; n < t[e].data.length; n++) {
        void 0 !== t[e].data[n].y && (Array.isArray(t[e].data[n].y) ? this.twoDSeries.push(f.parseNumber(t[e].data[n].y[t[e].data[n].y.length - 1])) : this.twoDSeries.push(f.parseNumber(t[e].data[n].y)));
      }

      for (var o = 0; o < t[r].data.length; o++) {
        var l = "string" == typeof t[r].data[o].x,
            h = Array.isArray(t[r].data[o].x),
            c = !h && !!s.isValidDate(t[r].data[o].x.toString());
        if (l || c) {
          if (l || i.xaxis.convertedCatToNumeric) {
            var d = a.isBarHorizontal && a.isRangeData;
            "datetime" !== i.xaxis.type || d ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : this.twoDSeriesX.push(s.parseDate(t[r].data[o].x));
          } else "datetime" === i.xaxis.type ? this.twoDSeriesX.push(s.parseDate(t[r].data[o].x.toString())) : (a.dataFormatXNumeric = !0, a.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[r].data[o].x)));
        } else h ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : (a.isXNumeric = !0, a.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[r].data[o].x));
      }

      if (t[e].data[0] && void 0 !== t[e].data[0].z) {
        for (var g = 0; g < t[e].data.length; g++) {
          this.threeDSeries.push(t[e].data[g].z);
        }

        a.isDataXYZ = !0;
      }
    }
  }, {
    key: "handleRangeData",
    value: function value(t, e) {
      var i = this.w.config,
          a = this.w.globals,
          s = {};
      return this.isFormat2DArray() ? s = this.handleRangeDataFormat("array", t, e) : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", t, e)), a.seriesRangeStart.push(s.start), a.seriesRangeEnd.push(s.end), "datetime" === i.xaxis.type && a.seriesRangeBarTimeline.push(s.rangeUniques), a.seriesRangeBarTimeline.forEach(function (t, e) {
        t && t.forEach(function (t, e) {
          t.y.forEach(function (e, i) {
            for (var a = 0; a < t.y.length; a++) {
              if (i !== a) {
                var s = e.y1,
                    r = e.y2,
                    n = t.y[a].y1;
                s <= t.y[a].y2 && n <= r && (t.overlaps.indexOf(e.rangeName) < 0 && t.overlaps.push(e.rangeName), t.overlaps.indexOf(t.y[a].rangeName) < 0 && t.overlaps.push(t.y[a].rangeName));
              }
            }
          });
        });
      }), s;
    }
  }, {
    key: "handleCandleStickBoxData",
    value: function value(t, e) {
      var i = this.w.globals,
          a = {};
      return this.isFormat2DArray() ? a = this.handleCandleStickBoxDataFormat("array", t, e) : this.isFormatXY() && (a = this.handleCandleStickBoxDataFormat("xy", t, e)), i.seriesCandleO[e] = a.o, i.seriesCandleH[e] = a.h, i.seriesCandleM[e] = a.m, i.seriesCandleL[e] = a.l, i.seriesCandleC[e] = a.c, a;
    }
  }, {
    key: "handleRangeDataFormat",
    value: function value(t, e, i) {
      var a = [],
          s = [],
          r = e[i].data.filter(function (t, e, i) {
        return e === i.findIndex(function (e) {
          return e.x === t.x;
        });
      }).map(function (t, e) {
        return {
          x: t.x,
          overlaps: [],
          y: []
        };
      }),
          n = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts",
          o = new M(this.ctx).getActiveConfigSeriesIndex();

      if ("array" === t) {
        if (2 !== e[o].data[0][1].length) throw new Error(n);

        for (var l = 0; l < e[i].data.length; l++) {
          a.push(e[i].data[l][1][0]), s.push(e[i].data[l][1][1]);
        }
      } else if ("xy" === t) {
        if (2 !== e[o].data[0].y.length) throw new Error(n);

        for (var h = function h(t) {
          var n = f.randomId(),
              o = e[i].data[t].x,
              l = {
            y1: e[i].data[t].y[0],
            y2: e[i].data[t].y[1],
            rangeName: n
          };
          e[i].data[t].rangeName = n;
          var h = r.findIndex(function (t) {
            return t.x === o;
          });
          r[h].y.push(l), a.push(l.y1), s.push(l.y2);
        }, c = 0; c < e[i].data.length; c++) {
          h(c);
        }
      }

      return {
        start: a,
        end: s,
        rangeUniques: r
      };
    }
  }, {
    key: "handleCandleStickBoxDataFormat",
    value: function value(t, e, i) {
      var a = this.w,
          s = "boxPlot" === a.config.chart.type || "boxPlot" === a.config.series[i].type,
          r = [],
          n = [],
          o = [],
          l = [],
          h = [];
      if ("array" === t) {
        if (s && 6 === e[i].data[0].length || !s && 5 === e[i].data[0].length) for (var c = 0; c < e[i].data.length; c++) {
          r.push(e[i].data[c][1]), n.push(e[i].data[c][2]), s ? (o.push(e[i].data[c][3]), l.push(e[i].data[c][4]), h.push(e[i].data[c][5])) : (l.push(e[i].data[c][3]), h.push(e[i].data[c][4]));
        } else for (var d = 0; d < e[i].data.length; d++) {
          Array.isArray(e[i].data[d][1]) && (r.push(e[i].data[d][1][0]), n.push(e[i].data[d][1][1]), s ? (o.push(e[i].data[d][1][2]), l.push(e[i].data[d][1][3]), h.push(e[i].data[d][1][4])) : (l.push(e[i].data[d][1][2]), h.push(e[i].data[d][1][3])));
        }
      } else if ("xy" === t) for (var g = 0; g < e[i].data.length; g++) {
        Array.isArray(e[i].data[g].y) && (r.push(e[i].data[g].y[0]), n.push(e[i].data[g].y[1]), s ? (o.push(e[i].data[g].y[2]), l.push(e[i].data[g].y[3]), h.push(e[i].data[g].y[4])) : (l.push(e[i].data[g].y[2]), h.push(e[i].data[g].y[3])));
      }
      return {
        o: r,
        h: n,
        m: o,
        l: l,
        c: h
      };
    }
  }, {
    key: "parseDataAxisCharts",
    value: function value(t) {
      var e = this,
          i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx,
          a = this.w.config,
          s = this.w.globals,
          r = new Y(i),
          n = a.labels.length > 0 ? a.labels.slice() : a.xaxis.categories.slice();
      s.isTimelineBar = "rangeBar" === a.chart.type && "datetime" === a.xaxis.type;

      for (var o = function o() {
        for (var t = 0; t < n.length; t++) {
          if ("string" == typeof n[t]) {
            if (!r.isValidDate(n[t])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
            e.twoDSeriesX.push(r.parseDate(n[t]));
          } else e.twoDSeriesX.push(n[t]);
        }
      }, l = 0; l < t.length; l++) {
        if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t[l].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
        if ("rangeBar" !== a.chart.type && "rangeArea" !== a.chart.type && "rangeBar" !== t[l].type && "rangeArea" !== t[l].type || (s.isRangeData = !0, this.handleRangeData(t, l)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t, l) : this.isFormatXY() && this.handleFormatXY(t, l), "candlestick" !== a.chart.type && "candlestick" !== t[l].type && "boxPlot" !== a.chart.type && "boxPlot" !== t[l].type || this.handleCandleStickBoxData(t, l), s.series.push(this.twoDSeries), s.labels.push(this.twoDSeriesX), s.seriesX.push(this.twoDSeriesX), l !== this.activeSeriesIndex || this.fallbackToCategory || (s.isXNumeric = !0);else {
          "datetime" === a.xaxis.type ? (s.isXNumeric = !0, o(), s.seriesX.push(this.twoDSeriesX)) : "numeric" === a.xaxis.type && (s.isXNumeric = !0, n.length > 0 && (this.twoDSeriesX = n, s.seriesX.push(this.twoDSeriesX))), s.labels.push(this.twoDSeriesX);
          var h = t[l].data.map(function (t) {
            return f.parseNumber(t);
          });
          s.series.push(h);
        }
        s.seriesZ.push(this.threeDSeries), void 0 !== t[l].name ? s.seriesNames.push(t[l].name) : s.seriesNames.push("series-" + parseInt(l + 1, 10)), void 0 !== t[l].color ? s.seriesColors.push(t[l].color) : s.seriesColors.push(void 0);
      }

      return this.w;
    }
  }, {
    key: "parseDataNonAxisCharts",
    value: function value(t) {
      var e = this.w.globals,
          i = this.w.config;
      e.series = t.slice(), e.seriesNames = i.labels.slice();

      for (var a = 0; a < e.series.length; a++) {
        void 0 === e.seriesNames[a] && e.seriesNames.push("series-" + (a + 1));
      }

      return this.w;
    }
  }, {
    key: "handleExternalLabelsData",
    value: function value(t) {
      var e = this.w.config,
          i = this.w.globals;
      if (e.xaxis.categories.length > 0) i.labels = e.xaxis.categories;else if (e.labels.length > 0) i.labels = e.labels.slice();else if (this.fallbackToCategory) {
        if (i.labels = i.labels[0], i.seriesRangeBarTimeline.length && (i.seriesRangeBarTimeline.map(function (t) {
          t.forEach(function (t) {
            i.labels.indexOf(t.x) < 0 && t.x && i.labels.push(t.x);
          });
        }), i.labels = i.labels.filter(function (t, e, i) {
          return i.indexOf(t) === e;
        })), e.xaxis.convertedCatToNumeric) new R(e).convertCatToNumericXaxis(e, this.ctx, i.seriesX[0]), this._generateExternalLabels(t);
      } else this._generateExternalLabels(t);
    }
  }, {
    key: "_generateExternalLabels",
    value: function value(t) {
      var e = this.w.globals,
          i = this.w.config,
          a = [];

      if (e.axisCharts) {
        if (e.series.length > 0) for (var s = 0; s < e.series[e.maxValsInArrayIndex].length; s++) {
          a.push(s + 1);
        }
        e.seriesX = [];

        for (var r = 0; r < t.length; r++) {
          e.seriesX.push(a);
        }

        e.isXNumeric = !0;
      }

      if (0 === a.length) {
        a = e.axisCharts ? [] : e.series.map(function (t, e) {
          return e + 1;
        });

        for (var n = 0; n < t.length; n++) {
          e.seriesX.push(a);
        }
      }

      e.labels = a, i.xaxis.convertedCatToNumeric && (e.categoryLabels = a.map(function (t) {
        return i.xaxis.labels.formatter(t);
      })), e.noLabelsProvided = !0;
    }
  }, {
    key: "parseData",
    value: function value(t) {
      var e = this.w,
          i = e.config,
          a = e.globals;

      if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a.axisCharts ? this.parseDataAxisCharts(t) : this.parseDataNonAxisCharts(t), this.coreUtils.getLargestSeries(), "bar" === i.chart.type && i.chart.stacked) {
        var s = new M(this.ctx);
        a.series = s.setNullSeriesToZeroValues(a.series);
      }

      this.coreUtils.getSeriesTotals(), a.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), a.dataFormatXNumeric || a.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(t);

      for (var r = this.coreUtils.getCategoryLabels(a.labels), n = 0; n < r.length; n++) {
        if (Array.isArray(r[n])) {
          a.isMultiLineX = !0;
          break;
        }
      }
    }
  }, {
    key: "excludeCollapsedSeriesInYAxis",
    value: function value() {
      var t = this,
          e = this.w;
      e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map(function (i, a) {
        if (t.w.globals.isMultipleYAxis && !e.config.chart.stacked) return i.index;
      });
    }
  }]), t;
}(),
    W = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.tooltipKeyFormat = "dd MMM";
  }

  return a(t, [{
    key: "xLabelFormat",
    value: function value(t, e, i, a) {
      var s = this.w;

      if ("datetime" === s.config.xaxis.type && void 0 === s.config.xaxis.labels.formatter && void 0 === s.config.tooltip.x.formatter) {
        var r = new Y(this.ctx);
        return r.formatDate(r.getDate(e), s.config.tooltip.x.format);
      }

      return t(e, i, a);
    }
  }, {
    key: "defaultGeneralFormatter",
    value: function value(t) {
      return Array.isArray(t) ? t.map(function (t) {
        return t;
      }) : t;
    }
  }, {
    key: "defaultYFormatter",
    value: function value(t, e, i) {
      var a = this.w;
      return f.isNumber(t) && (t = 0 !== a.globals.yValueDecimal ? t.toFixed(void 0 !== e.decimalsInFloat ? e.decimalsInFloat : a.globals.yValueDecimal) : a.globals.maxYArr[i] - a.globals.minYArr[i] < 5 ? t.toFixed(1) : t.toFixed(0)), t;
    }
  }, {
    key: "setLabelFormatters",
    value: function value() {
      var t = this,
          e = this.w;
      return e.globals.xLabelFormatter = function (e) {
        return t.defaultGeneralFormatter(e);
      }, e.globals.xaxisTooltipFormatter = function (e) {
        return t.defaultGeneralFormatter(e);
      }, e.globals.ttKeyFormatter = function (e) {
        return t.defaultGeneralFormatter(e);
      }, e.globals.ttZFormatter = function (t) {
        return t;
      }, e.globals.legendFormatter = function (e) {
        return t.defaultGeneralFormatter(e);
      }, void 0 !== e.config.xaxis.labels.formatter ? e.globals.xLabelFormatter = e.config.xaxis.labels.formatter : e.globals.xLabelFormatter = function (t) {
        if (f.isNumber(t)) {
          if (!e.config.xaxis.convertedCatToNumeric && "numeric" === e.config.xaxis.type && e.globals.dataPoints < 50) return t.toFixed(1);
          if (e.globals.isBarHorizontal) if (e.globals.maxY - e.globals.minYArr < 4) return t.toFixed(1);
          return t.toFixed(0);
        }

        return t;
      }, "function" == typeof e.config.tooltip.x.formatter ? e.globals.ttKeyFormatter = e.config.tooltip.x.formatter : e.globals.ttKeyFormatter = e.globals.xLabelFormatter, "function" == typeof e.config.xaxis.tooltip.formatter && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), (Array.isArray(e.config.tooltip.y) || void 0 !== e.config.tooltip.y.formatter) && (e.globals.ttVal = e.config.tooltip.y), void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach(function (i, a) {
        void 0 !== i.labels.formatter ? e.globals.yLabelFormatters[a] = i.labels.formatter : e.globals.yLabelFormatters[a] = function (s) {
          return e.globals.xyCharts ? Array.isArray(s) ? s.map(function (e) {
            return t.defaultYFormatter(e, i, a);
          }) : t.defaultYFormatter(s, i, a) : s;
        };
      }), e.globals;
    }
  }, {
    key: "heatmapLabelFormatters",
    value: function value() {
      var t = this.w;

      if ("heatmap" === t.config.chart.type) {
        t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
        var e = t.globals.seriesNames.reduce(function (t, e) {
          return t.length > e.length ? t : e;
        }, 0);
        t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e;
      }
    }
  }]), t;
}(),
    B = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "getLabel",
    value: function value(t, e, i, a) {
      var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [],
          r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px",
          n = this.w,
          o = void 0 === t[a] ? "" : t[a],
          l = o,
          h = n.globals.xLabelFormatter,
          c = n.config.xaxis.labels.formatter,
          d = !1,
          g = new W(this.ctx),
          u = o;
      l = g.xLabelFormat(h, o, u, {
        i: a,
        dateFormatter: new Y(this.ctx).formatDate,
        w: n
      }), void 0 !== c && (l = c(o, t[a], {
        i: a,
        dateFormatter: new Y(this.ctx).formatDate,
        w: n
      }));

      var f = function f(t) {
        var i = null;
        return e.forEach(function (t) {
          "month" === t.unit ? i = "year" : "day" === t.unit ? i = "month" : "hour" === t.unit ? i = "day" : "minute" === t.unit && (i = "hour");
        }), i === t;
      };

      e.length > 0 ? (d = f(e[a].unit), i = e[a].position, l = e[a].value) : "datetime" === n.config.xaxis.type && void 0 === c && (l = ""), void 0 === l && (l = ""), l = Array.isArray(l) ? l : l.toString();
      var p = new b(this.ctx),
          x = {};
      x = n.globals.rotateXLabels ? p.getTextRects(l, parseInt(r, 10), null, "rotate(".concat(n.config.xaxis.labels.rotate, " 0 0)"), !1) : p.getTextRects(l, parseInt(r, 10));
      var m = !n.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
      return !Array.isArray(l) && (0 === l.indexOf("NaN") || 0 === l.toLowerCase().indexOf("invalid") || l.toLowerCase().indexOf("infinity") >= 0 || s.indexOf(l) >= 0 && m) && (l = ""), {
        x: i,
        text: l,
        textRect: x,
        isBold: d
      };
    }
  }, {
    key: "checkLabelBasedOnTickamount",
    value: function value(t, e, i) {
      var a = this.w,
          s = a.config.xaxis.tickAmount;
      return "dataPoints" === s && (s = Math.round(a.globals.gridWidth / 120)), s > i || t % Math.round(i / (s + 1)) == 0 || (e.text = ""), e;
    }
  }, {
    key: "checkForOverflowingLabels",
    value: function value(t, e, i, a, s) {
      var r = this.w;

      if (0 === t && r.globals.skipFirstTimelinelabel && (e.text = ""), t === i - 1 && r.globals.skipLastTimelinelabel && (e.text = ""), r.config.xaxis.labels.hideOverlappingLabels && a.length > 0) {
        var n = s[s.length - 1];
        e.x < n.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.01) + n.x && (e.text = "");
      }

      return e;
    }
  }, {
    key: "checkForReversedLabels",
    value: function value(t, e) {
      var i = this.w;
      return i.config.yaxis[t] && i.config.yaxis[t].reversed && e.reverse(), e;
    }
  }, {
    key: "isYAxisHidden",
    value: function value(t) {
      var e = this.w,
          i = new y(this.ctx);
      return !e.config.yaxis[t].show || !e.config.yaxis[t].showForNullSeries && i.isSeriesNull(t) && -1 === e.globals.collapsedSeriesIndices.indexOf(t);
    }
  }, {
    key: "getYAxisForeColor",
    value: function value(t, e) {
      var i = this.w;
      return Array.isArray(t) && i.globals.yAxisScale[e] && this.ctx.theme.pushExtraColors(t, i.globals.yAxisScale[e].result.length, !1), t;
    }
  }, {
    key: "drawYAxisTicks",
    value: function value(t, e, i, a, s, r, n) {
      var o = this.w,
          l = new b(this.ctx),
          h = o.globals.translateY;

      if (a.show && e > 0) {
        !0 === o.config.yaxis[s].opposite && (t += a.width);

        for (var c = e; c >= 0; c--) {
          var d = h + e / 10 + o.config.yaxis[s].labels.offsetY - 1;
          o.globals.isBarHorizontal && (d = r * c), "heatmap" === o.config.chart.type && (d += r / 2);
          var g = l.drawLine(t + i.offsetX - a.width + a.offsetX, d + a.offsetY, t + i.offsetX + a.offsetX, d + a.offsetY, a.color);
          n.add(g), h += r;
        }
      }
    }
  }]), t;
}(),
    V = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "fixSvgStringForIe11",
    value: function value(t) {
      if (!f.isIE11()) return t;
      var e = 0,
          i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function (t) {
        return 2 === ++e ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"' : t;
      });
      return i = (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
    }
  }, {
    key: "getSvgString",
    value: function value() {
      var t = this.w.globals.dom.Paper.svg();
      return this.fixSvgStringForIe11(t);
    }
  }, {
    key: "cleanup",
    value: function value() {
      var t = this.w,
          e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
          i = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
          a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
      Array.prototype.forEach.call(a, function (t) {
        t.setAttribute("width", 0);
      }), e && e[0] && (e[0].setAttribute("x", -500), e[0].setAttribute("x1", -500), e[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100));
    }
  }, {
    key: "svgUrl",
    value: function value() {
      this.cleanup();
      var t = this.getSvgString(),
          e = new Blob([t], {
        type: "image/svg+xml;charset=utf-8"
      });
      return URL.createObjectURL(e);
    }
  }, {
    key: "dataURI",
    value: function value() {
      var t = this;
      return new Promise(function (e) {
        var i = t.w;
        t.cleanup();
        var a = document.createElement("canvas");
        a.width = i.globals.svgWidth, a.height = parseInt(i.globals.dom.elWrap.style.height, 10);
        var s = "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background,
            r = a.getContext("2d");
        r.fillStyle = s, r.fillRect(0, 0, a.width, a.height);
        var n = t.getSvgString();

        if (window.canvg && f.isIE11()) {
          var o = window.canvg.Canvg.fromString(r, n, {
            ignoreClear: !0,
            ignoreDimensions: !0
          });
          o.start();
          var l = a.msToBlob();
          o.stop(), e({
            blob: l
          });
        } else {
          var h = "data:image/svg+xml," + encodeURIComponent(n),
              c = new Image();
          c.crossOrigin = "anonymous", c.onload = function () {
            if (r.drawImage(c, 0, 0), a.msToBlob) {
              var t = a.msToBlob();
              e({
                blob: t
              });
            } else {
              var i = a.toDataURL("image/png");
              e({
                imgURI: i
              });
            }
          }, c.src = h;
        }
      });
    }
  }, {
    key: "exportToSVG",
    value: function value() {
      this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar["export"].svg.filename, ".svg");
    }
  }, {
    key: "exportToPng",
    value: function value() {
      var t = this;
      this.dataURI().then(function (e) {
        var i = e.imgURI,
            a = e.blob;
        a ? navigator.msSaveOrOpenBlob(a, t.w.globals.chartID + ".png") : t.triggerDownload(i, t.w.config.chart.toolbar["export"].png.filename, ".png");
      });
    }
  }, {
    key: "exportToCSV",
    value: function value(t) {
      var e = this,
          i = t.series,
          a = t.columnDelimiter,
          s = t.lineDelimiter,
          r = void 0 === s ? "\n" : s,
          n = this.w,
          o = [],
          l = [],
          h = "data:text/csv;charset=utf-8,\uFEFF",
          c = new N(this.ctx),
          d = new B(this.ctx),
          g = function g(t) {
        var i = "";

        if (n.globals.axisCharts) {
          if ("category" === n.config.xaxis.type || n.config.xaxis.convertedCatToNumeric) if (n.globals.isBarHorizontal) {
            var s = n.globals.yLabelFormatters[0],
                r = new M(e.ctx).getActiveConfigSeriesIndex();
            i = s(n.globals.labels[t], {
              seriesIndex: r,
              dataPointIndex: t,
              w: n
            });
          } else i = d.getLabel(n.globals.labels, n.globals.timescaleLabels, 0, t).text;
          "datetime" === n.config.xaxis.type && (n.config.xaxis.categories.length ? i = n.config.xaxis.categories[t] : n.config.labels.length && (i = n.config.labels[t]));
        } else i = n.config.labels[t];

        return Array.isArray(i) && (i = i.join(" ")), f.isNumber(i) ? i : i.split(a).join("");
      };

      o.push(n.config.chart.toolbar["export"].csv.headerCategory), i.map(function (t, e) {
        var i = t.name ? t.name : "series-".concat(e);
        n.globals.axisCharts && o.push(i.split(a).join("") ? i.split(a).join("") : "series-".concat(e));
      }), n.globals.axisCharts || (o.push(n.config.chart.toolbar["export"].csv.headerValue), l.push(o.join(a))), i.map(function (t, e) {
        n.globals.axisCharts ? function (t, e) {
          if (o.length && 0 === e && l.push(o.join(a)), t.data && t.data.length) for (var s = 0; s < t.data.length; s++) {
            o = [];
            var r = g(s);

            if (r || (c.isFormatXY() ? r = i[e].data[s].x : c.isFormat2DArray() && (r = i[e].data[s] ? i[e].data[s][0] : "")), 0 === e) {
              o.push((d = r, "datetime" === n.config.xaxis.type && String(d).length >= 10 ? n.config.chart.toolbar["export"].csv.dateFormatter(r) : r.split(a).join("")));

              for (var h = 0; h < n.globals.series.length; h++) {
                o.push(n.globals.series[h][s]);
              }
            }

            ("candlestick" === n.config.chart.type || t.type && "candlestick" === t.type) && (o.pop(), o.push(n.globals.seriesCandleO[e][s]), o.push(n.globals.seriesCandleH[e][s]), o.push(n.globals.seriesCandleL[e][s]), o.push(n.globals.seriesCandleC[e][s])), ("boxPlot" === n.config.chart.type || t.type && "boxPlot" === t.type) && (o.pop(), o.push(n.globals.seriesCandleO[e][s]), o.push(n.globals.seriesCandleH[e][s]), o.push(n.globals.seriesCandleM[e][s]), o.push(n.globals.seriesCandleL[e][s]), o.push(n.globals.seriesCandleC[e][s])), "rangeBar" === n.config.chart.type && (o.pop(), o.push(n.globals.seriesRangeStart[e][s]), o.push(n.globals.seriesRangeEnd[e][s])), o.length && l.push(o.join(a));
          }
          var d;
        }(t, e) : ((o = []).push(n.globals.labels[e].split(a).join("")), o.push(n.globals.series[e]), l.push(o.join(a)));
      }), h += l.join(r), this.triggerDownload(encodeURI(h), n.config.chart.toolbar["export"].csv.filename, ".csv");
    }
  }, {
    key: "triggerDownload",
    value: function value(t, e, i) {
      var a = document.createElement("a");
      a.href = t, a.download = (e || this.w.globals.chartID) + i, document.body.appendChild(a), a.click(), document.body.removeChild(a);
    }
  }]), t;
}(),
    G = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
    var a = this.w;
    this.axesUtils = new B(i), this.xaxisLabels = a.globals.labels.slice(), a.globals.timescaleLabels.length > 0 && !a.globals.isBarHorizontal && (this.xaxisLabels = a.globals.timescaleLabels.slice()), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === a.config.xaxis.position ? this.offY = 0 : this.offY = a.globals.gridHeight + 1, this.offY = this.offY + a.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === a.config.chart.type && a.config.plotOptions.bar.horizontal, this.xaxisFontSize = a.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = a.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = a.config.xaxis.labels.style.colors, this.xaxisBorderWidth = a.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = a.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = a.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = a.config.xaxis.axisBorder.height, this.yaxis = a.config.yaxis[0];
  }

  return a(t, [{
    key: "drawXaxis",
    value: function value() {
      var t,
          e = this,
          i = this.w,
          a = new b(this.ctx),
          s = a.group({
        "class": "apexcharts-xaxis",
        transform: "translate(".concat(i.config.xaxis.offsetX, ", ").concat(i.config.xaxis.offsetY, ")")
      }),
          r = a.group({
        "class": "apexcharts-xaxis-texts-g",
        transform: "translate(".concat(i.globals.translateXAxisX, ", ").concat(i.globals.translateXAxisY, ")")
      });
      s.add(r);

      for (var n = i.globals.padHorizontal, o = [], l = 0; l < this.xaxisLabels.length; l++) {
        o.push(this.xaxisLabels[l]);
      }

      var h = o.length;

      if (i.globals.isXNumeric) {
        var c = h > 1 ? h - 1 : h;
        t = i.globals.gridWidth / c, n = n + t / 2 + i.config.xaxis.labels.offsetX;
      } else t = i.globals.gridWidth / o.length, n = n + t + i.config.xaxis.labels.offsetX;

      for (var d = function d(s) {
        var l = n - t / 2 + i.config.xaxis.labels.offsetX;
        0 === s && 1 === h && t / 2 === n && 1 === i.globals.dataPoints && (l = i.globals.gridWidth / 2);
        var c = e.axesUtils.getLabel(o, i.globals.timescaleLabels, l, s, e.drawnLabels, e.xaxisFontSize),
            d = 28;
        i.globals.rotateXLabels && (d = 22);

        if ((c = void 0 !== i.config.xaxis.tickAmount && "dataPoints" !== i.config.xaxis.tickAmount && "datetime" !== i.config.xaxis.type ? e.axesUtils.checkLabelBasedOnTickamount(s, c, h) : e.axesUtils.checkForOverflowingLabels(s, c, h, e.drawnLabels, e.drawnLabelsRects)).text && i.globals.xaxisLabelsCount++, i.config.xaxis.labels.show) {
          var g = a.drawText({
            x: c.x,
            y: e.offY + i.config.xaxis.labels.offsetY + d - ("top" === i.config.xaxis.position ? i.globals.xAxisHeight + i.config.xaxis.axisTicks.height - 2 : 0),
            text: c.text,
            textAnchor: "middle",
            fontWeight: c.isBold ? 600 : i.config.xaxis.labels.style.fontWeight,
            fontSize: e.xaxisFontSize,
            fontFamily: e.xaxisFontFamily,
            foreColor: Array.isArray(e.xaxisForeColors) ? i.config.xaxis.convertedCatToNumeric ? e.xaxisForeColors[i.globals.minX + s - 1] : e.xaxisForeColors[s] : e.xaxisForeColors,
            isPlainText: !1,
            cssClass: "apexcharts-xaxis-label " + i.config.xaxis.labels.style.cssClass
          });
          r.add(g);
          var u = document.createElementNS(i.globals.SVGNS, "title");
          u.textContent = Array.isArray(c.text) ? c.text.join(" ") : c.text, g.node.appendChild(u), "" !== c.text && (e.drawnLabels.push(c.text), e.drawnLabelsRects.push(c));
        }

        n += t;
      }, g = 0; g <= h - 1; g++) {
        d(g);
      }

      if (void 0 !== i.config.xaxis.title.text) {
        var u = a.group({
          "class": "apexcharts-xaxis-title"
        }),
            f = a.drawText({
          x: i.globals.gridWidth / 2 + i.config.xaxis.title.offsetX,
          y: this.offY + parseFloat(this.xaxisFontSize) + i.globals.xAxisLabelsHeight + i.config.xaxis.title.offsetY,
          text: i.config.xaxis.title.text,
          textAnchor: "middle",
          fontSize: i.config.xaxis.title.style.fontSize,
          fontFamily: i.config.xaxis.title.style.fontFamily,
          fontWeight: i.config.xaxis.title.style.fontWeight,
          foreColor: i.config.xaxis.title.style.color,
          cssClass: "apexcharts-xaxis-title-text " + i.config.xaxis.title.style.cssClass
        });
        u.add(f), s.add(u);
      }

      if (i.config.xaxis.axisBorder.show) {
        var p = i.globals.barPadForNumericAxis,
            x = a.drawLine(i.globals.padHorizontal + i.config.xaxis.axisBorder.offsetX - p, this.offY, this.xaxisBorderWidth + p, this.offY, i.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        s.add(x);
      }

      return s;
    }
  }, {
    key: "drawXaxisInversed",
    value: function value(t) {
      var e,
          i,
          a = this,
          s = this.w,
          r = new b(this.ctx),
          n = s.config.yaxis[0].opposite ? s.globals.translateYAxisX[t] : 0,
          o = r.group({
        "class": "apexcharts-yaxis apexcharts-xaxis-inversed",
        rel: t
      }),
          l = r.group({
        "class": "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
        transform: "translate(" + n + ", 0)"
      });
      o.add(l);
      var h = [];
      if (s.config.yaxis[t].show) for (var c = 0; c < this.xaxisLabels.length; c++) {
        h.push(this.xaxisLabels[c]);
      }
      e = s.globals.gridHeight / h.length, i = -e / 2.2;
      var d = s.globals.yLabelFormatters[0],
          g = s.config.yaxis[0].labels;
      if (g.show) for (var u = function u(n) {
        var o = void 0 === h[n] ? "" : h[n];
        o = d(o, {
          seriesIndex: t,
          dataPointIndex: n,
          w: s
        });
        var c = a.axesUtils.getYAxisForeColor(g.style.colors, t),
            u = 0;
        Array.isArray(o) && (u = o.length / 2 * parseInt(g.style.fontSize, 10));
        var f = r.drawText({
          x: g.offsetX - 15,
          y: i + e + g.offsetY - u,
          text: o,
          textAnchor: a.yaxis.opposite ? "start" : "end",
          foreColor: Array.isArray(c) ? c[n] : c,
          fontSize: g.style.fontSize,
          fontFamily: g.style.fontFamily,
          fontWeight: g.style.fontWeight,
          isPlainText: !1,
          cssClass: "apexcharts-yaxis-label " + g.style.cssClass
        });
        l.add(f);
        var p = document.createElementNS(s.globals.SVGNS, "title");

        if (p.textContent = o.text, f.node.appendChild(p), 0 !== s.config.yaxis[t].labels.rotate) {
          var x = r.rotateAroundCenter(f.node);
          f.node.setAttribute("transform", "rotate(".concat(s.config.yaxis[t].labels.rotate, " 0 ").concat(x.y, ")"));
        }

        i += e;
      }, f = 0; f <= h.length - 1; f++) {
        u(f);
      }

      if (void 0 !== s.config.yaxis[0].title.text) {
        var p = r.group({
          "class": "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
          transform: "translate(" + n + ", 0)"
        }),
            x = r.drawText({
          x: 0,
          y: s.globals.gridHeight / 2,
          text: s.config.yaxis[0].title.text,
          textAnchor: "middle",
          foreColor: s.config.yaxis[0].title.style.color,
          fontSize: s.config.yaxis[0].title.style.fontSize,
          fontWeight: s.config.yaxis[0].title.style.fontWeight,
          fontFamily: s.config.yaxis[0].title.style.fontFamily,
          cssClass: "apexcharts-yaxis-title-text " + s.config.yaxis[0].title.style.cssClass
        });
        p.add(x), o.add(p);
      }

      var m = 0;
      this.isCategoryBarHorizontal && s.config.yaxis[0].opposite && (m = s.globals.gridWidth);
      var v = s.config.xaxis.axisBorder;

      if (v.show) {
        var y = r.drawLine(s.globals.padHorizontal + v.offsetX + m, 1 + v.offsetY, s.globals.padHorizontal + v.offsetX + m, s.globals.gridHeight + v.offsetY, v.color, 0);
        o.add(y);
      }

      return s.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(m, h.length, s.config.yaxis[0].axisBorder, s.config.yaxis[0].axisTicks, 0, e, o), o;
    }
  }, {
    key: "drawXaxisTicks",
    value: function value(t, e) {
      var i = this.w,
          a = t;

      if (!(t < 0 || t - 2 > i.globals.gridWidth)) {
        var s = this.offY + i.config.xaxis.axisTicks.offsetY,
            r = s + i.config.xaxis.axisTicks.height;

        if ("top" === i.config.xaxis.position && (r = s - i.config.xaxis.axisTicks.height), i.config.xaxis.axisTicks.show) {
          var n = new b(this.ctx).drawLine(t + i.config.xaxis.axisTicks.offsetX, s + i.config.xaxis.offsetY, a + i.config.xaxis.axisTicks.offsetX, r + i.config.xaxis.offsetY, i.config.xaxis.axisTicks.color);
          e.add(n), n.node.classList.add("apexcharts-xaxis-tick");
        }
      }
    }
  }, {
    key: "getXAxisTicksPositions",
    value: function value() {
      var t = this.w,
          e = [],
          i = this.xaxisLabels.length,
          a = t.globals.padHorizontal;
      if (t.globals.timescaleLabels.length > 0) for (var s = 0; s < i; s++) {
        a = this.xaxisLabels[s].position, e.push(a);
      } else for (var r = i, n = 0; n < r; n++) {
        var o = r;
        t.globals.isXNumeric && "bar" !== t.config.chart.type && (o -= 1), a += t.globals.gridWidth / o, e.push(a);
      }
      return e;
    }
  }, {
    key: "xAxisLabelCorrections",
    value: function value() {
      var t = this.w,
          e = new b(this.ctx),
          i = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
          a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text"),
          s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
          r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
      if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways) for (var n = 0; n < a.length; n++) {
        var o = e.rotateAroundCenter(a[n]);
        o.y = o.y - 1, o.x = o.x + 1, a[n].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")), a[n].setAttribute("text-anchor", "end");
        i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
        var l = a[n].childNodes;
        t.config.xaxis.labels.trim && Array.prototype.forEach.call(l, function (i) {
          e.placeTextWithEllipsis(i, i.textContent, t.globals.xAxisLabelsHeight - ("bottom" === t.config.legend.position ? 20 : 10));
        });
      } else !function () {
        for (var i = t.globals.gridWidth / (t.globals.labels.length + 1), s = 0; s < a.length; s++) {
          var r = a[s].childNodes;
          t.config.xaxis.labels.trim && "datetime" !== t.config.xaxis.type && Array.prototype.forEach.call(r, function (t) {
            e.placeTextWithEllipsis(t, t.textContent, i);
          });
        }
      }();

      if (s.length > 0) {
        var h = s[s.length - 1].getBBox(),
            c = s[0].getBBox();
        h.x < -20 && s[s.length - 1].parentNode.removeChild(s[s.length - 1]), c.x + c.width > t.globals.gridWidth && !t.globals.isBarHorizontal && s[0].parentNode.removeChild(s[0]);

        for (var d = 0; d < r.length; d++) {
          e.placeTextWithEllipsis(r[d], r[d].textContent, t.config.yaxis[0].labels.maxWidth - 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) - 20);
        }
      }
    }
  }]), t;
}(),
    _ = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
    var a = this.w;
    this.xaxisLabels = a.globals.labels.slice(), this.axesUtils = new B(i), this.isTimelineBar = "datetime" === a.config.xaxis.type && a.globals.seriesRangeBarTimeline.length, a.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a.globals.timescaleLabels.slice());
  }

  return a(t, [{
    key: "drawGridArea",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
          e = this.w,
          i = new b(this.ctx);
      null === t && (t = i.group({
        "class": "apexcharts-grid"
      }));
      var a = i.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, "transparent"),
          s = i.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, "transparent");
      return t.add(s), t.add(a), t;
    }
  }, {
    key: "drawGrid",
    value: function value() {
      var t = null;
      return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t;
    }
  }, {
    key: "createGridMask",
    value: function value() {
      var t = this.w,
          e = t.globals,
          i = new b(this.ctx),
          a = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;

      if (Array.isArray(t.config.stroke.width)) {
        var s = 0;
        t.config.stroke.width.forEach(function (t) {
          s = Math.max(s, t);
        }), a = s;
      }

      e.dom.elGridRectMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e.cuid));
      var r = t.config.chart.type,
          n = 0,
          o = 0;
      ("bar" === r || "rangeBar" === r || "candlestick" === r || "boxPlot" === r || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (n = t.config.grid.padding.left, o = t.config.grid.padding.right, e.barPadForNumericAxis > n && (n = e.barPadForNumericAxis, o = e.barPadForNumericAxis)), e.dom.elGridRect = i.drawRect(-a / 2 - n - 2, -a / 2, e.gridWidth + a + o + n + 4, e.gridHeight + a, 0, "#fff"), new y(this).getLargestMarkerSize();
      var l = t.globals.markers.largestSize + 1;
      e.dom.elGridRectMarker = i.drawRect(2 * -l, 2 * -l, e.gridWidth + 4 * l, e.gridHeight + 4 * l, 0, "#fff"), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);
      var h = e.dom.baseEl.querySelector("defs");
      h.appendChild(e.dom.elGridRectMask), h.appendChild(e.dom.elGridRectMarkerMask);
    }
  }, {
    key: "_drawGridLines",
    value: function value(t) {
      var e = t.i,
          i = t.x1,
          a = t.y1,
          s = t.x2,
          r = t.y2,
          n = t.xCount,
          o = t.parent,
          l = this.w;
      0 === e && l.globals.skipFirstTimelinelabel || e === n - 1 && l.globals.skipLastTimelinelabel && !l.config.xaxis.labels.formatter || "radar" === l.config.chart.type || (l.config.grid.xaxis.lines.show && this._drawGridLine({
        x1: i,
        y1: a,
        x2: s,
        y2: r,
        parent: o
      }), new G(this.ctx).drawXaxisTicks(i, this.elg));
    }
  }, {
    key: "_drawGridLine",
    value: function value(t) {
      var e = t.x1,
          i = t.y1,
          a = t.x2,
          s = t.y2,
          r = t.parent,
          n = this.w,
          o = r.node.classList.contains("apexcharts-gridlines-horizontal"),
          l = n.config.grid.strokeDashArray,
          h = n.globals.barPadForNumericAxis,
          c = new b(this).drawLine(e - (o ? h : 0), i, a + (o ? h : 0), s, n.config.grid.borderColor, l);
      c.node.classList.add("apexcharts-gridline"), r.add(c);
    }
  }, {
    key: "_drawGridBandRect",
    value: function value(t) {
      var e = t.c,
          i = t.x1,
          a = t.y1,
          s = t.x2,
          r = t.y2,
          n = t.type,
          o = this.w,
          l = new b(this.ctx),
          h = o.globals.barPadForNumericAxis;

      if ("column" !== n || "datetime" !== o.config.xaxis.type) {
        var c = o.config.grid[n].colors[e],
            d = l.drawRect(i - ("row" === n ? h : 0), a, s + ("row" === n ? 2 * h : 0), r, 0, c, o.config.grid[n].opacity);
        this.elg.add(d), d.attr("clip-path", "url(#gridRectMask".concat(o.globals.cuid, ")")), d.node.classList.add("apexcharts-grid-".concat(n));
      }
    }
  }, {
    key: "_drawXYLines",
    value: function value(t) {
      var e = this,
          i = t.xCount,
          a = t.tickAmount,
          s = this.w;

      if (s.config.grid.xaxis.lines.show || s.config.xaxis.axisTicks.show) {
        var r,
            n = s.globals.padHorizontal,
            o = s.globals.gridHeight;
        s.globals.timescaleLabels.length ? function (t) {
          for (var a = t.xC, s = t.x1, r = t.y1, n = t.x2, o = t.y2, l = 0; l < a; l++) {
            s = e.xaxisLabels[l].position, n = e.xaxisLabels[l].position, e._drawGridLines({
              i: l,
              x1: s,
              y1: r,
              x2: n,
              y2: o,
              xCount: i,
              parent: e.elgridLinesV
            });
          }
        }({
          xC: i,
          x1: n,
          y1: 0,
          x2: r,
          y2: o
        }) : (s.globals.isXNumeric && (i = s.globals.xAxisScale.result.length), s.config.xaxis.convertedCatToNumeric && (i = s.globals.xaxisLabelsCount), function (t) {
          var a = t.xC,
              r = t.x1,
              n = t.y1,
              o = t.x2,
              l = t.y2;
          if (void 0 !== s.config.xaxis.tickAmount && "dataPoints" !== s.config.xaxis.tickAmount) s.globals.dom.baseEl.querySelectorAll(".apexcharts-text.apexcharts-xaxis-label tspan:not(:empty)").forEach(function (t, a) {
            var s = t.getBBox();

            e._drawGridLines({
              i: a,
              x1: s.x + s.width / 2,
              y1: n,
              x2: s.x + s.width / 2,
              y2: l,
              xCount: i,
              parent: e.elgridLinesV
            });
          });else for (var h = 0; h < a + (s.globals.isXNumeric ? 0 : 1); h++) {
            0 === h && 1 === a && 1 === s.globals.dataPoints && (o = r = s.globals.gridWidth / 2), e._drawGridLines({
              i: h,
              x1: r,
              y1: n,
              x2: o,
              y2: l,
              xCount: i,
              parent: e.elgridLinesV
            }), o = r += s.globals.gridWidth / (s.globals.isXNumeric ? a - 1 : a);
          }
        }({
          xC: i,
          x1: n,
          y1: 0,
          x2: r,
          y2: o
        }));
      }

      if (s.config.grid.yaxis.lines.show) {
        var l = 0,
            h = 0,
            c = s.globals.gridWidth,
            d = a + 1;
        this.isTimelineBar && (d = s.globals.labels.length);

        for (var g = 0; g < d + (this.isTimelineBar ? 1 : 0); g++) {
          this._drawGridLine({
            x1: 0,
            y1: l,
            x2: c,
            y2: h,
            parent: this.elgridLinesH
          }), h = l += s.globals.gridHeight / (this.isTimelineBar ? d : a);
        }
      }
    }
  }, {
    key: "_drawInvertedXYLines",
    value: function value(t) {
      var e = t.xCount,
          i = this.w;
      if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) for (var a, s = i.globals.padHorizontal, r = i.globals.gridHeight, n = 0; n < e + 1; n++) {
        i.config.grid.xaxis.lines.show && this._drawGridLine({
          x1: s,
          y1: 0,
          x2: a,
          y2: r,
          parent: this.elgridLinesV
        }), new G(this.ctx).drawXaxisTicks(s, this.elg), a = s = s + i.globals.gridWidth / e + .3;
      }
      if (i.config.grid.yaxis.lines.show) for (var o = 0, l = 0, h = i.globals.gridWidth, c = 0; c < i.globals.dataPoints + 1; c++) {
        this._drawGridLine({
          x1: 0,
          y1: o,
          x2: h,
          y2: l,
          parent: this.elgridLinesH
        }), l = o += i.globals.gridHeight / i.globals.dataPoints;
      }
    }
  }, {
    key: "renderGrid",
    value: function value() {
      var t = this.w,
          e = new b(this.ctx);
      this.elg = e.group({
        "class": "apexcharts-grid"
      }), this.elgridLinesH = e.group({
        "class": "apexcharts-gridlines-horizontal"
      }), this.elgridLinesV = e.group({
        "class": "apexcharts-gridlines-vertical"
      }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide());

      for (var i, a = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, s = 0; s < t.globals.series.length && (void 0 !== t.globals.yAxisScale[s] && (a = t.globals.yAxisScale[s].result.length - 1), !(a > 2)); s++) {
        ;
      }

      return !t.globals.isBarHorizontal || this.isTimelineBar ? (i = this.xaxisLabels.length, this.isTimelineBar && (a = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (i = t.config.xaxis.tickAmount)), this._drawXYLines({
        xCount: i,
        tickAmount: a
      })) : (i = a, a = t.globals.xTickAmount, this._drawInvertedXYLines({
        xCount: i,
        tickAmount: a
      })), this.drawGridBands(i, a), {
        el: this.elg,
        xAxisTickWidth: t.globals.gridWidth / i
      };
    }
  }, {
    key: "drawGridBands",
    value: function value(t, e) {
      var i = this.w;
      if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0) for (var a = 0, s = i.globals.gridHeight / e, r = i.globals.gridWidth, n = 0, o = 0; n < e; n++, o++) {
        o >= i.config.grid.row.colors.length && (o = 0), this._drawGridBandRect({
          c: o,
          x1: 0,
          y1: a,
          x2: r,
          y2: s,
          type: "row"
        }), a += i.globals.gridHeight / e;
      }
      if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0) for (var l = i.globals.isBarHorizontal || "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric ? t : t - 1, h = i.globals.padHorizontal, c = i.globals.padHorizontal + i.globals.gridWidth / l, d = i.globals.gridHeight, g = 0, u = 0; g < t; g++, u++) {
        u >= i.config.grid.column.colors.length && (u = 0), this._drawGridBandRect({
          c: u,
          x1: h,
          y1: 0,
          x2: c,
          y2: d,
          type: "column"
        }), h += i.globals.gridWidth / l;
      }
    }
  }]), t;
}(),
    j = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "niceScale",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
          a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
          s = arguments.length > 4 ? arguments[4] : void 0,
          r = this.w,
          n = Math.abs(e - t);

      if ("dataPoints" === (i = this._adjustTicksForSmallRange(i, a, n)) && (i = r.globals.dataPoints - 1), t === Number.MIN_VALUE && 0 === e || !f.isNumber(t) && !f.isNumber(e) || t === Number.MIN_VALUE && e === -Number.MAX_VALUE) {
        t = 0, e = i;
        var o = this.linearScale(t, e, i);
        return o;
      }

      t > e ? (console.warn("axis.min cannot be greater than axis.max"), e = t + .1) : t === e && (t = 0 === t ? 0 : t - .5, e = 0 === e ? 2 : e + .5);
      var l = [];
      n < 1 && s && ("candlestick" === r.config.chart.type || "candlestick" === r.config.series[a].type || "boxPlot" === r.config.chart.type || "boxPlot" === r.config.series[a].type || r.globals.isRangeData) && (e *= 1.01);
      var h = i + 1;
      h < 2 ? h = 2 : h > 2 && (h -= 2);
      var c = n / h,
          d = Math.floor(f.log10(c)),
          g = Math.pow(10, d),
          u = Math.round(c / g);
      u < 1 && (u = 1);
      var p = u * g,
          x = p * Math.floor(t / p),
          b = p * Math.ceil(e / p),
          m = x;

      if (s && n > 2) {
        for (; l.push(m), !((m += p) > b);) {
          ;
        }

        return {
          result: l,
          niceMin: l[0],
          niceMax: l[l.length - 1]
        };
      }

      var v = t;
      (l = []).push(v);

      for (var y = Math.abs(e - t) / i, w = 0; w <= i; w++) {
        v += y, l.push(v);
      }

      return l[l.length - 2] >= e && l.pop(), {
        result: l,
        niceMin: l[0],
        niceMax: l[l.length - 1]
      };
    }
  }, {
    key: "linearScale",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
          a = arguments.length > 3 ? arguments[3] : void 0,
          s = Math.abs(e - t);
      "dataPoints" === (i = this._adjustTicksForSmallRange(i, a, s)) && (i = this.w.globals.dataPoints - 1);
      var r = s / i;
      i === Number.MAX_VALUE && (i = 10, r = 1);

      for (var n = [], o = t; i >= 0;) {
        n.push(o), o += r, i -= 1;
      }

      return {
        result: n,
        niceMin: n[0],
        niceMax: n[n.length - 1]
      };
    }
  }, {
    key: "logarithmicScale",
    value: function value(t) {
      for (var e = [], i = Math.ceil(Math.log10(t)) + 1, a = 0; a < i; a++) {
        e.push(Math.pow(10, a));
      }

      return {
        result: e,
        niceMin: e[0],
        niceMax: e[e.length - 1]
      };
    }
  }, {
    key: "_adjustTicksForSmallRange",
    value: function value(t, e, i) {
      var a = t;

      if (void 0 !== e && this.w.config.yaxis[e].labels.formatter && void 0 === this.w.config.yaxis[e].tickAmount) {
        var s = this.w.config.yaxis[e].labels.formatter(1);
        f.isNumber(Number(s)) && !f.isFloat(s) && (a = Math.ceil(i));
      }

      return a < t ? a : t;
    }
  }, {
    key: "setYScaleForIndex",
    value: function value(t, e, i) {
      var a = this.w.globals,
          s = this.w.config,
          r = a.isBarHorizontal ? s.xaxis : s.yaxis[t];
      void 0 === a.yAxisScale[t] && (a.yAxisScale[t] = []);
      var n = Math.abs(i - e);
      if (r.logarithmic && n <= 5 && (a.invalidLogScale = !0), r.logarithmic && n > 5) a.allSeriesCollapsed = !1, a.yAxisScale[t] = this.logarithmicScale(i);else if (i !== -Number.MAX_VALUE && f.isNumber(i)) {
        if (a.allSeriesCollapsed = !1, void 0 === r.min && void 0 === r.max || r.forceNiceScale) {
          var o = void 0 === s.yaxis[t].max && void 0 === s.yaxis[t].min || s.yaxis[t].forceNiceScale;
          a.yAxisScale[t] = this.niceScale(e, i, r.tickAmount ? r.tickAmount : n < 5 && n > 1 ? n + 1 : 5, t, o);
        } else a.yAxisScale[t] = this.linearScale(e, i, r.tickAmount, t);
      } else a.yAxisScale[t] = this.linearScale(0, 5, 5);
    }
  }, {
    key: "setXScale",
    value: function value(t, e) {
      var i = this.w,
          a = i.globals,
          s = i.config.xaxis,
          r = Math.abs(e - t);
      return e !== -Number.MAX_VALUE && f.isNumber(e) ? a.xAxisScale = this.linearScale(t, e, s.tickAmount ? s.tickAmount : r < 5 && r > 1 ? r + 1 : 5, 0) : a.xAxisScale = this.linearScale(0, 5, 5), a.xAxisScale;
    }
  }, {
    key: "setMultipleYScales",
    value: function value() {
      var t = this,
          e = this.w.globals,
          i = this.w.config,
          a = e.minYArr.concat([]),
          s = e.maxYArr.concat([]),
          r = [];
      i.yaxis.forEach(function (e, n) {
        var o = n;
        i.series.forEach(function (t, i) {
          t.name === e.seriesName && (o = i, n !== i ? r.push({
            index: i,
            similarIndex: n,
            alreadyExists: !0
          }) : r.push({
            index: i
          }));
        });
        var l = a[o],
            h = s[o];
        t.setYScaleForIndex(n, l, h);
      }), this.sameScaleInMultipleAxes(a, s, r);
    }
  }, {
    key: "sameScaleInMultipleAxes",
    value: function value(t, e, i) {
      var a = this,
          s = this.w.config,
          r = this.w.globals,
          n = [];
      i.forEach(function (t) {
        t.alreadyExists && (void 0 === n[t.index] && (n[t.index] = []), n[t.index].push(t.index), n[t.index].push(t.similarIndex));
      }), r.yAxisSameScaleIndices = n, n.forEach(function (t, e) {
        n.forEach(function (i, a) {
          var s, r;
          e !== a && (s = t, r = i, s.filter(function (t) {
            return -1 !== r.indexOf(t);
          })).length > 0 && (n[e] = n[e].concat(n[a]));
        });
      });
      var o = n.map(function (t) {
        return t.filter(function (e, i) {
          return t.indexOf(e) === i;
        });
      }).map(function (t) {
        return t.sort();
      });
      n = n.filter(function (t) {
        return !!t;
      });
      var l = o.slice(),
          h = l.map(function (t) {
        return JSON.stringify(t);
      });
      l = l.filter(function (t, e) {
        return h.indexOf(JSON.stringify(t)) === e;
      });
      var c = [],
          d = [];
      t.forEach(function (t, i) {
        l.forEach(function (a, s) {
          a.indexOf(i) > -1 && (void 0 === c[s] && (c[s] = [], d[s] = []), c[s].push({
            key: i,
            value: t
          }), d[s].push({
            key: i,
            value: e[i]
          }));
        });
      });
      var g = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE),
          u = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
      c.forEach(function (t, e) {
        t.forEach(function (t, i) {
          g[e] = Math.min(t.value, g[e]);
        });
      }), d.forEach(function (t, e) {
        t.forEach(function (t, i) {
          u[e] = Math.max(t.value, u[e]);
        });
      }), t.forEach(function (t, e) {
        d.forEach(function (t, i) {
          var n = g[i],
              o = u[i];
          s.chart.stacked && (o = 0, t.forEach(function (t, e) {
            t.value !== -Number.MAX_VALUE && (o += t.value), n !== Number.MIN_VALUE && (n += c[i][e].value);
          })), t.forEach(function (i, l) {
            t[l].key === e && (void 0 !== s.yaxis[e].min && (n = "function" == typeof s.yaxis[e].min ? s.yaxis[e].min(r.minY) : s.yaxis[e].min), void 0 !== s.yaxis[e].max && (o = "function" == typeof s.yaxis[e].max ? s.yaxis[e].max(r.maxY) : s.yaxis[e].max), a.setYScaleForIndex(e, n, o));
          });
        });
      });
    }
  }, {
    key: "autoScaleY",
    value: function value(t, e, i) {
      t || (t = this);
      var a = t.w;
      if (a.globals.isMultipleYAxis || a.globals.collapsedSeries.length) return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), e;
      var s = a.globals.seriesX[0],
          r = a.config.chart.stacked;
      return e.forEach(function (t, n) {
        for (var o = 0, l = 0; l < s.length; l++) {
          if (s[l] >= i.xaxis.min) {
            o = l;
            break;
          }
        }

        var h,
            c,
            d = a.globals.minYArr[n],
            g = a.globals.maxYArr[n],
            u = a.globals.stackedSeriesTotals;
        a.globals.series.forEach(function (n, l) {
          var f = n[o];
          r ? (f = u[o], h = c = f, u.forEach(function (t, e) {
            s[e] <= i.xaxis.max && s[e] >= i.xaxis.min && (t > c && null !== t && (c = t), n[e] < h && null !== n[e] && (h = n[e]));
          })) : (h = c = f, n.forEach(function (t, e) {
            if (s[e] <= i.xaxis.max && s[e] >= i.xaxis.min) {
              var r = t,
                  n = t;
              a.globals.series.forEach(function (i, a) {
                null !== t && (r = Math.min(i[e], r), n = Math.max(i[e], n));
              }), n > c && null !== n && (c = n), r < h && null !== r && (h = r);
            }
          })), void 0 === h && void 0 === c && (h = d, c = g), (c *= c < 0 ? .9 : 1.1) < 0 && c < g && (c = g), (h *= h < 0 ? 1.1 : .9) < 0 && h > d && (h = d), e.length > 1 ? (e[l].min = void 0 === t.min ? h : t.min, e[l].max = void 0 === t.max ? c : t.max) : (e[0].min = void 0 === t.min ? h : t.min, e[0].max = void 0 === t.max ? c : t.max);
        });
      }), e;
    }
  }]), t;
}(),
    U = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.scales = new j(i);
  }

  return a(t, [{
    key: "init",
    value: function value() {
      this.setYRange(), this.setXRange(), this.setZRange();
    }
  }, {
    key: "getMinYMaxY",
    value: function value(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE,
          a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
          s = this.w.config,
          r = this.w.globals,
          n = -Number.MAX_VALUE,
          o = Number.MIN_VALUE;
      null === a && (a = t + 1);
      var l = r.series,
          h = l,
          c = l;
      "candlestick" === s.chart.type ? (h = r.seriesCandleL, c = r.seriesCandleH) : "boxPlot" === s.chart.type ? (h = r.seriesCandleO, c = r.seriesCandleC) : r.isRangeData && (h = r.seriesRangeStart, c = r.seriesRangeEnd);

      for (var d = t; d < a; d++) {
        r.dataPoints = Math.max(r.dataPoints, l[d].length);

        for (var g = 0; g < r.series[d].length; g++) {
          var u = l[d][g];
          null !== u && f.isNumber(u) ? (void 0 !== c[d][g] && (n = Math.max(n, c[d][g])), void 0 !== h[d][g] && (e = Math.min(e, h[d][g]), i = Math.max(i, h[d][g])), "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || (void 0 !== r.seriesCandleC[d][g] && (n = Math.max(n, r.seriesCandleO[d][g]), n = Math.max(n, r.seriesCandleH[d][g]), n = Math.max(n, r.seriesCandleL[d][g]), n = Math.max(n, r.seriesCandleC[d][g]), "boxPlot" === this.w.config.chart.type && (n = Math.max(n, r.seriesCandleM[d][g]))), !s.series[d].type || "candlestick" === s.series[d].type && "boxPlot" === s.series[d].type || (n = Math.max(n, r.series[d][g]), e = Math.min(e, r.series[d][g])), i = n), f.isFloat(u) && (u = f.noExponents(u), r.yValueDecimal = Math.max(r.yValueDecimal, u.toString().split(".")[1].length)), o > h[d][g] && h[d][g] < 0 && (o = h[d][g])) : r.hasNullValues = !0;
        }
      }

      return "rangeBar" === s.chart.type && r.seriesRangeStart.length && r.isBarHorizontal && "datetime" === s.xaxis.type && (o = e), "bar" === s.chart.type && (o < 0 && n < 0 && (n = 0), o === Number.MIN_VALUE && (o = 0)), {
        minY: o,
        maxY: n,
        lowestY: e,
        highestY: i
      };
    }
  }, {
    key: "setYRange",
    value: function value() {
      var t = this.w.globals,
          e = this.w.config;
      t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
      var i = Number.MAX_VALUE;
      if (t.isMultipleYAxis) for (var a = 0; a < t.series.length; a++) {
        var s = this.getMinYMaxY(a, i, null, a + 1);
        t.minYArr.push(s.minY), t.maxYArr.push(s.maxY), i = s.lowestY;
      }
      var r = this.getMinYMaxY(0, i, null, t.series.length);

      if (t.minY = r.minY, t.maxY = r.maxY, i = r.lowestY, e.chart.stacked && this._setStackedMinMax(), ("line" === e.chart.type || "area" === e.chart.type || "candlestick" === e.chart.type || "boxPlot" === e.chart.type || "rangeBar" === e.chart.type && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) {
        var n = t.maxY - i;
        (i >= 0 && i <= 10 || void 0 !== e.yaxis[0].min || void 0 !== e.yaxis[0].max) && (n = 0), t.minY = i - 5 * n / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * n / 100;
      }

      if (e.yaxis.forEach(function (e, i) {
        void 0 !== e.max && ("number" == typeof e.max ? t.maxYArr[i] = e.max : "function" == typeof e.max && (t.maxYArr[i] = e.max(t.isMultipleYAxis ? t.maxYArr[i] : t.maxY)), t.maxY = t.maxYArr[i]), void 0 !== e.min && ("number" == typeof e.min ? t.minYArr[i] = e.min : "function" == typeof e.min && (t.minYArr[i] = e.min(t.isMultipleYAxis ? t.minYArr[i] === Number.MIN_VALUE ? 0 : t.minYArr[i] : t.minY)), t.minY = t.minYArr[i]);
      }), t.isBarHorizontal) {
        ["min", "max"].forEach(function (i) {
          void 0 !== e.xaxis[i] && "number" == typeof e.xaxis[i] && ("min" === i ? t.minY = e.xaxis[i] : t.maxY = e.xaxis[i]);
        });
      }

      return t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach(function (e, i) {
        t.minYArr[i] = e.niceMin, t.maxYArr[i] = e.niceMax;
      })) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), {
        minY: t.minY,
        maxY: t.maxY,
        minYArr: t.minYArr,
        maxYArr: t.maxYArr,
        yAxisScale: t.yAxisScale
      };
    }
  }, {
    key: "setXRange",
    value: function value() {
      var t = this.w.globals,
          e = this.w.config,
          i = "numeric" === e.xaxis.type || "datetime" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;

      if (t.isXNumeric && function () {
        for (var e = 0; e < t.series.length; e++) {
          if (t.labels[e]) for (var i = 0; i < t.labels[e].length; i++) {
            null !== t.labels[e][i] && f.isNumber(t.labels[e][i]) && (t.maxX = Math.max(t.maxX, t.labels[e][i]), t.initialMaxX = Math.max(t.maxX, t.labels[e][i]), t.minX = Math.min(t.minX, t.labels[e][i]), t.initialMinX = Math.min(t.minX, t.labels[e][i]));
          }
        }
      }(), t.noLabelsProvided && 0 === e.xaxis.categories.length && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
        var a;
        if (void 0 === e.xaxis.tickAmount ? (a = Math.round(t.svgWidth / 150), "numeric" === e.xaxis.type && t.dataPoints < 30 && (a = t.dataPoints - 1), a > t.dataPoints && 0 !== t.dataPoints && (a = t.dataPoints - 1)) : "dataPoints" === e.xaxis.tickAmount ? (t.series.length > 1 && (a = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (a = t.maxX - t.minX - 1)) : a = e.xaxis.tickAmount, t.xTickAmount = a, void 0 !== e.xaxis.max && "number" == typeof e.xaxis.max && (t.maxX = e.xaxis.max), void 0 !== e.xaxis.min && "number" == typeof e.xaxis.min && (t.minX = e.xaxis.min), void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE) {
          if (e.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
            for (var s = [], r = t.minX - 1; r < t.maxX; r++) {
              s.push(r + 1);
            }

            t.xAxisScale = {
              result: s,
              niceMin: s[0],
              niceMax: s[s.length - 1]
            };
          } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
        } else t.xAxisScale = this.scales.linearScale(1, a, a), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, a - 1), t.seriesX = t.labels.slice());
        i && (t.labels = t.xAxisScale.result.slice());
      }

      return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
        minX: t.minX,
        maxX: t.maxX
      };
    }
  }, {
    key: "setZRange",
    value: function value() {
      var t = this.w.globals;
      if (t.isDataXYZ) for (var e = 0; e < t.series.length; e++) {
        if (void 0 !== t.seriesZ[e]) for (var i = 0; i < t.seriesZ[e].length; i++) {
          null !== t.seriesZ[e][i] && f.isNumber(t.seriesZ[e][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[e][i]), t.minZ = Math.min(t.minZ, t.seriesZ[e][i]));
        }
      }
    }
  }, {
    key: "_handleSingleDataPoint",
    value: function value() {
      var t = this.w.globals,
          e = this.w.config;

      if (t.minX === t.maxX) {
        var i = new Y(this.ctx);

        if ("datetime" === e.xaxis.type) {
          var a = i.getDate(t.minX);
          a.setUTCDate(a.getDate() - 2), t.minX = new Date(a).getTime();
          var s = i.getDate(t.maxX);
          s.setUTCDate(s.getDate() + 2), t.maxX = new Date(s).getTime();
        } else ("numeric" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX);
      }
    }
  }, {
    key: "_getMinXDiff",
    value: function value() {
      var t = this.w.globals;
      t.isXNumeric && t.seriesX.forEach(function (e, i) {
        1 === e.length && e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
        var a = e.slice();
        a.sort(function (t, e) {
          return t - e;
        }), a.forEach(function (e, i) {
          if (i > 0) {
            var s = e - a[i - 1];
            s > 0 && (t.minXDiff = Math.min(s, t.minXDiff));
          }
        }), 1 === t.dataPoints && t.minXDiff === Number.MAX_VALUE && (t.minXDiff = .5);
      });
    }
  }, {
    key: "_setStackedMinMax",
    value: function value() {
      var t = this.w.globals,
          e = [],
          i = [];
      if (t.series.length) for (var a = 0; a < t.series[t.maxValsInArrayIndex].length; a++) {
        for (var s = 0, r = 0, n = 0; n < t.series.length; n++) {
          null !== t.series[n][a] && f.isNumber(t.series[n][a]) && (t.series[n][a] > 0 ? s = s + parseFloat(t.series[n][a]) + 1e-4 : r += parseFloat(t.series[n][a])), n === t.series.length - 1 && (e.push(s), i.push(r));
        }
      }

      for (var o = 0; o < e.length; o++) {
        t.maxY = Math.max(t.maxY, e[o]), t.minY = Math.min(t.minY, i[o]);
      }
    }
  }]), t;
}(),
    q = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
    var a = this.w;
    this.xaxisFontSize = a.config.xaxis.labels.style.fontSize, this.axisFontFamily = a.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = a.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === a.config.chart.type && a.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === a.config.xaxis.position && (this.xAxisoffX = a.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new B(i);
  }

  return a(t, [{
    key: "drawYaxis",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = new b(this.ctx),
          s = i.config.yaxis[t].labels.style,
          r = s.fontSize,
          n = s.fontFamily,
          o = s.fontWeight,
          l = a.group({
        "class": "apexcharts-yaxis",
        rel: t,
        transform: "translate(" + i.globals.translateYAxisX[t] + ", 0)"
      });
      if (this.axesUtils.isYAxisHidden(t)) return l;
      var h = a.group({
        "class": "apexcharts-yaxis-texts-g"
      });
      l.add(h);
      var c = i.globals.yAxisScale[t].result.length - 1,
          d = i.globals.gridHeight / c,
          g = i.globals.translateY,
          u = i.globals.yLabelFormatters[t],
          f = i.globals.yAxisScale[t].result.slice();
      f = this.axesUtils.checkForReversedLabels(t, f);
      var p = "";
      if (i.config.yaxis[t].labels.show) for (var x = function x(l) {
        var x = f[l];
        x = u(x, l);
        var b = i.config.yaxis[t].labels.padding;
        i.config.yaxis[t].opposite && 0 !== i.config.yaxis.length && (b *= -1);
        var m = e.axesUtils.getYAxisForeColor(s.colors, t),
            v = a.drawText({
          x: b,
          y: g + c / 10 + i.config.yaxis[t].labels.offsetY + 1,
          text: x,
          textAnchor: i.config.yaxis[t].opposite ? "start" : "end",
          fontSize: r,
          fontFamily: n,
          fontWeight: o,
          foreColor: Array.isArray(m) ? m[l] : m,
          isPlainText: !1,
          cssClass: "apexcharts-yaxis-label " + s.cssClass
        });

        if (l === c && (p = v), h.add(v), 0 !== i.config.yaxis[t].labels.rotate) {
          var y = a.rotateAroundCenter(p.node),
              w = a.rotateAroundCenter(v.node);
          v.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[t].labels.rotate, " ").concat(y.x, " ").concat(w.y, ")"));
        }

        g += d;
      }, m = c; m >= 0; m--) {
        x(m);
      }

      if (void 0 !== i.config.yaxis[t].title.text) {
        var v = a.group({
          "class": "apexcharts-yaxis-title"
        }),
            y = 0;
        i.config.yaxis[t].opposite && (y = i.globals.translateYAxisX[t]);
        var w = a.drawText({
          x: y,
          y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[t].title.offsetY,
          text: i.config.yaxis[t].title.text,
          textAnchor: "end",
          foreColor: i.config.yaxis[t].title.style.color,
          fontSize: i.config.yaxis[t].title.style.fontSize,
          fontWeight: i.config.yaxis[t].title.style.fontWeight,
          fontFamily: i.config.yaxis[t].title.style.fontFamily,
          cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[t].title.style.cssClass
        });
        v.add(w), l.add(v);
      }

      var k = i.config.yaxis[t].axisBorder,
          A = 31 + k.offsetX;

      if (i.config.yaxis[t].opposite && (A = -31 - k.offsetX), k.show) {
        var S = a.drawLine(A, i.globals.translateY + k.offsetY - 2, A, i.globals.gridHeight + i.globals.translateY + k.offsetY + 2, k.color, 0, k.width);
        l.add(S);
      }

      return i.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(A, c, k, i.config.yaxis[t].axisTicks, t, d, l), l;
    }
  }, {
    key: "drawYaxisInversed",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx),
          a = i.group({
        "class": "apexcharts-xaxis apexcharts-yaxis-inversed"
      }),
          s = i.group({
        "class": "apexcharts-xaxis-texts-g",
        transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
      });
      a.add(s);
      var r = e.globals.yAxisScale[t].result.length - 1,
          n = e.globals.gridWidth / r + .1,
          o = n + e.config.xaxis.labels.offsetX,
          l = e.globals.xLabelFormatter,
          h = e.globals.yAxisScale[t].result.slice(),
          c = e.globals.timescaleLabels;
      c.length > 0 && (this.xaxisLabels = c.slice(), r = (h = c.slice()).length), h = this.axesUtils.checkForReversedLabels(t, h);
      var d = c.length;
      if (e.config.xaxis.labels.show) for (var g = d ? 0 : r; d ? g < d : g >= 0; d ? g++ : g--) {
        var u = h[g];
        u = l(u, g);
        var f = e.globals.gridWidth + e.globals.padHorizontal - (o - n + e.config.xaxis.labels.offsetX);

        if (c.length) {
          var p = this.axesUtils.getLabel(h, c, f, g, this.drawnLabels, this.xaxisFontSize);
          f = p.x, u = p.text, this.drawnLabels.push(p.text), 0 === g && e.globals.skipFirstTimelinelabel && (u = ""), g === h.length - 1 && e.globals.skipLastTimelinelabel && (u = "");
        }

        var x = i.drawText({
          x: f,
          y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30 - ("top" === e.config.xaxis.position ? e.globals.xAxisHeight + e.config.xaxis.axisTicks.height - 2 : 0),
          text: u,
          textAnchor: "middle",
          foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors,
          fontSize: this.xaxisFontSize,
          fontFamily: this.xaxisFontFamily,
          fontWeight: e.config.xaxis.labels.style.fontWeight,
          isPlainText: !1,
          cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass
        });
        s.add(x), x.tspan(u);
        var m = document.createElementNS(e.globals.SVGNS, "title");
        m.textContent = u, x.node.appendChild(m), o += n;
      }
      return this.inversedYAxisTitleText(a), this.inversedYAxisBorder(a), a;
    }
  }, {
    key: "inversedYAxisBorder",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx),
          a = e.config.xaxis.axisBorder;

      if (a.show) {
        var s = 0;
        "bar" === e.config.chart.type && e.globals.isXNumeric && (s -= 15);
        var r = i.drawLine(e.globals.padHorizontal + s + a.offsetX, this.xAxisoffX, e.globals.gridWidth, this.xAxisoffX, a.color, 0, a.height);
        t.add(r);
      }
    }
  }, {
    key: "inversedYAxisTitleText",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx);

      if (void 0 !== e.config.xaxis.title.text) {
        var a = i.group({
          "class": "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
        }),
            s = i.drawText({
          x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
          y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e.config.xaxis.title.style.fontSize) + e.config.xaxis.title.offsetY + 20,
          text: e.config.xaxis.title.text,
          textAnchor: "middle",
          fontSize: e.config.xaxis.title.style.fontSize,
          fontFamily: e.config.xaxis.title.style.fontFamily,
          fontWeight: e.config.xaxis.title.style.fontWeight,
          foreColor: e.config.xaxis.title.style.color,
          cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
        });
        a.add(s), t.add(a);
      }
    }
  }, {
    key: "yAxisTitleRotate",
    value: function value(t, e) {
      var i = this.w,
          a = new b(this.ctx),
          s = {
        width: 0,
        height: 0
      },
          r = {
        width: 0,
        height: 0
      },
          n = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
      null !== n && (s = n.getBoundingClientRect());
      var o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));

      if (null !== o && (r = o.getBoundingClientRect()), null !== o) {
        var l = this.xPaddingForYAxisTitle(t, s, r, e);
        o.setAttribute("x", l.xPos - (e ? 10 : 0));
      }

      if (null !== o) {
        var h = a.rotateAroundCenter(o);
        o.setAttribute("transform", "rotate(".concat(e ? -1 * i.config.yaxis[t].title.rotate : i.config.yaxis[t].title.rotate, " ").concat(h.x, " ").concat(h.y, ")"));
      }
    }
  }, {
    key: "xPaddingForYAxisTitle",
    value: function value(t, e, i, a) {
      var s = this.w,
          r = 0,
          n = 0,
          o = 10;
      return void 0 === s.config.yaxis[t].title.text || t < 0 ? {
        xPos: n,
        padd: 0
      } : (a ? (n = e.width + s.config.yaxis[t].title.offsetX + i.width / 2 + o / 2, 0 === (r += 1) && (n -= o / 2)) : (n = -1 * e.width + s.config.yaxis[t].title.offsetX + o / 2 + i.width / 2, s.globals.isBarHorizontal && (o = 25, n = -1 * e.width - s.config.yaxis[t].title.offsetX - o)), {
        xPos: n,
        padd: o
      });
    }
  }, {
    key: "setYAxisXPosition",
    value: function value(t, e) {
      var i = this.w,
          a = 0,
          s = 0,
          r = 18,
          n = 1;
      i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map(function (o, l) {
        var h = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || 0 === t[l].width,
            c = t[l].width + e[l].width;
        o.opposite ? i.globals.isBarHorizontal ? (s = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[l] = s - o.labels.offsetX) : (s = i.globals.gridWidth + i.globals.translateX + n, h || (n = n + c + 20), i.globals.translateYAxisX[l] = s - o.labels.offsetX + 20) : (a = i.globals.translateX - r, h || (r = r + c + 20), i.globals.translateYAxisX[l] = a + o.labels.offsetX);
      });
    }
  }, {
    key: "setYAxisTextAlignments",
    value: function value() {
      var t = this.w,
          e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
      (e = f.listToArray(e)).forEach(function (e, i) {
        var a = t.config.yaxis[i];

        if (a && void 0 !== a.labels.align) {
          var s = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")),
              r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"));
          r = f.listToArray(r);
          var n = s.getBoundingClientRect();
          "left" === a.labels.align ? (r.forEach(function (t, e) {
            t.setAttribute("text-anchor", "start");
          }), a.opposite || s.setAttribute("transform", "translate(-".concat(n.width, ", 0)"))) : "center" === a.labels.align ? (r.forEach(function (t, e) {
            t.setAttribute("text-anchor", "middle");
          }), s.setAttribute("transform", "translate(".concat(n.width / 2 * (a.opposite ? 1 : -1), ", 0)"))) : "right" === a.labels.align && (r.forEach(function (t, e) {
            t.setAttribute("text-anchor", "end");
          }), a.opposite && s.setAttribute("transform", "translate(".concat(n.width, ", 0)")));
        }
      });
    }
  }]), t;
}(),
    Z = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.documentEvent = f.bind(this.documentEvent, this);
  }

  return a(t, [{
    key: "addEventListener",
    value: function value(t, e) {
      var i = this.w;
      i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(e) : i.globals.events[t] = [e];
    }
  }, {
    key: "removeEventListener",
    value: function value(t, e) {
      var i = this.w;

      if (i.globals.events.hasOwnProperty(t)) {
        var a = i.globals.events[t].indexOf(e);
        -1 !== a && i.globals.events[t].splice(a, 1);
      }
    }
  }, {
    key: "fireEvent",
    value: function value(t, e) {
      var i = this.w;

      if (i.globals.events.hasOwnProperty(t)) {
        e && e.length || (e = []);

        for (var a = i.globals.events[t], s = a.length, r = 0; r < s; r++) {
          a[r].apply(null, e);
        }
      }
    }
  }, {
    key: "setupEventHandlers",
    value: function value() {
      var t = this,
          e = this.w,
          i = this.ctx,
          a = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
      this.ctx.eventList.forEach(function (t) {
        a.addEventListener(t, function (t) {
          var a = Object.assign({}, e, {
            seriesIndex: e.globals.capturedSeriesIndex,
            dataPointIndex: e.globals.capturedDataPointIndex
          });
          "mousemove" === t.type || "touchmove" === t.type ? "function" == typeof e.config.chart.events.mouseMove && e.config.chart.events.mouseMove(t, i, a) : ("mouseup" === t.type && 1 === t.which || "touchend" === t.type) && ("function" == typeof e.config.chart.events.click && e.config.chart.events.click(t, i, a), i.ctx.events.fireEvent("click", [t, i, a]));
        }, {
          capture: !1,
          passive: !0
        });
      }), this.ctx.eventList.forEach(function (i) {
        e.globals.dom.baseEl.addEventListener(i, t.documentEvent, {
          passive: !0
        });
      }), this.ctx.core.setupBrushHandler();
    }
  }, {
    key: "documentEvent",
    value: function value(t) {
      var e = this.w,
          i = t.target.className;

      if ("click" === t.type) {
        var a = e.globals.dom.baseEl.querySelector(".apexcharts-menu");
        a && a.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i && a.classList.remove("apexcharts-menu-open");
      }

      e.globals.clientX = "touchmove" === t.type ? t.touches[0].clientX : t.clientX, e.globals.clientY = "touchmove" === t.type ? t.touches[0].clientY : t.clientY;
    }
  }]), t;
}(),
    $ = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "setCurrentLocaleValues",
    value: function value(t) {
      var e = this.w.config.chart.locales;
      window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales));
      var i = e.filter(function (e) {
        return e.name === t;
      })[0];
      if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
      var a = f.extend(A, i);
      this.w.globals.locale = a.options;
    }
  }]), t;
}(),
    J = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "drawAxis",
    value: function value(t, e) {
      var i,
          a,
          s = this.w.globals,
          r = this.w.config,
          n = new G(this.ctx),
          o = new q(this.ctx);
      s.axisCharts && "radar" !== t && (s.isBarHorizontal ? (a = o.drawYaxisInversed(0), i = n.drawXaxisInversed(0), s.dom.elGraphical.add(i), s.dom.elGraphical.add(a)) : (i = n.drawXaxis(), s.dom.elGraphical.add(i), r.yaxis.map(function (t, e) {
        -1 === s.ignoreYAxisIndexes.indexOf(e) && (a = o.drawYaxis(e), s.dom.Paper.add(a));
      })));
    }
  }]), t;
}(),
    Q = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "drawXCrosshairs",
    value: function value() {
      var t = this.w,
          e = new b(this.ctx),
          i = new x(this.ctx),
          a = t.config.xaxis.crosshairs.fill.gradient,
          s = t.config.xaxis.crosshairs.dropShadow,
          r = t.config.xaxis.crosshairs.fill.type,
          n = a.colorFrom,
          o = a.colorTo,
          l = a.opacityFrom,
          h = a.opacityTo,
          c = a.stops,
          d = s.enabled,
          g = s.left,
          u = s.top,
          p = s.blur,
          m = s.color,
          v = s.opacity,
          y = t.config.xaxis.crosshairs.fill.color;

      if (t.config.xaxis.crosshairs.show) {
        "gradient" === r && (y = e.drawGradient("vertical", n, o, l, h, null, c, null));
        var w = e.drawRect();
        1 === t.config.xaxis.crosshairs.width && (w = e.drawLine()), w.attr({
          "class": "apexcharts-xcrosshairs",
          x: 0,
          y: 0,
          y2: t.globals.gridHeight,
          width: f.isNumber(t.config.xaxis.crosshairs.width) ? t.config.xaxis.crosshairs.width : 0,
          height: t.globals.gridHeight,
          fill: y,
          filter: "none",
          "fill-opacity": t.config.xaxis.crosshairs.opacity,
          stroke: t.config.xaxis.crosshairs.stroke.color,
          "stroke-width": t.config.xaxis.crosshairs.stroke.width,
          "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray
        }), d && (w = i.dropShadow(w, {
          left: g,
          top: u,
          blur: p,
          color: m,
          opacity: v
        })), t.globals.dom.elGraphical.add(w);
      }
    }
  }, {
    key: "drawYCrosshairs",
    value: function value() {
      var t = this.w,
          e = new b(this.ctx),
          i = t.config.yaxis[0].crosshairs,
          a = t.globals.barPadForNumericAxis;

      if (t.config.yaxis[0].crosshairs.show) {
        var s = e.drawLine(-a, 0, t.globals.gridWidth + a, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
        s.attr({
          "class": "apexcharts-ycrosshairs"
        }), t.globals.dom.elGraphical.add(s);
      }

      var r = e.drawLine(-a, 0, t.globals.gridWidth + a, 0, i.stroke.color, 0, 0);
      r.attr({
        "class": "apexcharts-ycrosshairs-hidden"
      }), t.globals.dom.elGraphical.add(r);
    }
  }]), t;
}(),
    K = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "checkResponsiveConfig",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = i.config;

      if (0 !== a.responsive.length) {
        var s = a.responsive.slice();
        s.sort(function (t, e) {
          return t.breakpoint > e.breakpoint ? 1 : e.breakpoint > t.breakpoint ? -1 : 0;
        }).reverse();

        var r = new D({}),
            n = function n() {
          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
              a = s[0].breakpoint,
              n = window.innerWidth > 0 ? window.innerWidth : screen.width;

          if (n > a) {
            var o = y.extendArrayProps(r, i.globals.initialConfig, i);
            t = f.extend(o, t), t = f.extend(i.config, t), e.overrideResponsiveOptions(t);
          } else for (var l = 0; l < s.length; l++) {
            n < s[l].breakpoint && (t = y.extendArrayProps(r, s[l].options, i), t = f.extend(i.config, t), e.overrideResponsiveOptions(t));
          }
        };

        if (t) {
          var o = y.extendArrayProps(r, t, i);
          o = f.extend(i.config, o), n(o = f.extend(o, t));
        } else n({});
      }
    }
  }, {
    key: "overrideResponsiveOptions",
    value: function value(t) {
      var e = new D(t).init({
        responsiveOverride: !0
      });
      this.w.config = e;
    }
  }]), t;
}(),
    tt = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.colors = [], this.w = i.w;
    var a = this.w;
    this.isColorFn = !1, this.isHeatmapDistributed = "treemap" === a.config.chart.type && a.config.plotOptions.treemap.distributed || "heatmap" === a.config.chart.type && a.config.plotOptions.heatmap.distributed, this.isBarDistributed = a.config.plotOptions.bar.distributed && ("bar" === a.config.chart.type || "rangeBar" === a.config.chart.type);
  }

  return a(t, [{
    key: "init",
    value: function value() {
      this.setDefaultColors();
    }
  }, {
    key: "setDefaultColors",
    value: function value() {
      var t = this,
          e = this.w,
          i = new f();

      if (e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode)), void 0 === e.config.colors ? e.globals.colors = this.predefined() : (e.globals.colors = e.config.colors, Array.isArray(e.config.colors) && e.config.colors.length > 0 && "function" == typeof e.config.colors[0] && (e.globals.colors = e.config.series.map(function (i, a) {
        var s = e.config.colors[a];
        return s || (s = e.config.colors[0]), "function" == typeof s ? (t.isColorFn = !0, s({
          value: e.globals.axisCharts ? e.globals.series[a][0] ? e.globals.series[a][0] : 0 : e.globals.series[a],
          seriesIndex: a,
          dataPointIndex: a,
          w: e
        })) : s;
      }))), e.globals.seriesColors.map(function (t, i) {
        t && (e.globals.colors[i] = t);
      }), e.config.theme.monochrome.enabled) {
        var a = [],
            s = e.globals.series.length;
        (this.isBarDistributed || this.isHeatmapDistributed) && (s = e.globals.series[0].length * e.globals.series.length);

        for (var r = e.config.theme.monochrome.color, n = 1 / (s / e.config.theme.monochrome.shadeIntensity), o = e.config.theme.monochrome.shadeTo, l = 0, h = 0; h < s; h++) {
          var c = void 0;
          "dark" === o ? (c = i.shadeColor(-1 * l, r), l += n) : (c = i.shadeColor(l, r), l += n), a.push(c);
        }

        e.globals.colors = a.slice();
      }

      var d = e.globals.colors.slice();
      this.pushExtraColors(e.globals.colors);
      ["fill", "stroke"].forEach(function (i) {
        void 0 === e.config[i].colors ? e.globals[i].colors = t.isColorFn ? e.config.colors : d : e.globals[i].colors = e.config[i].colors.slice(), t.pushExtraColors(e.globals[i].colors);
      }), void 0 === e.config.dataLabels.style.colors ? e.globals.dataLabels.style.colors = d : e.globals.dataLabels.style.colors = e.config.dataLabels.style.colors.slice(), this.pushExtraColors(e.globals.dataLabels.style.colors, 50), void 0 === e.config.plotOptions.radar.polygons.fill.colors ? e.globals.radarPolygons.fill.colors = ["dark" === e.config.theme.mode ? "#424242" : "none"] : e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20), void 0 === e.config.markers.colors ? e.globals.markers.colors = d : e.globals.markers.colors = e.config.markers.colors.slice(), this.pushExtraColors(e.globals.markers.colors);
    }
  }, {
    key: "pushExtraColors",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
          a = this.w,
          s = e || a.globals.series.length;
      if (null === i && (i = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a.config.chart.type && a.config.plotOptions.heatmap.colorScale.inverse), i && a.globals.series.length && (s = a.globals.series[a.globals.maxValsInArrayIndex].length * a.globals.series.length), t.length < s) for (var r = s - t.length, n = 0; n < r; n++) {
        t.push(t[n]);
      }
    }
  }, {
    key: "updateThemeOptions",
    value: function value(t) {
      t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
      var e = t.theme.mode || "light",
          i = t.theme.palette ? t.theme.palette : "dark" === e ? "palette4" : "palette1",
          a = t.chart.foreColor ? t.chart.foreColor : "dark" === e ? "#f6f7f8" : "#373d3f";
      return t.tooltip.theme = e, t.chart.foreColor = a, t.theme.palette = i, t;
    }
  }, {
    key: "predefined",
    value: function value() {
      switch (this.w.config.theme.palette) {
        case "palette1":
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
          break;

        case "palette2":
          this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
          break;

        case "palette3":
          this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
          break;

        case "palette4":
          this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
          break;

        case "palette5":
          this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
          break;

        case "palette6":
          this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
          break;

        case "palette7":
          this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
          break;

        case "palette8":
          this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
          break;

        case "palette9":
          this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
          break;

        case "palette10":
          this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
          break;

        default:
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
      }

      return this.colors;
    }
  }]), t;
}(),
    et = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "draw",
    value: function value() {
      this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
    }
  }, {
    key: "drawTitleSubtitle",
    value: function value(t) {
      var e = this.w,
          i = "title" === t ? e.config.title : e.config.subtitle,
          a = e.globals.svgWidth / 2,
          s = i.offsetY,
          r = "middle";

      if ("left" === i.align ? (a = 10, r = "start") : "right" === i.align && (a = e.globals.svgWidth - 10, r = "end"), a += i.offsetX, s = s + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text) {
        var n = new b(this.ctx).drawText({
          x: a,
          y: s,
          text: i.text,
          textAnchor: r,
          fontSize: i.style.fontSize,
          fontFamily: i.style.fontFamily,
          fontWeight: i.style.fontWeight,
          foreColor: i.style.color,
          opacity: 1
        });
        n.node.setAttribute("class", "apexcharts-".concat(t, "-text")), e.globals.dom.Paper.add(n);
      }
    }
  }]), t;
}(),
    it = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.dCtx = i;
  }

  return a(t, [{
    key: "getTitleSubtitleCoords",
    value: function value(t) {
      var e = this.w,
          i = 0,
          a = 0,
          s = "title" === t ? e.config.title.floating : e.config.subtitle.floating,
          r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));

      if (null !== r && !s) {
        var n = r.getBoundingClientRect();
        i = n.width, a = e.globals.axisCharts ? n.height + 5 : n.height;
      }

      return {
        width: i,
        height: a
      };
    }
  }, {
    key: "getLegendsRect",
    value: function value() {
      var t = this.w,
          e = t.globals.dom.baseEl.querySelector(".apexcharts-legend");
      t.config.legend.height || "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || (e.style.maxHeight = t.globals.svgHeight / 2 + "px");
      var i = Object.assign({}, f.getBoundingClientRect(e));
      return null !== e && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = {
        x: i.x,
        y: i.y,
        height: i.height,
        width: 0 === i.height ? 0 : i.width
      } : this.dCtx.lgRect = {
        x: 0,
        y: 0,
        height: 0,
        width: 0
      }, "left" !== t.config.legend.position && "right" !== t.config.legend.position || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect;
    }
  }, {
    key: "getLargestStringFromMultiArr",
    value: function value(t, e) {
      var i = t;

      if (this.w.globals.isMultiLineX) {
        var a = e.map(function (t, e) {
          return Array.isArray(t) ? t.length : 1;
        }),
            s = Math.max.apply(Math, g(a));
        i = e[a.indexOf(s)];
      }

      return i;
    }
  }]), t;
}(),
    at = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.dCtx = i;
  }

  return a(t, [{
    key: "getxAxisLabelsCoords",
    value: function value() {
      var t,
          e = this.w,
          i = e.globals.labels.slice();

      if (e.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = e.globals.categoryLabels), e.globals.timescaleLabels.length > 0) {
        var a = this.getxAxisTimeScaleLabelsCoords();
        t = {
          width: a.width,
          height: a.height
        }, e.globals.rotateXLabels = !1;
      } else {
        this.dCtx.lgWidthForSideLegends = "left" !== e.config.legend.position && "right" !== e.config.legend.position || e.config.legend.floating ? 0 : this.dCtx.lgRect.width;
        var s = e.globals.xLabelFormatter,
            r = f.getLargestStringFromArr(i),
            n = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, i);
        e.globals.isBarHorizontal && (n = r = e.globals.yAxisScale[0].result.reduce(function (t, e) {
          return t.length > e.length ? t : e;
        }, 0));
        var o = new W(this.dCtx.ctx),
            l = r;
        r = o.xLabelFormat(s, r, l, {
          i: void 0,
          dateFormatter: new Y(this.dCtx.ctx).formatDate,
          w: e
        }), n = o.xLabelFormat(s, n, l, {
          i: void 0,
          dateFormatter: new Y(this.dCtx.ctx).formatDate,
          w: e
        }), (e.config.xaxis.convertedCatToNumeric && void 0 === r || "" === String(r).trim()) && (n = r = "1");
        var h = new b(this.dCtx.ctx),
            c = h.getTextRects(r, e.config.xaxis.labels.style.fontSize),
            d = c;

        if (r !== n && (d = h.getTextRects(n, e.config.xaxis.labels.style.fontSize)), (t = {
          width: c.width >= d.width ? c.width : d.width,
          height: c.height >= d.height ? c.height : d.height
        }).width * i.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e.config.xaxis.labels.rotate || e.config.xaxis.labels.rotateAlways) {
          if (!e.globals.isBarHorizontal) {
            e.globals.rotateXLabels = !0;

            var g = function g(t) {
              return h.getTextRects(t, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, "rotate(".concat(e.config.xaxis.labels.rotate, " 0 0)"), !1);
            };

            c = g(r), r !== n && (d = g(n)), t.height = (c.height > d.height ? c.height : d.height) / 1.5, t.width = c.width > d.width ? c.width : d.width;
          }
        } else e.globals.rotateXLabels = !1;
      }

      return e.config.xaxis.labels.show || (t = {
        width: 0,
        height: 0
      }), {
        width: t.width,
        height: t.height
      };
    }
  }, {
    key: "getxAxisTitleCoords",
    value: function value() {
      var t = this.w,
          e = 0,
          i = 0;

      if (void 0 !== t.config.xaxis.title.text) {
        var a = new b(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
        e = a.width, i = a.height;
      }

      return {
        width: e,
        height: i
      };
    }
  }, {
    key: "getxAxisTimeScaleLabelsCoords",
    value: function value() {
      var t,
          e = this.w;
      this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice();
      var i = this.dCtx.timescaleLabels.map(function (t) {
        return t.value;
      }),
          a = i.reduce(function (t, e) {
        return void 0 === t ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t.length > e.length ? t : e;
      }, 0);
      return 1.05 * (t = new b(this.dCtx.ctx).getTextRects(a, e.config.xaxis.labels.style.fontSize)).width * i.length > e.globals.gridWidth && 0 !== e.config.xaxis.labels.rotate && (e.globals.overlappingXLabels = !0), t;
    }
  }, {
    key: "additionalPaddingXLabels",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = i.globals,
          s = i.config,
          r = s.xaxis.type,
          n = t.width;
      a.skipLastTimelinelabel = !1, a.skipFirstTimelinelabel = !1;

      var o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal,
          l = function l(t, s) {
        (function (t) {
          return -1 !== a.collapsedSeriesIndices.indexOf(t);
        })(s) || function (t) {
          if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) {
            var s = e.dCtx.timescaleLabels[0],
                o = e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position + n / 1.75 - e.dCtx.yAxisWidthRight,
                l = s.position - n / 1.75 + e.dCtx.yAxisWidthLeft;
            o > a.svgWidth - a.translateX && (a.skipLastTimelinelabel = !0), l < 0 && (a.skipFirstTimelinelabel = !0);
          } else "datetime" === r ? e.dCtx.gridPad.right < n && !a.rotateXLabels && (a.skipLastTimelinelabel = !0) : "datetime" !== r && e.dCtx.gridPad.right < n / 2 - e.dCtx.yAxisWidthRight && !a.rotateXLabels && ("between" !== i.config.xaxis.tickPlacement || i.globals.isBarHorizontal) && (e.dCtx.xPadRight = n / 2 + 1);
        }();
      };

      s.yaxis.forEach(function (t, i) {
        o ? (e.dCtx.gridPad.left < n && (e.dCtx.xPadLeft = n / 2 + 1), e.dCtx.xPadRight = n / 2 + 1) : l(0, i);
      });
    }
  }]), t;
}(),
    st = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.dCtx = i;
  }

  return a(t, [{
    key: "getyAxisLabelsCoords",
    value: function value() {
      var t = this,
          e = this.w,
          i = [],
          a = 10,
          s = new B(this.dCtx.ctx);
      return e.config.yaxis.map(function (r, n) {
        var o = e.globals.yAxisScale[n];

        if (!s.isYAxisHidden(n) && r.labels.show && o.result.length) {
          var l = e.globals.yLabelFormatters[n],
              h = String(o.niceMin).length > String(o.niceMax).length ? o.niceMin : o.niceMax,
              c = l(h, {
            seriesIndex: n,
            dataPointIndex: -1,
            w: e
          }),
              d = c;

          if (void 0 !== c && 0 !== c.length || (c = h), e.globals.isBarHorizontal) {
            a = 0;
            var g = e.globals.labels.slice();
            c = l(c = f.getLargestStringFromArr(g), {
              seriesIndex: n,
              dataPointIndex: -1,
              w: e
            }), d = t.dCtx.dimHelpers.getLargestStringFromMultiArr(c, g);
          }

          var u = new b(t.dCtx.ctx),
              p = "rotate(".concat(r.labels.rotate, " 0 0)"),
              x = u.getTextRects(c, r.labels.style.fontSize, r.labels.style.fontFamily, p, !1),
              m = x;
          c !== d && (m = u.getTextRects(d, r.labels.style.fontSize, r.labels.style.fontFamily, p, !1)), i.push({
            width: (m.width > x.width ? m.width : x.width) + a,
            height: m.height > x.height ? m.height : x.height
          });
        } else i.push({
          width: 0,
          height: 0
        });
      }), i;
    }
  }, {
    key: "getyAxisTitleCoords",
    value: function value() {
      var t = this,
          e = this.w,
          i = [];
      return e.config.yaxis.map(function (e, a) {
        if (e.show && void 0 !== e.title.text) {
          var s = new b(t.dCtx.ctx),
              r = "rotate(".concat(e.title.rotate, " 0 0)"),
              n = s.getTextRects(e.title.text, e.title.style.fontSize, e.title.style.fontFamily, r, !1);
          i.push({
            width: n.width,
            height: n.height
          });
        } else i.push({
          width: 0,
          height: 0
        });
      }), i;
    }
  }, {
    key: "getTotalYAxisWidth",
    value: function value() {
      var t = this.w,
          e = 0,
          i = 0,
          a = 0,
          s = t.globals.yAxisScale.length > 1 ? 10 : 0,
          r = new B(this.dCtx.ctx),
          n = function n(_n, o) {
        var l = t.config.yaxis[o].floating,
            h = 0;
        _n.width > 0 && !l ? (h = _n.width + s, function (e) {
          return t.globals.ignoreYAxisIndexes.indexOf(e) > -1;
        }(o) && (h = h - _n.width - s)) : h = l || r.isYAxisHidden(o) ? 0 : 5, t.config.yaxis[o].opposite ? a += h : i += h, e += h;
      };

      return t.globals.yLabelsCoords.map(function (t, e) {
        n(t, e);
      }), t.globals.yTitleCoords.map(function (t, e) {
        n(t, e);
      }), t.globals.isBarHorizontal && !t.config.yaxis[0].floating && (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = a, e;
    }
  }]), t;
}(),
    rt = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.dCtx = i;
  }

  return a(t, [{
    key: "gridPadForColumnsInNumericAxis",
    value: function value(t) {
      var e = this.w;
      if (e.globals.noData || e.globals.allSeriesCollapsed) return 0;

      var i = function i(t) {
        return "bar" === t || "rangeBar" === t || "candlestick" === t || "boxPlot" === t;
      },
          a = e.config.chart.type,
          s = 0,
          r = i(a) ? e.config.series.length : 1;

      if (e.globals.comboBarCount > 0 && (r = e.globals.comboBarCount), e.globals.collapsedSeries.forEach(function (t) {
        i(t.type) && (r -= 1);
      }), e.config.chart.stacked && (r = 1), (i(a) || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && r > 0) {
        var n,
            o,
            l = Math.abs(e.globals.initialMaxX - e.globals.initialMinX);
        l <= 3 && (l = e.globals.dataPoints), n = l / t, e.globals.minXDiff && e.globals.minXDiff / n > 0 && (o = e.globals.minXDiff / n), o > t / 2 && (o /= 2), (s = o / r * parseInt(e.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s = 1), s = s / (r > 1 ? 1 : 1.5) + 5, e.globals.barPadForNumericAxis = s;
      }

      return s;
    }
  }, {
    key: "gridPadFortitleSubtitle",
    value: function value() {
      var t = this,
          e = this.w,
          i = e.globals,
          a = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10;
      ["title", "subtitle"].forEach(function (i) {
        void 0 !== e.config[i].text ? a += e.config[i].margin : a += t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5;
      }), !e.config.legend.show || "bottom" !== e.config.legend.position || e.config.legend.floating || e.globals.axisCharts || (a += 10);
      var s = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),
          r = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
      i.gridHeight = i.gridHeight - s.height - r.height - a, i.translateY = i.translateY + s.height + r.height + a;
    }
  }, {
    key: "setGridXPosForDualYAxis",
    value: function value(t, e) {
      var i = this.w,
          a = new B(this.dCtx.ctx);
      i.config.yaxis.map(function (s, r) {
        -1 !== i.globals.ignoreYAxisIndexes.indexOf(r) || s.floating || a.isYAxisHidden(r) || (s.opposite && (i.globals.translateX = i.globals.translateX - (e[r].width + t[r].width) - parseInt(i.config.yaxis[r].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
      });
    }
  }]), t;
}(),
    nt = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new it(this), this.dimYAxis = new st(this), this.dimXAxis = new at(this), this.dimGrid = new rt(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }

  return a(t, [{
    key: "plotCoords",
    value: function value() {
      var t = this.w.globals;
      this.lgRect = this.dimHelpers.getLegendsRect(), t.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), t.gridHeight = t.gridHeight - this.gridPad.top - this.gridPad.bottom, t.gridWidth = t.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
      var e = this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth);
      t.gridWidth = t.gridWidth - 2 * e, t.translateX = t.translateX + this.gridPad.left + this.xPadLeft + (e > 0 ? e + 4 : 0), t.translateY = t.translateY + this.gridPad.top;
    }
  }, {
    key: "setDimensionsForAxisCharts",
    value: function value() {
      var t = this,
          e = this.w,
          i = e.globals,
          a = this.dimYAxis.getyAxisLabelsCoords(),
          s = this.dimYAxis.getyAxisTitleCoords();
      e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map(function (t, i) {
        e.globals.yLabelsCoords.push({
          width: a[i].width,
          index: i
        }), e.globals.yTitleCoords.push({
          width: s[i].width,
          index: i
        });
      }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
      var r = this.dimXAxis.getxAxisLabelsCoords(),
          n = this.dimXAxis.getxAxisTitleCoords();
      this.conditionalChecksForAxisCoords(r, n), i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + e.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + e.config.xaxis.labels.offsetX;
      var o = this.yAxisWidth,
          l = this.xAxisHeight;
      i.xAxisLabelsHeight = this.xAxisHeight - n.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
      var h = 10;
      ("radar" === e.config.chart.type || this.isSparkline) && (o = 0, l = i.goldenPadding), this.isSparkline && (this.lgRect = {
        height: 0,
        width: 0
      }), (this.isSparkline || "treemap" === e.config.chart.type) && (o = 0, l = 0, h = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r);

      var c = function c() {
        i.translateX = o, i.gridHeight = i.svgHeight - t.lgRect.height - l - (t.isSparkline || "treemap" === e.config.chart.type ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - o;
      };

      switch ("top" === e.config.xaxis.position && (h = i.xAxisHeight - e.config.xaxis.axisTicks.height - 5), e.config.legend.position) {
        case "bottom":
          i.translateY = h, c();
          break;

        case "top":
          i.translateY = this.lgRect.height + h, c();
          break;

        case "left":
          i.translateY = h, i.translateX = this.lgRect.width + o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o;
          break;

        case "right":
          i.translateY = h, i.translateX = o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o - 5;
          break;

        default:
          throw new Error("Legend position not supported");
      }

      this.dimGrid.setGridXPosForDualYAxis(s, a), new q(this.ctx).setYAxisXPosition(a, s);
    }
  }, {
    key: "setDimensionsForNonAxisCharts",
    value: function value() {
      var t = this.w,
          e = t.globals,
          i = t.config,
          a = 0;
      t.config.legend.show && !t.config.legend.floating && (a = 20);
      var s = "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar",
          r = i.plotOptions[s].offsetY,
          n = i.plotOptions[s].offsetX;
      if (!i.legend.show || i.legend.floating) return e.gridHeight = e.svgHeight - i.grid.padding.left + i.grid.padding.right, e.gridWidth = e.gridHeight, e.translateY = r, void (e.translateX = n + (e.svgWidth - e.gridWidth) / 2);

      switch (i.legend.position) {
        case "bottom":
          e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = r - 10, e.translateX = n + (e.svgWidth - e.gridWidth) / 2;
          break;

        case "top":
          e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = this.lgRect.height + r + 10, e.translateX = n + (e.svgWidth - e.gridWidth) / 2;
          break;

        case "left":
          e.gridWidth = e.svgWidth - this.lgRect.width - a, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = n + this.lgRect.width + a;
          break;

        case "right":
          e.gridWidth = e.svgWidth - this.lgRect.width - a - 5, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = n + 10;
          break;

        default:
          throw new Error("Legend position not supported");
      }
    }
  }, {
    key: "conditionalChecksForAxisCoords",
    value: function value(t, e) {
      var i = this.w;
      this.xAxisHeight = (t.height + e.height) * (i.globals.isMultiLineX ? 1.2 : i.globals.LINE_HEIGHT_RATIO) + (i.globals.rotateXLabels ? 22 : 10), this.xAxisWidth = t.width, this.xAxisHeight - e.height > i.config.xaxis.labels.maxHeight && (this.xAxisHeight = i.config.xaxis.labels.maxHeight), i.config.xaxis.labels.minHeight && this.xAxisHeight < i.config.xaxis.labels.minHeight && (this.xAxisHeight = i.config.xaxis.labels.minHeight), i.config.xaxis.floating && (this.xAxisHeight = 0);
      var a = 0,
          s = 0;
      i.config.yaxis.forEach(function (t) {
        a += t.labels.minWidth, s += t.labels.maxWidth;
      }), this.yAxisWidth < a && (this.yAxisWidth = a), this.yAxisWidth > s && (this.yAxisWidth = s);
    }
  }]), t;
}(),
    ot = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.lgCtx = i;
  }

  return a(t, [{
    key: "getLegendStyles",
    value: function value() {
      var t = document.createElement("style");
      t.setAttribute("type", "text/css");
      var e = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-left, .apexcharts-legend.position-top.apexcharts-align-left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-center, .apexcharts-legend.position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-right, .apexcharts-legend.position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
      return t.appendChild(e), t;
    }
  }, {
    key: "getLegendBBox",
    value: function value() {
      var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),
          e = t.width;
      return {
        clwh: t.height,
        clww: e
      };
    }
  }, {
    key: "appendToForeignObject",
    value: function value() {
      var t = this.w.globals;
      t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject");
      var e = t.dom.elLegendForeign;
      e.setAttribute("x", 0), e.setAttribute("y", 0), e.setAttribute("width", t.svgWidth), e.setAttribute("height", t.svgHeight), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e.appendChild(t.dom.elLegendWrap), e.appendChild(this.getLegendStyles()), t.dom.Paper.node.insertBefore(e, t.dom.elGraphical.node);
    }
  }, {
    key: "toggleDataSeries",
    value: function value(t, e) {
      var i = this,
          a = this.w;

      if (a.globals.axisCharts || "radialBar" === a.config.chart.type) {
        a.globals.resized = !0;
        var s = null,
            r = null;
        if (a.globals.risingSeries = [], a.globals.axisCharts ? (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), r = parseInt(s.getAttribute("data:realIndex"), 10)) : (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), r = parseInt(s.getAttribute("rel"), 10) - 1), e) [{
          cs: a.globals.collapsedSeries,
          csi: a.globals.collapsedSeriesIndices
        }, {
          cs: a.globals.ancillaryCollapsedSeries,
          csi: a.globals.ancillaryCollapsedSeriesIndices
        }].forEach(function (t) {
          i.riseCollapsedSeries(t.cs, t.csi, r);
        });else this.hideSeries({
          seriesEl: s,
          realIndex: r
        });
      } else {
        var n = a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")),
            o = a.config.chart.type;

        if ("pie" === o || "polarArea" === o || "donut" === o) {
          var l = a.config.plotOptions.pie.donut.labels;
          new b(this.lgCtx.ctx).pathMouseDown(n.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(n.members[0].node, l);
        }

        n.fire("click");
      }
    }
  }, {
    key: "hideSeries",
    value: function value(t) {
      var e = t.seriesEl,
          i = t.realIndex,
          a = this.w,
          s = f.clone(a.config.series);

      if (a.globals.axisCharts) {
        var r = !1;

        if (a.config.yaxis[i] && a.config.yaxis[i].show && a.config.yaxis[i].showAlways && (r = !0, a.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (a.globals.ancillaryCollapsedSeries.push({
          index: i,
          data: s[i].data.slice(),
          type: e.parentNode.className.baseVal.split("-")[1]
        }), a.globals.ancillaryCollapsedSeriesIndices.push(i))), !r) {
          a.globals.collapsedSeries.push({
            index: i,
            data: s[i].data.slice(),
            type: e.parentNode.className.baseVal.split("-")[1]
          }), a.globals.collapsedSeriesIndices.push(i);
          var n = a.globals.risingSeries.indexOf(i);
          a.globals.risingSeries.splice(n, 1);
        }
      } else a.globals.collapsedSeries.push({
        index: i,
        data: s[i]
      }), a.globals.collapsedSeriesIndices.push(i);

      for (var o = e.childNodes, l = 0; l < o.length; l++) {
        o[l].classList.contains("apexcharts-series-markers-wrap") && (o[l].classList.contains("apexcharts-hide") ? o[l].classList.remove("apexcharts-hide") : o[l].classList.add("apexcharts-hide"));
      }

      a.globals.allSeriesCollapsed = a.globals.collapsedSeries.length === a.config.series.length, s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled);
    }
  }, {
    key: "riseCollapsedSeries",
    value: function value(t, e, i) {
      var a = this.w,
          s = f.clone(a.config.series);

      if (t.length > 0) {
        for (var r = 0; r < t.length; r++) {
          t[r].index === i && (a.globals.axisCharts ? (s[i].data = t[r].data.slice(), t.splice(r, 1), e.splice(r, 1), a.globals.risingSeries.push(i)) : (s[i] = t[r].data, t.splice(r, 1), e.splice(r, 1), a.globals.risingSeries.push(i)));
        }

        s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled);
      }
    }
  }, {
    key: "_getSeriesBasedOnCollapsedState",
    value: function value(t) {
      var e = this.w;
      return e.globals.axisCharts ? t.forEach(function (i, a) {
        e.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a].data = []);
      }) : t.forEach(function (i, a) {
        e.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a] = 0);
      }), t;
    }
  }]), t;
}(),
    lt = function () {
  function t(i, a) {
    e(this, t), this.ctx = i, this.w = i.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new ot(this);
  }

  return a(t, [{
    key: "init",
    value: function value() {
      var t = this.w,
          e = t.globals,
          i = t.config;

      if ((i.legend.showForSingleSeries && 1 === e.series.length || this.isBarsDistributed || e.series.length > 1 || !e.axisCharts) && i.legend.show) {
        for (; e.dom.elLegendWrap.firstChild;) {
          e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);
        }

        this.drawLegends(), f.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical();
      }
    }
  }, {
    key: "drawLegends",
    value: function value() {
      var t = this,
          e = this.w,
          i = e.config.legend.fontFamily,
          a = e.globals.seriesNames,
          s = e.globals.colors.slice();

      if ("heatmap" === e.config.chart.type) {
        var r = e.config.plotOptions.heatmap.colorScale.ranges;
        a = r.map(function (t) {
          return t.name ? t.name : t.from + " - " + t.to;
        }), s = r.map(function (t) {
          return t.color;
        });
      } else this.isBarsDistributed && (a = e.globals.labels.slice());

      for (var n = e.globals.legendFormatter, o = e.config.legend.inverseOrder, l = o ? a.length - 1 : 0; o ? l >= 0 : l <= a.length - 1; o ? l-- : l++) {
        var h = n(a[l], {
          seriesIndex: l,
          w: e
        }),
            c = !1,
            d = !1;
        if (e.globals.collapsedSeries.length > 0) for (var g = 0; g < e.globals.collapsedSeries.length; g++) {
          e.globals.collapsedSeries[g].index === l && (c = !0);
        }
        if (e.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var u = 0; u < e.globals.ancillaryCollapsedSeriesIndices.length; u++) {
          e.globals.ancillaryCollapsedSeriesIndices[u] === l && (d = !0);
        }
        var p = document.createElement("span");
        p.classList.add("apexcharts-legend-marker");
        var x = e.config.legend.markers.offsetX,
            m = e.config.legend.markers.offsetY,
            v = e.config.legend.markers.height,
            w = e.config.legend.markers.width,
            k = e.config.legend.markers.strokeWidth,
            A = e.config.legend.markers.strokeColor,
            S = e.config.legend.markers.radius,
            C = p.style;
        C.background = s[l], C.color = s[l], C.setProperty("background", s[l], "important"), e.config.legend.markers.fillColors && e.config.legend.markers.fillColors[l] && (C.background = e.config.legend.markers.fillColors[l]), void 0 !== e.globals.seriesColors[l] && (C.background = e.globals.seriesColors[l], C.color = e.globals.seriesColors[l]), C.height = Array.isArray(v) ? parseFloat(v[l]) + "px" : parseFloat(v) + "px", C.width = Array.isArray(w) ? parseFloat(w[l]) + "px" : parseFloat(w) + "px", C.left = Array.isArray(x) ? x[l] : x, C.top = Array.isArray(m) ? m[l] : m, C.borderWidth = Array.isArray(k) ? k[l] : k, C.borderColor = Array.isArray(A) ? A[l] : A, C.borderRadius = Array.isArray(S) ? parseFloat(S[l]) + "px" : parseFloat(S) + "px", e.config.legend.markers.customHTML && (Array.isArray(e.config.legend.markers.customHTML) ? e.config.legend.markers.customHTML[l] && (p.innerHTML = e.config.legend.markers.customHTML[l]()) : p.innerHTML = e.config.legend.markers.customHTML()), b.setAttrs(p, {
          rel: l + 1,
          "data:collapsed": c || d
        }), (c || d) && p.classList.add("apexcharts-inactive-legend");
        var L = document.createElement("div"),
            P = document.createElement("span");
        P.classList.add("apexcharts-legend-text"), P.innerHTML = Array.isArray(h) ? h.join(" ") : h;
        var T = e.config.legend.labels.useSeriesColors ? e.globals.colors[l] : e.config.legend.labels.colors;
        T || (T = e.config.chart.foreColor), P.style.color = T, P.style.fontSize = parseFloat(e.config.legend.fontSize) + "px", P.style.fontWeight = e.config.legend.fontWeight, P.style.fontFamily = i || e.config.chart.fontFamily, b.setAttrs(P, {
          rel: l + 1,
          i: l,
          "data:default-text": encodeURIComponent(h),
          "data:collapsed": c || d
        }), L.appendChild(p), L.appendChild(P);
        var z = new y(this.ctx);
        if (!e.config.legend.showForZeroSeries) 0 === z.getSeriesTotalByIndex(l) && z.seriesHaveSameValues(l) && !z.isSeriesNull(l) && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && L.classList.add("apexcharts-hidden-zero-series");
        e.config.legend.showForNullSeries || z.isSeriesNull(l) && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && L.classList.add("apexcharts-hidden-null-series"), e.globals.dom.elLegendWrap.appendChild(L), e.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e.config.legend.horizontalAlign)), e.globals.dom.elLegendWrap.classList.add("position-" + e.config.legend.position), L.classList.add("apexcharts-legend-series"), L.style.margin = "".concat(e.config.legend.itemMargin.vertical, "px ").concat(e.config.legend.itemMargin.horizontal, "px"), e.globals.dom.elLegendWrap.style.width = e.config.legend.width ? e.config.legend.width + "px" : "", e.globals.dom.elLegendWrap.style.height = e.config.legend.height ? e.config.legend.height + "px" : "", b.setAttrs(L, {
          rel: l + 1,
          seriesName: f.escapeString(a[l]),
          "data:collapsed": c || d
        }), (c || d) && L.classList.add("apexcharts-inactive-legend"), e.config.legend.onItemClick.toggleDataSeries || L.classList.add("apexcharts-no-click");
      }

      e.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), e.config.legend.onItemHover.highlightDataSeries && (e.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), e.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0));
    }
  }, {
    key: "setLegendWrapXY",
    value: function value(t, e) {
      var i = this.w,
          a = i.globals.dom.baseEl.querySelector(".apexcharts-legend"),
          s = a.getBoundingClientRect(),
          r = 0,
          n = 0;
      if ("bottom" === i.config.legend.position) n += i.globals.svgHeight - s.height / 2;else if ("top" === i.config.legend.position) {
        var o = new nt(this.ctx),
            l = o.dimHelpers.getTitleSubtitleCoords("title").height,
            h = o.dimHelpers.getTitleSubtitleCoords("subtitle").height;
        n = n + (l > 0 ? l - 10 : 0) + (h > 0 ? h - 10 : 0);
      }
      a.style.position = "absolute", r = r + t + i.config.legend.offsetX, n = n + e + i.config.legend.offsetY, a.style.left = r + "px", a.style.top = n + "px", "bottom" === i.config.legend.position ? (a.style.top = "auto", a.style.bottom = 5 - i.config.legend.offsetY + "px") : "right" === i.config.legend.position && (a.style.left = "auto", a.style.right = 25 + i.config.legend.offsetX + "px");
      ["width", "height"].forEach(function (t) {
        a.style[t] && (a.style[t] = parseInt(i.config.legend[t], 10) + "px");
      });
    }
  }, {
    key: "legendAlignHorizontal",
    value: function value() {
      var t = this.w;
      t.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
      var e = this.legendHelpers.getLegendBBox(),
          i = new nt(this.ctx),
          a = i.dimHelpers.getTitleSubtitleCoords("title"),
          s = i.dimHelpers.getTitleSubtitleCoords("subtitle"),
          r = 0;
      "bottom" === t.config.legend.position ? r = -e.clwh / 1.8 : "top" === t.config.legend.position && (r = a.height + s.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, r);
    }
  }, {
    key: "legendAlignVertical",
    value: function value() {
      var t = this.w,
          e = this.legendHelpers.getLegendBBox(),
          i = 0;
      "left" === t.config.legend.position && (i = 20), "right" === t.config.legend.position && (i = t.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(i, 20);
    }
  }, {
    key: "onLegendHovered",
    value: function value(t) {
      var e = this.w,
          i = t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");

      if ("heatmap" === e.config.chart.type || this.isBarsDistributed) {
        if (i) {
          var a = parseInt(t.target.getAttribute("rel"), 10) - 1;
          this.ctx.events.fireEvent("legendHover", [this.ctx, a, this.w]), new M(this.ctx).highlightRangeInSeries(t, t.target);
        }
      } else !t.target.classList.contains("apexcharts-inactive-legend") && i && new M(this.ctx).toggleSeriesOnHover(t, t.target);
    }
  }, {
    key: "onLegendClick",
    value: function value(t) {
      var e = this.w;

      if (t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker")) {
        var i = parseInt(t.target.getAttribute("rel"), 10) - 1,
            a = "true" === t.target.getAttribute("data:collapsed"),
            s = this.w.config.chart.events.legendClick;
        "function" == typeof s && s(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
        var r = this.w.config.legend.markers.onClick;
        "function" == typeof r && t.target.classList.contains("apexcharts-legend-marker") && (r(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), "treemap" !== e.config.chart.type && "heatmap" !== e.config.chart.type && !this.isBarsDistributed && e.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, a);
      }
    }
  }]), t;
}(),
    ht = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
    var a = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = a.globals.minX, this.maxX = a.globals.maxX;
  }

  return a(t, [{
    key: "createToolbar",
    value: function value() {
      var t = this,
          e = this.w,
          i = function i() {
        return document.createElement("div");
      },
          a = i();

      if (a.setAttribute("class", "apexcharts-toolbar"), a.style.top = e.config.chart.toolbar.offsetY + "px", a.style.right = 3 - e.config.chart.toolbar.offsetX + "px", e.globals.dom.elWrap.appendChild(a), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = e.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var s = 0; s < this.t.customIcons.length; s++) {
        this.elCustomIcons.push(i());
      }

      var r = [],
          n = function n(i, a, s) {
        var n = i.toLowerCase();
        t.t[n] && e.config.chart.zoom.enabled && r.push({
          el: a,
          icon: "string" == typeof t.t[n] ? t.t[n] : s,
          title: t.localeValues[i],
          "class": "apexcharts-".concat(n, "-icon")
        });
      };

      n("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), n("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');

      var o = function o(i) {
        t.t[i] && e.config.chart[i].enabled && r.push({
          el: "zoom" === i ? t.elZoom : t.elSelection,
          icon: "string" == typeof t.t[i] ? t.t[i] : "zoom" === i ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
          title: t.localeValues["zoom" === i ? "selectionZoom" : "selection"],
          "class": e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i, "-icon")
        });
      };

      o("zoom"), o("selection"), this.t.pan && e.config.chart.zoom.enabled && r.push({
        el: this.elPan,
        icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
        title: this.localeValues.pan,
        "class": e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
      }), n("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r.push({
        el: this.elMenuIcon,
        icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
        title: this.localeValues.menu,
        "class": "apexcharts-menu-icon"
      });

      for (var l = 0; l < this.elCustomIcons.length; l++) {
        r.push({
          el: this.elCustomIcons[l],
          icon: this.t.customIcons[l].icon,
          title: this.t.customIcons[l].title,
          index: this.t.customIcons[l].index,
          "class": "apexcharts-toolbar-custom-icon " + this.t.customIcons[l]["class"]
        });
      }

      r.forEach(function (t, e) {
        t.index && f.moveIndexInArray(r, e, t.index);
      });

      for (var h = 0; h < r.length; h++) {
        b.setAttrs(r[h].el, {
          "class": r[h]["class"],
          title: r[h].title
        }), r[h].el.innerHTML = r[h].icon, a.appendChild(r[h].el);
      }

      this._createHamburgerMenu(a), e.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
    }
  }, {
    key: "_createHamburgerMenu",
    value: function value(t) {
      this.elMenuItems = [], t.appendChild(this.elMenu), b.setAttrs(this.elMenu, {
        "class": "apexcharts-menu"
      });
      var e = [{
        name: "exportSVG",
        title: this.localeValues.exportToSVG
      }, {
        name: "exportPNG",
        title: this.localeValues.exportToPNG
      }, {
        name: "exportCSV",
        title: this.localeValues.exportToCSV
      }];
      this.w.globals.allSeriesHasEqualX || e.splice(2, 1);

      for (var i = 0; i < e.length; i++) {
        this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = e[i].title, b.setAttrs(this.elMenuItems[i], {
          "class": "apexcharts-menu-item ".concat(e[i].name),
          title: e[i].title
        }), this.elMenu.appendChild(this.elMenuItems[i]);
      }
    }
  }, {
    key: "addToolbarEventListeners",
    value: function value() {
      var t = this;
      this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function (e) {
        e.classList.contains("exportSVG") ? e.addEventListener("click", t.handleDownload.bind(t, "svg")) : e.classList.contains("exportPNG") ? e.addEventListener("click", t.handleDownload.bind(t, "png")) : e.classList.contains("exportCSV") && e.addEventListener("click", t.handleDownload.bind(t, "csv"));
      });

      for (var e = 0; e < this.t.customIcons.length; e++) {
        this.elCustomIcons[e].addEventListener("click", this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w));
      }
    }
  }, {
    key: "toggleZoomSelection",
    value: function value(t) {
      this.ctx.getSyncedCharts().forEach(function (e) {
        e.ctx.toolbar.toggleOtherControls();
        var i = "selection" === t ? e.ctx.toolbar.elSelection : e.ctx.toolbar.elZoom,
            a = "selection" === t ? "selectionEnabled" : "zoomEnabled";
        e.w.globals[a] = !e.w.globals[a], i.classList.contains(e.ctx.toolbar.selectedClass) ? i.classList.remove(e.ctx.toolbar.selectedClass) : i.classList.add(e.ctx.toolbar.selectedClass);
      });
    }
  }, {
    key: "getToolbarIconsReference",
    value: function value() {
      var t = this.w;
      this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
    }
  }, {
    key: "enableZoomPanFromToolbar",
    value: function value(t) {
      this.toggleOtherControls(), "pan" === t ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
      var e = "pan" === t ? this.elPan : this.elZoom,
          i = "pan" === t ? this.elZoom : this.elPan;
      e && e.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
    }
  }, {
    key: "togglePanning",
    value: function value() {
      this.ctx.getSyncedCharts().forEach(function (t) {
        t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass);
      });
    }
  }, {
    key: "toggleOtherControls",
    value: function value() {
      var t = this,
          e = this.w;
      e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function (e) {
        e && e.classList.remove(t.selectedClass);
      });
    }
  }, {
    key: "handleZoomIn",
    value: function value() {
      var t = this.w;
      t.globals.isTimelineBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY);

      var e = (this.minX + this.maxX) / 2,
          i = (this.minX + e) / 2,
          a = (this.maxX + e) / 2,
          s = this._getNewMinXMaxX(i, a);

      t.globals.disableZoomIn || this.zoomUpdateOptions(s.minX, s.maxX);
    }
  }, {
    key: "handleZoomOut",
    value: function value() {
      var t = this.w;

      if (t.globals.isTimelineBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY), !("datetime" === t.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
        var e = (this.minX + this.maxX) / 2,
            i = this.minX - (e - this.minX),
            a = this.maxX - (e - this.maxX),
            s = this._getNewMinXMaxX(i, a);

        t.globals.disableZoomOut || this.zoomUpdateOptions(s.minX, s.maxX);
      }
    }
  }, {
    key: "_getNewMinXMaxX",
    value: function value(t, e) {
      var i = this.w.config.xaxis.convertedCatToNumeric;
      return {
        minX: i ? Math.floor(t) : t,
        maxX: i ? Math.floor(e) : e
      };
    }
  }, {
    key: "zoomUpdateOptions",
    value: function value(t, e) {
      var i = this.w;

      if (void 0 !== t || void 0 !== e) {
        if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, e = i.globals.dataPoints), e - t < 2))) {
          var a = {
            min: t,
            max: e
          },
              s = this.getBeforeZoomRange(a);
          s && (a = s.xaxis);
          var r = {
            xaxis: a
          },
              n = f.clone(i.globals.initialConfig.yaxis);
          if (i.config.chart.zoom.autoScaleYaxis) n = new j(this.ctx).autoScaleY(this.ctx, n, {
            xaxis: a
          });
          i.config.chart.group || (r.yaxis = n), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a, n);
        }
      } else this.handleZoomReset();
    }
  }, {
    key: "zoomCallback",
    value: function value(t, e) {
      "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
        xaxis: t,
        yaxis: e
      });
    }
  }, {
    key: "getBeforeZoomRange",
    value: function value(t, e) {
      var i = null;
      return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, {
        xaxis: t,
        yaxis: e
      })), i;
    }
  }, {
    key: "toggleMenu",
    value: function value() {
      var t = this;
      window.setTimeout(function () {
        t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open");
      }, 0);
    }
  }, {
    key: "handleDownload",
    value: function value(t) {
      var e = this.w,
          i = new V(this.ctx);

      switch (t) {
        case "svg":
          i.exportToSVG(this.ctx);
          break;

        case "png":
          i.exportToPng(this.ctx);
          break;

        case "csv":
          i.exportToCSV({
            series: e.config.series,
            columnDelimiter: e.config.chart.toolbar["export"].csv.columnDelimiter
          });
      }
    }
  }, {
    key: "handleZoomReset",
    value: function value(t) {
      this.ctx.getSyncedCharts().forEach(function (t) {
        var e = t.w;

        if (e.globals.lastXAxis.min = void 0, e.globals.lastXAxis.max = void 0, t.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e.config.chart.events.beforeResetZoom) {
          var i = e.config.chart.events.beforeResetZoom(t, e);
          i && t.updateHelpers.revertDefaultAxisMinMax(i);
        }

        "function" == typeof e.config.chart.events.zoomed && t.ctx.toolbar.zoomCallback({
          min: e.config.xaxis.min,
          max: e.config.xaxis.max
        }), e.globals.zoomed = !1;
        var a = t.ctx.series.emptyCollapsedSeries(f.clone(e.globals.initialSeries));

        t.updateHelpers._updateSeries(a, e.config.chart.animations.dynamicAnimation.enabled);
      });
    }
  }, {
    key: "destroy",
    value: function value() {
      this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
    }
  }]), t;
}(),
    ct = function (t) {
  o(s, ht);
  var i = d(s);

  function s(t) {
    var a;
    return e(this, s), (a = i.call(this, t)).ctx = t, a.w = t.w, a.dragged = !1, a.graphics = new b(a.ctx), a.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], a.clientX = 0, a.clientY = 0, a.startX = 0, a.endX = 0, a.dragX = 0, a.startY = 0, a.endY = 0, a.dragY = 0, a.moveDirection = "none", a;
  }

  return a(s, [{
    key: "init",
    value: function value(t) {
      var e = this,
          i = t.xyRatios,
          a = this.w,
          s = this;
      this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a.globals.dom.elGraphical.add(this.zoomRect), a.globals.dom.elGraphical.add(this.selectionRect), "x" === a.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
        minX: 0,
        minY: 0,
        maxX: a.globals.gridWidth,
        maxY: a.globals.gridHeight
      }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
        minX: 0,
        maxX: a.globals.gridWidth
      }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a.globals.dom.baseEl.querySelector("".concat(a.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function (t) {
        e.hoverArea.addEventListener(t, s.svgMouseEvents.bind(s, i), {
          capture: !1,
          passive: !0
        });
      });
    }
  }, {
    key: "destroy",
    value: function value() {
      this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
    }
  }, {
    key: "svgMouseEvents",
    value: function value(t, e) {
      var i = this.w,
          a = this,
          s = this.ctx.toolbar,
          r = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type,
          n = i.config.chart.toolbar.autoSelected;
      e.shiftKey ? (this.shiftWasPressed = !0, s.enableZoomPanFromToolbar("pan" === n ? "zoom" : "pan")) : this.shiftWasPressed && (s.enableZoomPanFromToolbar(n), this.shiftWasPressed = !1);
      var o = e.target.classList;

      if (!(o.contains("apexcharts-selection-rect") || o.contains("apexcharts-legend-marker") || o.contains("apexcharts-legend-text") || e.target.parentNode.classList.contains("apexcharts-toolbar"))) {
        if (a.clientX = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientX : "touchend" === e.type ? e.changedTouches[0].clientX : e.clientX, a.clientY = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientY : "touchend" === e.type ? e.changedTouches[0].clientY : e.clientY, "mousedown" === e.type && 1 === e.which) {
          var l = a.gridRect.getBoundingClientRect();
          a.startX = a.clientX - l.left, a.startY = a.clientY - l.top, a.dragged = !1, a.w.globals.mousedown = !0;
        }

        if (("mousemove" === e.type && 1 === e.which || "touchmove" === e.type) && (a.dragged = !0, i.globals.panEnabled ? (i.globals.selection = null, a.w.globals.mousedown && a.panDragging({
          context: a,
          zoomtype: r,
          xyRatios: t
        })) : (a.w.globals.mousedown && i.globals.zoomEnabled || a.w.globals.mousedown && i.globals.selectionEnabled) && (a.selection = a.selectionDrawing({
          context: a,
          zoomtype: r
        }))), "mouseup" === e.type || "touchend" === e.type || "mouseleave" === e.type) {
          var h = a.gridRect.getBoundingClientRect();
          a.w.globals.mousedown && (a.endX = a.clientX - h.left, a.endY = a.clientY - h.top, a.dragX = Math.abs(a.endX - a.startX), a.dragY = Math.abs(a.endY - a.startY), (i.globals.zoomEnabled || i.globals.selectionEnabled) && a.selectionDrawn({
            context: a,
            zoomtype: r
          }), i.globals.panEnabled && i.config.xaxis.convertedCatToNumeric && a.delayedPanScrolled()), i.globals.zoomEnabled && a.hideSelectionRect(this.selectionRect), a.dragged = !1, a.w.globals.mousedown = !1;
        }

        this.makeSelectionRectDraggable();
      }
    }
  }, {
    key: "makeSelectionRectDraggable",
    value: function value() {
      var t = this.w;

      if (this.selectionRect) {
        var e = this.selectionRect.node.getBoundingClientRect();
        e.width > 0 && e.height > 0 && this.slDraggableRect.selectize({
          points: "l, r",
          pointSize: 8,
          pointType: "rect"
        }).resize({
          constraint: {
            minX: 0,
            minY: 0,
            maxX: t.globals.gridWidth,
            maxY: t.globals.gridHeight
          }
        }).on("resizing", this.selectionDragging.bind(this, "resizing"));
      }
    }
  }, {
    key: "preselectedSelection",
    value: function value() {
      var t = this.w,
          e = this.xyRatios;
      if (!t.globals.zoomEnabled) if (void 0 !== t.globals.selection && null !== t.globals.selection) this.drawSelectionRect(t.globals.selection);else if (void 0 !== t.config.chart.selection.xaxis.min && void 0 !== t.config.chart.selection.xaxis.max) {
        var i = (t.config.chart.selection.xaxis.min - t.globals.minX) / e.xRatio,
            a = {
          x: i,
          y: 0,
          width: t.globals.gridWidth - (t.globals.maxX - t.config.chart.selection.xaxis.max) / e.xRatio - i,
          height: t.globals.gridHeight,
          translateX: 0,
          translateY: 0,
          selectionEnabled: !0
        };
        this.drawSelectionRect(a), this.makeSelectionRectDraggable(), "function" == typeof t.config.chart.events.selection && t.config.chart.events.selection(this.ctx, {
          xaxis: {
            min: t.config.chart.selection.xaxis.min,
            max: t.config.chart.selection.xaxis.max
          },
          yaxis: {}
        });
      }
    }
  }, {
    key: "drawSelectionRect",
    value: function value(t) {
      var e = t.x,
          i = t.y,
          a = t.width,
          s = t.height,
          r = t.translateX,
          n = void 0 === r ? 0 : r,
          o = t.translateY,
          l = void 0 === o ? 0 : o,
          h = this.w,
          c = this.zoomRect,
          d = this.selectionRect;

      if (this.dragged || null !== h.globals.selection) {
        var g = {
          transform: "translate(" + n + ", " + l + ")"
        };
        h.globals.zoomEnabled && this.dragged && (a < 0 && (a = 1), c.attr({
          x: e,
          y: i,
          width: a,
          height: s,
          fill: h.config.chart.zoom.zoomedArea.fill.color,
          "fill-opacity": h.config.chart.zoom.zoomedArea.fill.opacity,
          stroke: h.config.chart.zoom.zoomedArea.stroke.color,
          "stroke-width": h.config.chart.zoom.zoomedArea.stroke.width,
          "stroke-opacity": h.config.chart.zoom.zoomedArea.stroke.opacity
        }), b.setAttrs(c.node, g)), h.globals.selectionEnabled && (d.attr({
          x: e,
          y: i,
          width: a > 0 ? a : 0,
          height: s > 0 ? s : 0,
          fill: h.config.chart.selection.fill.color,
          "fill-opacity": h.config.chart.selection.fill.opacity,
          stroke: h.config.chart.selection.stroke.color,
          "stroke-width": h.config.chart.selection.stroke.width,
          "stroke-dasharray": h.config.chart.selection.stroke.dashArray,
          "stroke-opacity": h.config.chart.selection.stroke.opacity
        }), b.setAttrs(d.node, g));
      }
    }
  }, {
    key: "hideSelectionRect",
    value: function value(t) {
      t && t.attr({
        x: 0,
        y: 0,
        width: 0,
        height: 0
      });
    }
  }, {
    key: "selectionDrawing",
    value: function value(t) {
      var e = t.context,
          i = t.zoomtype,
          a = this.w,
          s = e,
          r = this.gridRect.getBoundingClientRect(),
          n = s.startX - 1,
          o = s.startY,
          l = !1,
          h = !1,
          c = s.clientX - r.left - n,
          d = s.clientY - r.top - o,
          g = {};
      return Math.abs(c + n) > a.globals.gridWidth ? c = a.globals.gridWidth - n : s.clientX - r.left < 0 && (c = n), n > s.clientX - r.left && (l = !0, c = Math.abs(c)), o > s.clientY - r.top && (h = !0, d = Math.abs(d)), g = "x" === i ? {
        x: l ? n - c : n,
        y: 0,
        width: c,
        height: a.globals.gridHeight
      } : "y" === i ? {
        x: 0,
        y: h ? o - d : o,
        width: a.globals.gridWidth,
        height: d
      } : {
        x: l ? n - c : n,
        y: h ? o - d : o,
        width: c,
        height: d
      }, s.drawSelectionRect(g), s.selectionDragging("resizing"), g;
    }
  }, {
    key: "selectionDragging",
    value: function value(t, e) {
      var i = this,
          a = this.w,
          s = this.xyRatios,
          r = this.selectionRect,
          n = 0;
      "resizing" === t && (n = 30);

      var o = function o(t) {
        return parseFloat(r.node.getAttribute(t));
      },
          l = {
        x: o("x"),
        y: o("y"),
        width: o("width"),
        height: o("height")
      };

      a.globals.selection = l, "function" == typeof a.config.chart.events.selection && a.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function () {
        var t = i.gridRect.getBoundingClientRect(),
            e = r.node.getBoundingClientRect(),
            n = {
          xaxis: {
            min: a.globals.xAxisScale.niceMin + (e.left - t.left) * s.xRatio,
            max: a.globals.xAxisScale.niceMin + (e.right - t.left) * s.xRatio
          },
          yaxis: {
            min: a.globals.yAxisScale[0].niceMin + (t.bottom - e.bottom) * s.yRatio[0],
            max: a.globals.yAxisScale[0].niceMax - (e.top - t.top) * s.yRatio[0]
          }
        };
        a.config.chart.events.selection(i.ctx, n), a.config.chart.brush.enabled && void 0 !== a.config.chart.events.brushScrolled && a.config.chart.events.brushScrolled(i.ctx, n);
      }, n));
    }
  }, {
    key: "selectionDrawn",
    value: function value(t) {
      var e = t.context,
          i = t.zoomtype,
          a = this.w,
          s = e,
          r = this.xyRatios,
          n = this.ctx.toolbar;

      if (s.startX > s.endX) {
        var o = s.startX;
        s.startX = s.endX, s.endX = o;
      }

      if (s.startY > s.endY) {
        var l = s.startY;
        s.startY = s.endY, s.endY = l;
      }

      var h = void 0,
          c = void 0;
      a.globals.isTimelineBar ? (h = a.globals.yAxisScale[0].niceMin + s.startX * r.invertedYRatio, c = a.globals.yAxisScale[0].niceMin + s.endX * r.invertedYRatio) : (h = a.globals.xAxisScale.niceMin + s.startX * r.xRatio, c = a.globals.xAxisScale.niceMin + s.endX * r.xRatio);
      var d = [],
          g = [];
      if (a.config.yaxis.forEach(function (t, e) {
        d.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * s.startY), g.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * s.endY);
      }), s.dragged && (s.dragX > 10 || s.dragY > 10) && h !== c) if (a.globals.zoomEnabled) {
        var u = f.clone(a.globals.initialConfig.yaxis),
            p = f.clone(a.globals.initialConfig.xaxis);

        if (a.globals.zoomed = !0, a.config.xaxis.convertedCatToNumeric && (h = Math.floor(h), c = Math.floor(c), h < 1 && (h = 1, c = a.globals.dataPoints), c - h < 2 && (c = h + 1)), "xy" !== i && "x" !== i || (p = {
          min: h,
          max: c
        }), "xy" !== i && "y" !== i || u.forEach(function (t, e) {
          u[e].min = g[e], u[e].max = d[e];
        }), a.config.chart.zoom.autoScaleYaxis) {
          var x = new j(s.ctx);
          u = x.autoScaleY(s.ctx, u, {
            xaxis: p
          });
        }

        if (n) {
          var b = n.getBeforeZoomRange(p, u);
          b && (p = b.xaxis ? b.xaxis : p, u = b.yaxis ? b.yaxis : u);
        }

        var m = {
          xaxis: p
        };
        a.config.chart.group || (m.yaxis = u), s.ctx.updateHelpers._updateOptions(m, !1, s.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a.config.chart.events.zoomed && n.zoomCallback(p, u);
      } else if (a.globals.selectionEnabled) {
        var v,
            y = null;
        v = {
          min: h,
          max: c
        }, "xy" !== i && "y" !== i || (y = f.clone(a.config.yaxis)).forEach(function (t, e) {
          y[e].min = g[e], y[e].max = d[e];
        }), a.globals.selection = s.selection, "function" == typeof a.config.chart.events.selection && a.config.chart.events.selection(s.ctx, {
          xaxis: v,
          yaxis: y
        });
      }
    }
  }, {
    key: "panDragging",
    value: function value(t) {
      var e = t.context,
          i = this.w,
          a = e;

      if (void 0 !== i.globals.lastClientPosition.x) {
        var s = i.globals.lastClientPosition.x - a.clientX,
            r = i.globals.lastClientPosition.y - a.clientY;
        Math.abs(s) > Math.abs(r) && s > 0 ? this.moveDirection = "left" : Math.abs(s) > Math.abs(r) && s < 0 ? this.moveDirection = "right" : Math.abs(r) > Math.abs(s) && r > 0 ? this.moveDirection = "up" : Math.abs(r) > Math.abs(s) && r < 0 && (this.moveDirection = "down");
      }

      i.globals.lastClientPosition = {
        x: a.clientX,
        y: a.clientY
      };
      var n = i.globals.isTimelineBar ? i.globals.minY : i.globals.minX,
          o = i.globals.isTimelineBar ? i.globals.maxY : i.globals.maxX;
      i.config.xaxis.convertedCatToNumeric || a.panScrolled(n, o);
    }
  }, {
    key: "delayedPanScrolled",
    value: function value() {
      var t = this.w,
          e = t.globals.minX,
          i = t.globals.maxX,
          a = (t.globals.maxX - t.globals.minX) / 2;
      "left" === this.moveDirection ? (e = t.globals.minX + a, i = t.globals.maxX + a) : "right" === this.moveDirection && (e = t.globals.minX - a, i = t.globals.maxX - a), e = Math.floor(e), i = Math.floor(i), this.updateScrolledChart({
        xaxis: {
          min: e,
          max: i
        }
      }, e, i);
    }
  }, {
    key: "panScrolled",
    value: function value(t, e) {
      var i = this.w,
          a = this.xyRatios,
          s = f.clone(i.globals.initialConfig.yaxis),
          r = a.xRatio,
          n = i.globals.minX,
          o = i.globals.maxX;
      i.globals.isTimelineBar && (r = a.invertedYRatio, n = i.globals.minY, o = i.globals.maxY), "left" === this.moveDirection ? (t = n + i.globals.gridWidth / 15 * r, e = o + i.globals.gridWidth / 15 * r) : "right" === this.moveDirection && (t = n - i.globals.gridWidth / 15 * r, e = o - i.globals.gridWidth / 15 * r), i.globals.isTimelineBar || (t < i.globals.initialMinX || e > i.globals.initialMaxX) && (t = n, e = o);
      var l = {
        min: t,
        max: e
      };
      i.config.chart.zoom.autoScaleYaxis && (s = new j(this.ctx).autoScaleY(this.ctx, s, {
        xaxis: l
      }));
      var h = {
        xaxis: {
          min: t,
          max: e
        }
      };
      i.config.chart.group || (h.yaxis = s), this.updateScrolledChart(h, t, e);
    }
  }, {
    key: "updateScrolledChart",
    value: function value(t, e, i) {
      var a = this.w;
      this.ctx.updateHelpers._updateOptions(t, !1, !1), "function" == typeof a.config.chart.events.scrolled && a.config.chart.events.scrolled(this.ctx, {
        xaxis: {
          min: e,
          max: i
        }
      });
    }
  }]), s;
}(),
    dt = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.ttCtx = i, this.ctx = i.ctx;
  }

  return a(t, [{
    key: "getNearestValues",
    value: function value(t) {
      var e = t.hoverArea,
          i = t.elGrid,
          a = t.clientX,
          s = t.clientY,
          r = this.w,
          n = r.globals.gridWidth,
          o = r.globals.gridHeight,
          l = n / (r.globals.dataPoints - 1),
          h = o / r.globals.dataPoints,
          c = i.getBoundingClientRect(),
          d = this.hasBars();
      !r.globals.comboCharts && !d || r.config.xaxis.convertedCatToNumeric || (l = n / r.globals.dataPoints);
      var g = a - c.left - r.globals.barPadForNumericAxis,
          u = s - c.top;
      g < 0 || u < 0 || g > r.globals.gridWidth || u > r.globals.gridHeight ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan")) : r.globals.zoomEnabled ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom")) : r.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
      var p = Math.round(g / l),
          x = Math.floor(u / h);
      d && !r.config.xaxis.convertedCatToNumeric && (p = Math.ceil(g / l), p -= 1);

      for (var b, m = null, v = null, y = [], w = 0; w < r.globals.seriesXvalues.length; w++) {
        y.push([r.globals.seriesXvalues[w][0] - 1e-6].concat(r.globals.seriesXvalues[w]));
      }

      return y = y.map(function (t) {
        return t.filter(function (t) {
          return t;
        });
      }), b = r.globals.seriesYvalues.map(function (t) {
        return t.filter(function (t) {
          return f.isNumber(t);
        });
      }), r.globals.isXNumeric && (m = (v = this.closestInMultiArray(g, u, y, b)).index, p = v.j, null !== m && (y = r.globals.seriesXvalues[m], p = (v = this.closestInArray(g, y)).index)), r.globals.capturedSeriesIndex = null === m ? -1 : m, (!p || p < 1) && (p = 0), r.globals.capturedDataPointIndex = p, {
        capturedSeries: m,
        j: r.globals.isBarHorizontal ? x : p,
        hoverX: g,
        hoverY: u
      };
    }
  }, {
    key: "closestInMultiArray",
    value: function value(t, e, i, a) {
      var s = this.w,
          r = 0,
          n = null,
          o = -1;
      s.globals.series.length > 1 ? r = this.getFirstActiveXArray(i) : n = 0;
      var l = a[r][0],
          h = i[r][0],
          c = Math.abs(t - h),
          d = Math.abs(e - l),
          g = d + c;
      return a.map(function (s, r) {
        s.map(function (s, l) {
          var h = Math.abs(e - a[r][l]),
              u = Math.abs(t - i[r][l]),
              f = u + h;
          f < g && (g = f, c = u, d = h, n = r, o = l);
        });
      }), {
        index: n,
        j: o
      };
    }
  }, {
    key: "getFirstActiveXArray",
    value: function value(t) {
      for (var e = 0, i = t.map(function (t, e) {
        return t.length > 0 ? e : -1;
      }), a = 0; a < i.length; a++) {
        if (-1 !== i[a]) {
          e = i[a];
          break;
        }
      }

      return e;
    }
  }, {
    key: "closestInArray",
    value: function value(t, e) {
      for (var i = e[0], a = null, s = Math.abs(t - i), r = 0; r < e.length; r++) {
        var n = Math.abs(t - e[r]);
        n < s && (s = n, a = r);
      }

      return {
        index: a
      };
    }
  }, {
    key: "isXoverlap",
    value: function value(t) {
      var e = [],
          i = this.w.globals.seriesX.filter(function (t) {
        return void 0 !== t[0];
      });
      if (i.length > 0) for (var a = 0; a < i.length - 1; a++) {
        void 0 !== i[a][t] && void 0 !== i[a + 1][t] && i[a][t] !== i[a + 1][t] && e.push("unEqual");
      }
      return 0 === e.length;
    }
  }, {
    key: "isInitialSeriesSameLen",
    value: function value() {
      for (var t = !0, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++) {
        if (e[i].data.length !== e[i + 1].data.length) {
          t = !1;
          break;
        }
      }

      return t;
    }
  }, {
    key: "getBarsHeight",
    value: function value(t) {
      return g(t).reduce(function (t, e) {
        return t + e.getBBox().height;
      }, 0);
    }
  }, {
    key: "getElMarkers",
    value: function value() {
      return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers");
    }
  }, {
    key: "getAllMarkers",
    value: function value() {
      var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
      (t = g(t)).sort(function (t, e) {
        return Number(e.getAttribute("data:realIndex")) < Number(t.getAttribute("data:realIndex")) ? 0 : -1;
      });
      var e = [];
      return t.forEach(function (t) {
        e.push(t.querySelector(".apexcharts-marker"));
      }), e;
    }
  }, {
    key: "hasMarkers",
    value: function value() {
      return this.getElMarkers().length > 0;
    }
  }, {
    key: "getElBars",
    value: function value() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
    }
  }, {
    key: "hasBars",
    value: function value() {
      return this.getElBars().length > 0;
    }
  }, {
    key: "getHoverMarkerSize",
    value: function value(t) {
      var e = this.w,
          i = e.config.markers.hover.size;
      return void 0 === i && (i = e.globals.markers.size[t] + e.config.markers.hover.sizeOffset), i;
    }
  }, {
    key: "toggleAllTooltipSeriesGroups",
    value: function value(t) {
      var e = this.w,
          i = this.ttCtx;
      0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));

      for (var a = i.allTooltipSeriesGroups, s = 0; s < a.length; s++) {
        "enable" === t ? (a[s].classList.add("apexcharts-active"), a[s].style.display = e.config.tooltip.items.display) : (a[s].classList.remove("apexcharts-active"), a[s].style.display = "none");
      }
    }
  }]), t;
}(),
    gt = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.ctx = i.ctx, this.ttCtx = i, this.tooltipUtil = new dt(i);
  }

  return a(t, [{
    key: "drawSeriesTexts",
    value: function value(t) {
      var e = t.shared,
          i = void 0 === e || e,
          a = t.ttItems,
          s = t.i,
          r = void 0 === s ? 0 : s,
          n = t.j,
          o = void 0 === n ? null : n,
          l = t.y1,
          h = t.y2,
          c = t.e,
          d = this.w;
      void 0 !== d.config.tooltip.custom ? this.handleCustomTooltip({
        i: r,
        j: o,
        y1: l,
        y2: h,
        w: d
      }) : this.toggleActiveInactiveSeries(i);
      var g = this.getValuesToPrint({
        i: r,
        j: o
      });
      this.printLabels({
        i: r,
        j: o,
        values: g,
        ttItems: a,
        shared: i,
        e: c
      });
      var u = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = u.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u.getBoundingClientRect().height;
    }
  }, {
    key: "printLabels",
    value: function value(t) {
      var e,
          i = this,
          a = t.i,
          s = t.j,
          r = t.values,
          o = t.ttItems,
          l = t.shared,
          h = t.e,
          c = this.w,
          d = r.xVal,
          g = r.zVal,
          u = r.xAxisTTVal,
          f = "",
          p = c.globals.colors[a];
      null !== s && c.config.plotOptions.bar.distributed && (p = c.globals.colors[s]);

      for (var x = function x(t, r) {
        var x = i.getFormatters(a);
        f = i.getSeriesName({
          fn: x.yLbTitleFormatter,
          index: a,
          seriesIndex: a,
          j: s
        }), "treemap" === c.config.chart.type && (f = x.yLbTitleFormatter(String(c.config.series[a].data[s].x), {
          series: c.globals.series,
          seriesIndex: a,
          dataPointIndex: s,
          w: c
        }));
        var b = c.config.tooltip.inverseOrder ? r : t;

        if (c.globals.axisCharts) {
          var m = function m(t) {
            return x.yLbFormatter(c.globals.series[t][s], {
              series: c.globals.series,
              seriesIndex: t,
              dataPointIndex: s,
              w: c
            });
          };

          l ? (x = i.getFormatters(b), f = i.getSeriesName({
            fn: x.yLbTitleFormatter,
            index: b,
            seriesIndex: a,
            j: s
          }), p = c.globals.colors[b], e = m(b)) : (h && h.target && h.target.getAttribute("fill") && (p = h.target.getAttribute("fill")), e = m(a));
        }

        null === s && (e = x.yLbFormatter(c.globals.series[a], n(n({}, c), {}, {
          seriesIndex: a,
          dataPointIndex: a
        }))), i.DOMHandling({
          i: a,
          t: b,
          j: s,
          ttItems: o,
          values: {
            val: e,
            xVal: d,
            xAxisTTVal: u,
            zVal: g
          },
          seriesName: f,
          shared: l,
          pColor: p
        });
      }, b = 0, m = c.globals.series.length - 1; b < c.globals.series.length; b++, m--) {
        x(b, m);
      }
    }
  }, {
    key: "getFormatters",
    value: function value(t) {
      var e,
          i = this.w,
          a = i.globals.yLabelFormatters[t];
      return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (a = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, e = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (a = i.globals.ttVal.formatter, "function" == typeof i.globals.ttVal.title.formatter && (e = i.globals.ttVal.title.formatter)) : e = i.config.tooltip.y.title.formatter, "function" != typeof a && (a = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function (t) {
        return t;
      }), "function" != typeof e && (e = function e(t) {
        return t;
      }), {
        yLbFormatter: a,
        yLbTitleFormatter: e
      };
    }
  }, {
    key: "getSeriesName",
    value: function value(t) {
      var e = t.fn,
          i = t.index,
          a = t.seriesIndex,
          s = t.j,
          r = this.w;
      return e(String(r.globals.seriesNames[i]), {
        series: r.globals.series,
        seriesIndex: a,
        dataPointIndex: s,
        w: r
      });
    }
  }, {
    key: "DOMHandling",
    value: function value(t) {
      t.i;
      var e = t.t,
          i = (t.j, t.ttItems),
          a = t.values,
          s = t.seriesName,
          r = t.shared,
          n = t.pColor,
          o = this.w,
          l = this.ttCtx,
          h = a.val,
          c = a.xVal,
          d = a.xAxisTTVal,
          g = a.zVal,
          u = null;
      u = i[e].children, o.config.tooltip.fillSeriesColor && (i[e].style.backgroundColor = n, u[0].style.display = "none"), l.showTooltipTitle && (null === l.tooltipTitle && (l.tooltipTitle = o.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), l.tooltipTitle.innerHTML = c), l.blxaxisTooltip && (l.xaxisTooltipText.innerHTML = "" !== d ? d : c);
      var f = i[e].querySelector(".apexcharts-tooltip-text-label");
      f && (f.innerHTML = s || "");
      var p = i[e].querySelector(".apexcharts-tooltip-text-value");
      (p && (p.innerHTML = void 0 !== h ? h : ""), u[0] && u[0].classList.contains("apexcharts-tooltip-marker") && (o.config.tooltip.marker.fillColors && Array.isArray(o.config.tooltip.marker.fillColors) && (n = o.config.tooltip.marker.fillColors[e]), u[0].style.backgroundColor = n), o.config.tooltip.marker.show || (u[0].style.display = "none"), null !== g) && (i[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = o.config.tooltip.z.title, i[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== g ? g : "");
      r && u[0] && (null == h || o.globals.collapsedSeriesIndices.indexOf(e) > -1 ? u[0].parentNode.style.display = "none" : u[0].parentNode.style.display = o.config.tooltip.items.display);
    }
  }, {
    key: "toggleActiveInactiveSeries",
    value: function value(t) {
      var e = this.w;
      if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");else {
        this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
        var i = e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
        i && (i.classList.add("apexcharts-active"), i.style.display = e.config.tooltip.items.display);
      }
    }
  }, {
    key: "getValuesToPrint",
    value: function value(t) {
      var e = t.i,
          i = t.j,
          a = this.w,
          s = this.ctx.series.filteredSeriesX(),
          r = "",
          n = "",
          o = null,
          l = null,
          h = {
        series: a.globals.series,
        seriesIndex: e,
        dataPointIndex: i,
        w: a
      },
          c = a.globals.ttZFormatter;
      null === i ? l = a.globals.series[e] : a.globals.isXNumeric && "treemap" !== a.config.chart.type ? (r = s[e][i], 0 === s[e].length && (r = s[this.tooltipUtil.getFirstActiveXArray(s)][i])) : r = void 0 !== a.globals.labels[i] ? a.globals.labels[i] : "";
      var d = r;
      a.globals.isXNumeric && "datetime" === a.config.xaxis.type ? r = new W(this.ctx).xLabelFormat(a.globals.ttKeyFormatter, d, d, {
        i: void 0,
        dateFormatter: new Y(this.ctx).formatDate,
        w: this.w
      }) : r = a.globals.isBarHorizontal ? a.globals.yLabelFormatters[0](d, h) : a.globals.xLabelFormatter(d, h);
      return void 0 !== a.config.tooltip.x.formatter && (r = a.globals.ttKeyFormatter(d, h)), a.globals.seriesZ.length > 0 && a.globals.seriesZ[e].length > 0 && (o = c(a.globals.seriesZ[e][i], a)), n = "function" == typeof a.config.xaxis.tooltip.formatter ? a.globals.xaxisTooltipFormatter(d, h) : r, {
        val: Array.isArray(l) ? l.join(" ") : l,
        xVal: Array.isArray(r) ? r.join(" ") : r,
        xAxisTTVal: Array.isArray(n) ? n.join(" ") : n,
        zVal: o
      };
    }
  }, {
    key: "handleCustomTooltip",
    value: function value(t) {
      var e = t.i,
          i = t.j,
          a = t.y1,
          s = t.y2,
          r = t.w,
          n = this.ttCtx.getElTooltip(),
          o = r.config.tooltip.custom;
      Array.isArray(o) && o[e] && (o = o[e]), n.innerHTML = o({
        ctx: this.ctx,
        series: r.globals.series,
        seriesIndex: e,
        dataPointIndex: i,
        y1: a,
        y2: s,
        w: r
      });
    }
  }]), t;
}(),
    ut = function () {
  function t(i) {
    e(this, t), this.ttCtx = i, this.ctx = i.ctx, this.w = i.w;
  }

  return a(t, [{
    key: "moveXCrosshairs",
    value: function value(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
          i = this.ttCtx,
          a = this.w,
          s = i.getElXCrosshairs(),
          r = t - i.xcrosshairsWidth / 2,
          n = a.globals.labels.slice().length;

      if (null !== e && (r = a.globals.gridWidth / n * e), null !== s && (s.setAttribute("x", r), s.setAttribute("x1", r), s.setAttribute("x2", r), s.setAttribute("y2", a.globals.gridHeight), s.classList.add("apexcharts-active")), r < 0 && (r = 0), r > a.globals.gridWidth && (r = a.globals.gridWidth), i.blxaxisTooltip) {
        var o = r;
        "tickWidth" !== a.config.xaxis.crosshairs.width && "barWidth" !== a.config.xaxis.crosshairs.width || (o = r + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o);
      }
    }
  }, {
    key: "moveYCrosshairs",
    value: function value(t) {
      var e = this.ttCtx;
      null !== e.ycrosshairs && b.setAttrs(e.ycrosshairs, {
        y1: t,
        y2: t
      }), null !== e.ycrosshairsHidden && b.setAttrs(e.ycrosshairsHidden, {
        y1: t,
        y2: t
      });
    }
  }, {
    key: "moveXAxisTooltip",
    value: function value(t) {
      var e = this.w,
          i = this.ttCtx;

      if (null !== i.xaxisTooltip) {
        i.xaxisTooltip.classList.add("apexcharts-active");
        var a = i.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY;

        if (t -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) {
          t += e.globals.translateX;
          var s;
          s = new b(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = s.width + "px", i.xaxisTooltip.style.left = t + "px", i.xaxisTooltip.style.top = a + "px";
        }
      }
    }
  }, {
    key: "moveYAxisTooltip",
    value: function value(t) {
      var e = this.w,
          i = this.ttCtx;
      null === i.yaxisTTEls && (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      var a = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10),
          s = e.globals.translateY + a,
          r = i.yaxisTTEls[t].getBoundingClientRect().height,
          n = e.globals.translateYAxisX[t] - 2;
      e.config.yaxis[t].opposite && (n -= 26), s -= r / 2, -1 === e.globals.ignoreYAxisIndexes.indexOf(t) ? (i.yaxisTTEls[t].classList.add("apexcharts-active"), i.yaxisTTEls[t].style.top = s + "px", i.yaxisTTEls[t].style.left = n + e.config.yaxis[t].tooltip.offsetX + "px") : i.yaxisTTEls[t].classList.remove("apexcharts-active");
    }
  }, {
    key: "moveTooltip",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
          a = this.w,
          s = this.ttCtx,
          r = s.getElTooltip(),
          n = s.tooltipRect,
          o = null !== i ? parseFloat(i) : 1,
          l = parseFloat(t) + o + 5,
          h = parseFloat(e) + o / 2;

      if (l > a.globals.gridWidth / 2 && (l = l - n.ttWidth - o - 15), l > a.globals.gridWidth - n.ttWidth - 10 && (l = a.globals.gridWidth - n.ttWidth), l < -20 && (l = -20), a.config.tooltip.followCursor) {
        var c = s.getElGrid(),
            d = c.getBoundingClientRect();
        h = s.e.clientY + a.globals.translateY - d.top - n.ttHeight / 2;
      } else a.globals.isBarHorizontal ? h -= n.ttHeight : (n.ttHeight / 2 + h > a.globals.gridHeight && (h = a.globals.gridHeight - n.ttHeight + a.globals.translateY), h < 0 && (h = 0));

      isNaN(l) || (l += a.globals.translateX, r.style.left = l + "px", r.style.top = h + "px");
    }
  }, {
    key: "moveMarkers",
    value: function value(t, e) {
      var i = this.w,
          a = this.ttCtx;
      if (i.globals.markers.size[t] > 0) for (var s = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), r = 0; r < s.length; r++) {
        parseInt(s[r].getAttribute("rel"), 10) === e && (a.marker.resetPointsSize(), a.marker.enlargeCurrentPoint(e, s[r]));
      } else a.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t);
    }
  }, {
    key: "moveDynamicPointOnHover",
    value: function value(t, e) {
      var i,
          a,
          s = this.w,
          r = this.ttCtx,
          n = s.globals.pointsArray,
          o = r.tooltipUtil.getHoverMarkerSize(e),
          l = s.config.series[e].type;

      if (!l || "column" !== l && "candlestick" !== l && "boxPlot" !== l) {
        i = n[e][t][0], a = n[e][t][1] ? n[e][t][1] : 0;
        var h = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle"));
        h && a < s.globals.gridHeight && a > 0 && (h.setAttribute("r", o), h.setAttribute("cx", i), h.setAttribute("cy", a)), this.moveXCrosshairs(i), r.fixedTooltip || this.moveTooltip(i, a, o);
      }
    }
  }, {
    key: "moveDynamicPointsOnHover",
    value: function value(t) {
      var e,
          i = this.ttCtx,
          a = i.w,
          s = 0,
          r = 0,
          n = a.globals.pointsArray;
      e = new M(this.ctx).getActiveConfigSeriesIndex(!0);
      var o = i.tooltipUtil.getHoverMarkerSize(e);
      n[e] && (s = n[e][t][0], r = n[e][t][1]);
      var l = i.tooltipUtil.getAllMarkers();
      if (null !== l) for (var h = 0; h < a.globals.series.length; h++) {
        var c = n[h];

        if (a.globals.comboCharts && void 0 === c && l.splice(h, 0, null), c && c.length) {
          var d = n[h][t][1];
          l[h].setAttribute("cx", s), null !== d && !isNaN(d) && d < a.globals.gridHeight && d > 0 ? (l[h] && l[h].setAttribute("r", o), l[h] && l[h].setAttribute("cy", d)) : l[h] && l[h].setAttribute("r", 0);
        }
      }

      if (this.moveXCrosshairs(s), !i.fixedTooltip) {
        var g = r || a.globals.gridHeight;
        this.moveTooltip(s, g, o);
      }
    }
  }, {
    key: "moveStickyTooltipOverBars",
    value: function value(t) {
      var e = this.w,
          i = this.ttCtx,
          a = e.globals.columnSeries ? e.globals.columnSeries.length : e.globals.series.length,
          s = a >= 2 && a % 2 == 0 ? Math.floor(a / 2) : Math.floor(a / 2) + 1;
      e.globals.isBarHorizontal && (s = new M(this.ctx).getActiveConfigSeriesIndex(!1, "desc") + 1);
      var r = e.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(s, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "']")),
          n = r ? parseFloat(r.getAttribute("cx")) : 0,
          o = r ? parseFloat(r.getAttribute("cy")) : 0,
          l = r ? parseFloat(r.getAttribute("barWidth")) : 0,
          h = r ? parseFloat(r.getAttribute("barHeight")) : 0,
          c = i.getElGrid().getBoundingClientRect();

      if (e.globals.isXNumeric ? (n -= a % 2 != 0 ? l / 2 : 0, (r.classList.contains("apexcharts-candlestick-area") || r.classList.contains("apexcharts-boxPlot-area")) && e.globals.comboCharts && (n -= l / 2)) : e.globals.isBarHorizontal || (n = i.xAxisTicksPositions[t - 1] + i.dataPointsDividedWidth / 2, isNaN(n) && (n = i.xAxisTicksPositions[t] - i.dataPointsDividedWidth / 2)), e.globals.isBarHorizontal ? o += h / 3 : o = i.e.clientY - c.top - i.tooltipRect.ttHeight / 2, e.globals.isBarHorizontal || this.moveXCrosshairs(n), !i.fixedTooltip) {
        var d = o || e.globals.gridHeight;
        this.moveTooltip(n, d);
      }
    }
  }]), t;
}(),
    ft = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.ttCtx = i, this.ctx = i.ctx, this.tooltipPosition = new ut(i);
  }

  return a(t, [{
    key: "drawDynamicPoints",
    value: function value() {
      var t = this.w,
          e = new b(this.ctx),
          i = new P(this.ctx),
          a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      a = g(a), t.config.chart.stacked && a.sort(function (t, e) {
        return parseFloat(t.getAttribute("data:realIndex")) - parseFloat(e.getAttribute("data:realIndex"));
      });

      for (var s = 0; s < a.length; s++) {
        var r = a[s].querySelector(".apexcharts-series-markers-wrap");

        if (null !== r) {
          var n = void 0,
              o = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
          "line" !== t.config.chart.type && "area" !== t.config.chart.type || t.globals.comboCharts || t.config.tooltip.intersect || (o += " no-pointer-events");
          var l = i.getMarkerConfig(o, s);
          (n = e.drawMarker(0, 0, l)).node.setAttribute("default-marker-size", 0);
          var h = document.createElementNS(t.globals.SVGNS, "g");
          h.classList.add("apexcharts-series-markers"), h.appendChild(n.node), r.appendChild(h);
        }
      }
    }
  }, {
    key: "enlargeCurrentPoint",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
          a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
          s = this.w;
      "bubble" !== s.config.chart.type && this.newPointSize(t, e);
      var r = e.getAttribute("cx"),
          n = e.getAttribute("cy");

      if (null !== i && null !== a && (r = i, n = a), this.tooltipPosition.moveXCrosshairs(r), !this.fixedTooltip) {
        if ("radar" === s.config.chart.type) {
          var o = this.ttCtx.getElGrid(),
              l = o.getBoundingClientRect();
          r = this.ttCtx.e.clientX - l.left;
        }

        this.tooltipPosition.moveTooltip(r, n, s.config.markers.hover.size);
      }
    }
  }, {
    key: "enlargePoints",
    value: function value(t) {
      for (var e = this.w, i = this, a = this.ttCtx, s = t, r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n = e.config.markers.hover.size, o = 0; o < r.length; o++) {
        var l = r[o].getAttribute("rel"),
            h = r[o].getAttribute("index");

        if (void 0 === n && (n = e.globals.markers.size[h] + e.config.markers.hover.sizeOffset), s === parseInt(l, 10)) {
          i.newPointSize(s, r[o]);
          var c = r[o].getAttribute("cx"),
              d = r[o].getAttribute("cy");
          i.tooltipPosition.moveXCrosshairs(c), a.fixedTooltip || i.tooltipPosition.moveTooltip(c, d, n);
        } else i.oldPointSize(r[o]);
      }
    }
  }, {
    key: "newPointSize",
    value: function value(t, e) {
      var i = this.w,
          a = i.config.markers.hover.size,
          s = 0 === t ? e.parentNode.firstChild : e.parentNode.lastChild;

      if ("0" !== s.getAttribute("default-marker-size")) {
        var r = parseInt(s.getAttribute("index"), 10);
        void 0 === a && (a = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset), s.setAttribute("r", a);
      }
    }
  }, {
    key: "oldPointSize",
    value: function value(t) {
      var e = parseFloat(t.getAttribute("default-marker-size"));
      t.setAttribute("r", e);
    }
  }, {
    key: "resetPointsSize",
    value: function value() {
      for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e = 0; e < t.length; e++) {
        var i = parseFloat(t[e].getAttribute("default-marker-size"));
        f.isNumber(i) ? t[e].setAttribute("r", i) : t[e].setAttribute("r", 0);
      }
    }
  }]), t;
}(),
    pt = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.ttCtx = i;
  }

  return a(t, [{
    key: "getAttr",
    value: function value(t, e) {
      return parseFloat(t.target.getAttribute(e));
    }
  }, {
    key: "handleHeatTreeTooltip",
    value: function value(t) {
      var e = t.e,
          i = t.opt,
          a = t.x,
          s = t.y,
          r = t.type,
          n = this.ttCtx,
          o = this.w;

      if (e.target.classList.contains("apexcharts-".concat(r, "-rect"))) {
        var l = this.getAttr(e, "i"),
            h = this.getAttr(e, "j"),
            c = this.getAttr(e, "cx"),
            d = this.getAttr(e, "cy"),
            g = this.getAttr(e, "width"),
            u = this.getAttr(e, "height");

        if (n.tooltipLabels.drawSeriesTexts({
          ttItems: i.ttItems,
          i: l,
          j: h,
          shared: !1,
          e: e
        }), o.globals.capturedSeriesIndex = l, o.globals.capturedDataPointIndex = h, a = c + n.tooltipRect.ttWidth / 2 + g, s = d + n.tooltipRect.ttHeight / 2 - u / 2, n.tooltipPosition.moveXCrosshairs(c + g / 2), a > o.globals.gridWidth / 2 && (a = c - n.tooltipRect.ttWidth / 2 + g), n.w.config.tooltip.followCursor) {
          var f = o.globals.dom.elWrap.getBoundingClientRect();
          a = o.globals.clientX - f.left - n.tooltipRect.ttWidth / 2, s = o.globals.clientY - f.top - n.tooltipRect.ttHeight - 5;
        }
      }

      return {
        x: a,
        y: s
      };
    }
  }, {
    key: "handleMarkerTooltip",
    value: function value(t) {
      var e,
          i,
          a = t.e,
          s = t.opt,
          r = t.x,
          n = t.y,
          o = this.w,
          l = this.ttCtx;

      if (a.target.classList.contains("apexcharts-marker")) {
        var h = parseInt(s.paths.getAttribute("cx"), 10),
            c = parseInt(s.paths.getAttribute("cy"), 10),
            d = parseFloat(s.paths.getAttribute("val"));

        if (i = parseInt(s.paths.getAttribute("rel"), 10), e = parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l.intersect) {
          var g = f.findAncestor(s.paths, "apexcharts-series");
          g && (e = parseInt(g.getAttribute("data:realIndex"), 10));
        }

        if (l.tooltipLabels.drawSeriesTexts({
          ttItems: s.ttItems,
          i: e,
          j: i,
          shared: !l.showOnIntersect && o.config.tooltip.shared,
          e: a
        }), "mouseup" === a.type && l.markerClick(a, e, i), o.globals.capturedSeriesIndex = e, o.globals.capturedDataPointIndex = i, r = h, n = c + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight, l.w.config.tooltip.followCursor) {
          var u = l.getElGrid().getBoundingClientRect();
          n = l.e.clientY + o.globals.translateY - u.top;
        }

        d < 0 && (n = c), l.marker.enlargeCurrentPoint(i, s.paths, r, n);
      }

      return {
        x: r,
        y: n
      };
    }
  }, {
    key: "handleBarTooltip",
    value: function value(t) {
      var e,
          i,
          a = t.e,
          s = t.opt,
          r = this.w,
          n = this.ttCtx,
          o = n.getElTooltip(),
          l = 0,
          h = 0,
          c = 0,
          d = this.getBarTooltipXY({
        e: a,
        opt: s
      });
      e = d.i;
      var g = d.barHeight,
          u = d.j;
      r.globals.capturedSeriesIndex = e, r.globals.capturedDataPointIndex = u, r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (h = d.x, c = d.y, i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[e] : r.config.stroke.width, l = h) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2), isNaN(c) ? c = r.globals.svgHeight - n.tooltipRect.ttHeight : c < 0 && (c = 0);
      var f = parseInt(s.paths.parentNode.getAttribute("data:realIndex"), 10),
          p = r.globals.isMultipleYAxis ? r.config.yaxis[f] && r.config.yaxis[f].reversed : r.config.yaxis[0].reversed;

      if (h + n.tooltipRect.ttWidth > r.globals.gridWidth && !p ? h -= n.tooltipRect.ttWidth : h < 0 && (h = 0), n.w.config.tooltip.followCursor) {
        var x = n.getElGrid().getBoundingClientRect();
        c = n.e.clientY - x.top;
      }

      null === n.tooltip && (n.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r.config.tooltip.shared || (r.globals.comboBarCount > 0 ? n.tooltipPosition.moveXCrosshairs(l + i / 2) : n.tooltipPosition.moveXCrosshairs(l)), !n.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && n.tooltipUtil.hasBars()) && (p && (h -= n.tooltipRect.ttWidth) < 0 && (h = 0), o.style.left = h + r.globals.translateX + "px", !p || r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || (c = c + g - 2 * (r.globals.series[e][u] < 0 ? g : 0)), n.tooltipRect.ttHeight + c > r.globals.gridHeight ? (c = r.globals.gridHeight - n.tooltipRect.ttHeight + r.globals.translateY, o.style.top = c + "px") : o.style.top = c + r.globals.translateY - n.tooltipRect.ttHeight / 2 + "px");
    }
  }, {
    key: "getBarTooltipXY",
    value: function value(t) {
      var e = t.e,
          i = t.opt,
          a = this.w,
          s = null,
          r = this.ttCtx,
          n = 0,
          o = 0,
          l = 0,
          h = 0,
          c = 0,
          d = e.target.classList;

      if (d.contains("apexcharts-bar-area") || d.contains("apexcharts-candlestick-area") || d.contains("apexcharts-boxPlot-area") || d.contains("apexcharts-rangebar-area")) {
        var g = e.target,
            u = g.getBoundingClientRect(),
            f = i.elGrid.getBoundingClientRect(),
            p = u.height;
        c = u.height;
        var x = u.width,
            b = parseInt(g.getAttribute("cx"), 10),
            m = parseInt(g.getAttribute("cy"), 10);
        h = parseFloat(g.getAttribute("barWidth"));
        var v = "touchmove" === e.type ? e.touches[0].clientX : e.clientX;
        s = parseInt(g.getAttribute("j"), 10), n = parseInt(g.parentNode.getAttribute("rel"), 10) - 1;
        var y = g.getAttribute("data-range-y1"),
            w = g.getAttribute("data-range-y2");
        a.globals.comboCharts && (n = parseInt(g.parentNode.getAttribute("data:realIndex"), 10)), r.tooltipLabels.drawSeriesTexts({
          ttItems: i.ttItems,
          i: n,
          j: s,
          y1: y ? parseInt(y, 10) : null,
          y2: w ? parseInt(w, 10) : null,
          shared: !r.showOnIntersect && a.config.tooltip.shared,
          e: e
        }), a.config.tooltip.followCursor ? a.globals.isBarHorizontal ? (o = v - f.left + 15, l = m - r.dataPointsDividedHeight + p / 2 - r.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? b - x / 2 : b - r.dataPointsDividedWidth + x / 2, l = e.clientY - f.top - r.tooltipRect.ttHeight / 2 - 15) : a.globals.isBarHorizontal ? ((o = b) < r.xyRatios.baseLineInvertedY && (o = b - r.tooltipRect.ttWidth), l = m - r.dataPointsDividedHeight + p / 2 - r.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? b - x / 2 : b - r.dataPointsDividedWidth + x / 2, l = m);
      }

      return {
        x: o,
        y: l,
        barHeight: c,
        barWidth: h,
        i: n,
        j: s
      };
    }
  }]), t;
}(),
    xt = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.ttCtx = i;
  }

  return a(t, [{
    key: "drawXaxisTooltip",
    value: function value() {
      var t = this.w,
          e = this.ttCtx,
          i = "bottom" === t.config.xaxis.position;
      e.xaxisOffY = i ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
      var a = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top",
          s = t.globals.dom.elWrap;
      e.blxaxisTooltip && null === t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e.xaxisTooltip = document.createElement("div"), e.xaxisTooltip.setAttribute("class", a + " apexcharts-theme-" + t.config.tooltip.theme), s.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement("div"), e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText));
    }
  }, {
    key: "drawYaxisTooltip",
    value: function value() {
      for (var t = this.w, e = this.ttCtx, i = function i(_i2) {
        var a = t.config.yaxis[_i2].opposite || t.config.yaxis[_i2].crosshairs.opposite;
        e.yaxisOffX = a ? t.globals.gridWidth + 1 : 1;
        var s = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(_i2, a ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
        t.globals.yAxisSameScaleIndices.map(function (e, a) {
          e.map(function (e, a) {
            a === _i2 && (s += t.config.yaxis[a].show ? " " : " apexcharts-yaxistooltip-hidden");
          });
        });
        var r = t.globals.dom.elWrap;
        null === t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(_i2)) && (e.yaxisTooltip = document.createElement("div"), e.yaxisTooltip.setAttribute("class", s + " apexcharts-theme-" + t.config.tooltip.theme), r.appendChild(e.yaxisTooltip), 0 === _i2 && (e.yaxisTooltipText = []), e.yaxisTooltipText[_i2] = document.createElement("div"), e.yaxisTooltipText[_i2].classList.add("apexcharts-yaxistooltip-text"), e.yaxisTooltip.appendChild(e.yaxisTooltipText[_i2]));
      }, a = 0; a < t.config.yaxis.length; a++) {
        i(a);
      }
    }
  }, {
    key: "setXCrosshairWidth",
    value: function value() {
      var t = this.w,
          e = this.ttCtx,
          i = e.getElXCrosshairs();

      if (e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
        var a = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");

        if (null !== a && "barWidth" === t.config.xaxis.crosshairs.width) {
          var s = parseFloat(a.getAttribute("barWidth"));
          e.xcrosshairsWidth = s;
        } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
          var r = t.globals.labels.length;
          e.xcrosshairsWidth = t.globals.gridWidth / r;
        }
      } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
        var n = t.globals.labels.length;
        e.xcrosshairsWidth = t.globals.gridWidth / n;
      } else if ("barWidth" === t.config.xaxis.crosshairs.width) {
        var o = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");

        if (null !== o) {
          var l = parseFloat(o.getAttribute("barWidth"));
          e.xcrosshairsWidth = l;
        } else e.xcrosshairsWidth = 1;
      }

      t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), null !== i && e.xcrosshairsWidth > 0 && i.setAttribute("width", e.xcrosshairsWidth);
    }
  }, {
    key: "handleYCrosshair",
    value: function value() {
      var t = this.w,
          e = this.ttCtx;
      e.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
    }
  }, {
    key: "drawYaxisTooltipText",
    value: function value(t, e, i) {
      var a = this.ttCtx,
          s = this.w,
          r = s.globals.yLabelFormatters[t];

      if (a.yaxisTooltips[t]) {
        var n = a.getElGrid().getBoundingClientRect(),
            o = (e - n.top) * i.yRatio[t],
            l = s.globals.maxYArr[t] - s.globals.minYArr[t],
            h = s.globals.minYArr[t] + (l - o);
        a.tooltipPosition.moveYCrosshairs(e - n.top), a.yaxisTooltipText[t].innerHTML = r(h), a.tooltipPosition.moveYAxisTooltip(t);
      }
    }
  }]), t;
}(),
    bt = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
    var a = this.w;
    this.tConfig = a.config.tooltip, this.tooltipUtil = new dt(this), this.tooltipLabels = new gt(this), this.tooltipPosition = new ut(this), this.marker = new ft(this), this.intersect = new pt(this), this.axesTooltip = new xt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a.globals.isBarHorizontal && this.tConfig.shared;
  }

  return a(t, [{
    key: "getElTooltip",
    value: function value(t) {
      return t || (t = this), t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip");
    }
  }, {
    key: "getElXCrosshairs",
    value: function value() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
    }
  }, {
    key: "getElGrid",
    value: function value() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
    }
  }, {
    key: "drawTooltip",
    value: function value(t) {
      var e = this.w;
      this.xyRatios = t, this.blxaxisTooltip = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.yaxisTooltips = e.config.yaxis.map(function (t, i) {
        return !!(t.show && t.tooltip.enabled && e.globals.axisCharts);
      }), this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = !1);
      var i = document.createElement("div");

      if (i.classList.add("apexcharts-tooltip"), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e.globals.dom.elWrap.appendChild(i), e.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
        var a = new G(this.ctx);
        this.xAxisTicksPositions = a.getXAxisTicksPositions();
      }

      if (!e.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== e.config.markers.size && 0 !== e.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) {
        this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
        var s = e.globals.series.length;
        (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (s = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s), this.addSVGEvents();
      }
    }
  }, {
    key: "createTTElements",
    value: function value(t) {
      for (var e = this.w, i = [], a = this.getElTooltip(), s = 0; s < t; s++) {
        var r = document.createElement("div");
        r.classList.add("apexcharts-tooltip-series-group"), r.style.order = e.config.tooltip.inverseOrder ? t - s : s + 1, this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries) && this.tConfig.enabledOnSeries.indexOf(s) < 0 && r.classList.add("apexcharts-tooltip-series-group-hidden");
        var n = document.createElement("span");
        n.classList.add("apexcharts-tooltip-marker"), n.style.backgroundColor = e.globals.colors[s], r.appendChild(n);
        var o = document.createElement("div");
        o.classList.add("apexcharts-tooltip-text"), o.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, o.style.fontSize = this.tConfig.style.fontSize;
        var l = document.createElement("div");
        l.classList.add("apexcharts-tooltip-y-group");
        var h = document.createElement("span");
        h.classList.add("apexcharts-tooltip-text-label"), l.appendChild(h);
        var c = document.createElement("span");
        c.classList.add("apexcharts-tooltip-text-value"), l.appendChild(c);
        var d = document.createElement("div");
        d.classList.add("apexcharts-tooltip-z-group");
        var g = document.createElement("span");
        g.classList.add("apexcharts-tooltip-text-z-label"), d.appendChild(g);
        var u = document.createElement("span");
        u.classList.add("apexcharts-tooltip-text-z-value"), d.appendChild(u), o.appendChild(l), o.appendChild(d), r.appendChild(o), a.appendChild(r), i.push(r);
      }

      return i;
    }
  }, {
    key: "addSVGEvents",
    value: function value() {
      var t = this.w,
          e = t.config.chart.type,
          i = this.getElTooltip(),
          a = !("bar" !== e && "candlestick" !== e && "boxPlot" !== e && "rangeBar" !== e),
          s = "area" === e || "line" === e || "scatter" === e || "bubble" === e || "radar" === e,
          r = t.globals.dom.Paper.node,
          n = this.getElGrid();
      n && (this.seriesBound = n.getBoundingClientRect());
      var o,
          l = [],
          h = [],
          c = {
        hoverArea: r,
        elGrid: n,
        tooltipEl: i,
        tooltipY: l,
        tooltipX: h,
        ttItems: this.ttItems
      };
      if (t.globals.axisCharts && (s ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e && "treemap" !== e || (o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o && o.length)) for (var d = 0; d < o.length; d++) {
        l.push(o[d].getAttribute("cy")), h.push(o[d].getAttribute("cx"));
      }
      if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || a && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r], c);else if (a && !t.globals.comboCharts || s && this.showOnIntersect) this.addDatapointEventsListeners(c);else if (!t.globals.axisCharts || "heatmap" === e || "treemap" === e) {
        var g = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        this.addPathsEventListeners(g, c);
      }

      if (this.showOnIntersect) {
        var u = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
        u.length > 0 && this.addPathsEventListeners(u, c), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c);
      }
    }
  }, {
    key: "drawFixedTooltipRect",
    value: function value() {
      var t = this.w,
          e = this.getElTooltip(),
          i = e.getBoundingClientRect(),
          a = i.width + 10,
          s = i.height + 10,
          r = this.tConfig.fixed.offsetX,
          n = this.tConfig.fixed.offsetY,
          o = this.tConfig.fixed.position.toLowerCase();
      return o.indexOf("right") > -1 && (r = r + t.globals.svgWidth - a + 10), o.indexOf("bottom") > -1 && (n = n + t.globals.svgHeight - s - 10), e.style.left = r + "px", e.style.top = n + "px", {
        x: r,
        y: n,
        ttWidth: a,
        ttHeight: s
      };
    }
  }, {
    key: "addDatapointEventsListeners",
    value: function value(t) {
      var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
      this.addPathsEventListeners(e, t);
    }
  }, {
    key: "addPathsEventListeners",
    value: function value(t, e) {
      for (var i = this, a = function a(_a) {
        var s = {
          paths: t[_a],
          tooltipEl: e.tooltipEl,
          tooltipY: e.tooltipY,
          tooltipX: e.tooltipX,
          elGrid: e.elGrid,
          hoverArea: e.hoverArea,
          ttItems: e.ttItems
        };
        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function (e) {
          return t[_a].addEventListener(e, i.seriesHover.bind(i, s), {
            capture: !1,
            passive: !0
          });
        });
      }, s = 0; s < t.length; s++) {
        a(s);
      }
    }
  }, {
    key: "seriesHover",
    value: function value(t, e) {
      var i = this,
          a = [],
          s = this.w;
      s.config.chart.group && (a = this.ctx.getGroupedCharts()), s.globals.axisCharts && (s.globals.minX === -1 / 0 && s.globals.maxX === 1 / 0 || 0 === s.globals.dataPoints) || (a.length ? a.forEach(function (a) {
        var s = i.getElTooltip(a),
            r = {
          paths: t.paths,
          tooltipEl: s,
          tooltipY: t.tooltipY,
          tooltipX: t.tooltipX,
          elGrid: t.elGrid,
          hoverArea: t.hoverArea,
          ttItems: a.w.globals.tooltip.ttItems
        };
        a.w.globals.minX === i.w.globals.minX && a.w.globals.maxX === i.w.globals.maxX && a.w.globals.tooltip.seriesHoverByContext({
          chartCtx: a,
          ttCtx: a.w.globals.tooltip,
          opt: r,
          e: e
        });
      }) : this.seriesHoverByContext({
        chartCtx: this.ctx,
        ttCtx: this.w.globals.tooltip,
        opt: t,
        e: e
      }));
    }
  }, {
    key: "seriesHoverByContext",
    value: function value(t) {
      var e = t.chartCtx,
          i = t.ttCtx,
          a = t.opt,
          s = t.e,
          r = e.w,
          n = this.getElTooltip();
      (i.tooltipRect = {
        x: 0,
        y: 0,
        ttWidth: n.getBoundingClientRect().width,
        ttHeight: n.getBoundingClientRect().height
      }, i.e = s, !i.tooltipUtil.hasBars() || r.globals.comboCharts || i.isBarShared) || this.tConfig.onDatasetHover.highlightDataSeries && new M(e).toggleSeriesOnHover(s, s.target.parentNode);
      i.fixedTooltip && i.drawFixedTooltipRect(), r.globals.axisCharts ? i.axisChartsTooltips({
        e: s,
        opt: a,
        tooltipRect: i.tooltipRect
      }) : i.nonAxisChartsTooltips({
        e: s,
        opt: a,
        tooltipRect: i.tooltipRect
      });
    }
  }, {
    key: "axisChartsTooltips",
    value: function value(t) {
      var e,
          i,
          a = t.e,
          s = t.opt,
          r = this.w,
          n = s.elGrid.getBoundingClientRect(),
          o = "touchmove" === a.type ? a.touches[0].clientX : a.clientX,
          l = "touchmove" === a.type ? a.touches[0].clientY : a.clientY;
      if (this.clientY = l, this.clientX = o, r.globals.capturedSeriesIndex = -1, r.globals.capturedDataPointIndex = -1, l < n.top || l > n.top + n.height) this.handleMouseOut(s);else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) {
          var h = parseInt(s.paths.getAttribute("index"), 10);
          if (this.tConfig.enabledOnSeries.indexOf(h) < 0) return void this.handleMouseOut(s);
        }

        var c = this.getElTooltip(),
            d = this.getElXCrosshairs(),
            g = r.globals.xyCharts || "bar" === r.config.chart.type && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars();

        if ("mousemove" === a.type || "touchmove" === a.type || "mouseup" === a.type) {
          null !== d && d.classList.add("apexcharts-active");
          var u = this.yaxisTooltips.filter(function (t) {
            return !0 === t;
          });
          if (null !== this.ycrosshairs && u.length && this.ycrosshairs.classList.add("apexcharts-active"), g && !this.showOnIntersect) this.handleStickyTooltip(a, o, l, s);else if ("heatmap" === r.config.chart.type || "treemap" === r.config.chart.type) {
            var f = this.intersect.handleHeatTreeTooltip({
              e: a,
              opt: s,
              x: e,
              y: i,
              type: r.config.chart.type
            });
            e = f.x, i = f.y, c.style.left = e + "px", c.style.top = i + "px";
          } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
            e: a,
            opt: s
          }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
            e: a,
            opt: s,
            x: e,
            y: i
          });
          if (this.yaxisTooltips.length) for (var p = 0; p < r.config.yaxis.length; p++) {
            this.axesTooltip.drawYaxisTooltipText(p, l, this.xyRatios);
          }
          s.tooltipEl.classList.add("apexcharts-active");
        } else "mouseout" !== a.type && "touchend" !== a.type || this.handleMouseOut(s);
      }
    }
  }, {
    key: "nonAxisChartsTooltips",
    value: function value(t) {
      var e = t.e,
          i = t.opt,
          a = t.tooltipRect,
          s = this.w,
          r = i.paths.getAttribute("rel"),
          n = this.getElTooltip(),
          o = s.globals.dom.elWrap.getBoundingClientRect();

      if ("mousemove" === e.type || "touchmove" === e.type) {
        n.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
          ttItems: i.ttItems,
          i: parseInt(r, 10) - 1,
          shared: !1
        });
        var l = s.globals.clientX - o.left - a.ttWidth / 2,
            h = s.globals.clientY - o.top - a.ttHeight - 10;

        if (n.style.left = l + "px", n.style.top = h + "px", s.config.legend.tooltipHoverFormatter) {
          var c = r - 1,
              d = (0, s.config.legend.tooltipHoverFormatter)(this.legendLabels[c].getAttribute("data:default-text"), {
            seriesIndex: c,
            dataPointIndex: c,
            w: s
          });
          this.legendLabels[c].innerHTML = d;
        }
      } else "mouseout" !== e.type && "touchend" !== e.type || (n.classList.remove("apexcharts-active"), s.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function (t) {
        var e = t.getAttribute("data:default-text");
        t.innerHTML = decodeURIComponent(e);
      }));
    }
  }, {
    key: "handleStickyTooltip",
    value: function value(t, e, i, a) {
      var s = this.w,
          r = this.tooltipUtil.getNearestValues({
        context: this,
        hoverArea: a.hoverArea,
        elGrid: a.elGrid,
        clientX: e,
        clientY: i
      }),
          n = r.j,
          o = r.capturedSeries;
      r.hoverX < 0 || r.hoverX > s.globals.gridWidth ? this.handleMouseOut(a) : null !== o ? this.handleStickyCapturedSeries(t, o, a, n) : (this.tooltipUtil.isXoverlap(n) || s.globals.isBarHorizontal) && this.create(t, this, 0, n, a.ttItems);
    }
  }, {
    key: "handleStickyCapturedSeries",
    value: function value(t, e, i, a) {
      var s = this.w;
      null === s.globals.series[e][a] ? this.handleMouseOut(i) : void 0 !== s.globals.series[e][a] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(a) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, e, a, i.ttItems) : this.create(t, this, e, a, i.ttItems, !1) : this.tooltipUtil.isXoverlap(a) && this.create(t, this, 0, a, i.ttItems);
    }
  }, {
    key: "deactivateHoverFilter",
    value: function value() {
      for (var t = this.w, e = new b(this.ctx), i = t.globals.dom.Paper.select(".apexcharts-bar-area"), a = 0; a < i.length; a++) {
        e.pathMouseLeave(i[a]);
      }
    }
  }, {
    key: "handleMouseOut",
    value: function value(t) {
      var e = this.w,
          i = this.getElXCrosshairs();

      if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e.config.chart.type && this.marker.resetPointsSize(), null !== i && i.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.blxaxisTooltip && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
        null === this.yaxisTTEls && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));

        for (var a = 0; a < this.yaxisTTEls.length; a++) {
          this.yaxisTTEls[a].classList.remove("apexcharts-active");
        }
      }

      e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function (t) {
        var e = t.getAttribute("data:default-text");
        t.innerHTML = decodeURIComponent(e);
      });
    }
  }, {
    key: "markerClick",
    value: function value(t, e, i) {
      var a = this.w;
      "function" == typeof a.config.chart.events.markerClick && a.config.chart.events.markerClick(t, this.ctx, {
        seriesIndex: e,
        dataPointIndex: i,
        w: a
      }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, {
        seriesIndex: e,
        dataPointIndex: i,
        w: a
      }]);
    }
  }, {
    key: "create",
    value: function value(t, e, i, a, s) {
      var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
          n = this.w,
          o = e;
      "mouseup" === t.type && this.markerClick(t, i, a), null === r && (r = this.tConfig.shared);
      var l = this.tooltipUtil.hasMarkers(),
          h = this.tooltipUtil.getElBars();

      if (n.config.legend.tooltipHoverFormatter) {
        var c = n.config.legend.tooltipHoverFormatter,
            d = Array.from(this.legendLabels);
        d.forEach(function (t) {
          var e = t.getAttribute("data:default-text");
          t.innerHTML = decodeURIComponent(e);
        });

        for (var g = 0; g < d.length; g++) {
          var u = d[g],
              f = parseInt(u.getAttribute("i"), 10),
              p = decodeURIComponent(u.getAttribute("data:default-text")),
              x = c(p, {
            seriesIndex: r ? f : i,
            dataPointIndex: a,
            w: n
          });
          if (r) u.innerHTML = n.globals.collapsedSeriesIndices.indexOf(f) < 0 ? x : p;else if (u.innerHTML = f === i ? x : p, i === f) break;
        }
      }

      if (r) {
        if (o.tooltipLabels.drawSeriesTexts({
          ttItems: s,
          i: i,
          j: a,
          shared: !this.showOnIntersect && this.tConfig.shared
        }), l && (n.globals.markers.largestSize > 0 ? o.marker.enlargePoints(a) : o.tooltipPosition.moveDynamicPointsOnHover(a)), this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(h), this.barSeriesHeight > 0)) {
          var m = new b(this.ctx),
              v = n.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a, "']"));
          this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a);

          for (var y = 0; y < v.length; y++) {
            m.pathMouseEnter(v[y]);
          }
        }
      } else o.tooltipLabels.drawSeriesTexts({
        shared: !1,
        ttItems: s,
        i: i,
        j: a
      }), this.tooltipUtil.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(a), l && o.tooltipPosition.moveMarkers(i, a);
    }
  }]), t;
}(),
    mt = function (t) {
  o(s, X);
  var i = d(s);

  function s() {
    return e(this, s), i.apply(this, arguments);
  }

  return a(s, [{
    key: "draw",
    value: function value(t, e) {
      var i = this,
          a = this.w;
      this.graphics = new b(this.ctx), this.bar = new X(this.ctx, this.xyRatios);
      var s = new y(this.ctx, a);
      t = s.getLogSeries(t), this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t), "100%" === a.config.chart.stackType && (t = a.globals.seriesPercent.slice()), this.series = t, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = [];

      for (var r = 0; r < t.length; r++) {
        t[r].length > 0 && (this.totalItems += t[r].length);
      }

      for (var o = this.graphics.group({
        "class": "apexcharts-bar-series apexcharts-plot-series"
      }), l = 0, h = 0, c = function c(s, r) {
        var c = void 0,
            d = void 0,
            g = void 0,
            u = void 0,
            p = [],
            x = [],
            b = a.globals.comboCharts ? e[s] : s;
        i.yRatio.length > 1 && (i.yaxisIndex = b), i.isReversed = a.config.yaxis[i.yaxisIndex] && a.config.yaxis[i.yaxisIndex].reversed;
        var m = i.graphics.group({
          "class": "apexcharts-series",
          seriesName: f.escapeString(a.globals.seriesNames[b]),
          rel: s + 1,
          "data:realIndex": b
        });
        i.ctx.series.addCollapsedClassToSeries(m, b);
        var v = i.graphics.group({
          "class": "apexcharts-datalabels",
          "data:realIndex": b
        }),
            y = 0,
            w = 0,
            k = i.initialPositions(l, h, c, d, g, u);
        h = k.y, y = k.barHeight, d = k.yDivision, u = k.zeroW, l = k.x, w = k.barWidth, c = k.xDivision, g = k.zeroH, i.yArrj = [], i.yArrjF = [], i.yArrjVal = [], i.xArrj = [], i.xArrjF = [], i.xArrjVal = [], 1 === i.prevY.length && i.prevY[0].every(function (t) {
          return isNaN(t);
        }) && (i.prevY[0] = i.prevY[0].map(function (t) {
          return g;
        }), i.prevYF[0] = i.prevYF[0].map(function (t) {
          return 0;
        }));

        for (var A = 0; A < a.globals.dataPoints; A++) {
          var S = i.barHelpers.getStrokeWidth(s, A, b),
              C = {
            indexes: {
              i: s,
              j: A,
              realIndex: b,
              bc: r
            },
            strokeWidth: S,
            x: l,
            y: h,
            elSeries: m
          },
              L = null;
          i.isHorizontal ? (L = i.drawStackedBarPaths(n(n({}, C), {}, {
            zeroW: u,
            barHeight: y,
            yDivision: d
          })), w = i.series[s][A] / i.invertedYRatio) : (L = i.drawStackedColumnPaths(n(n({}, C), {}, {
            xDivision: c,
            barWidth: w,
            zeroH: g
          })), y = i.series[s][A] / i.yRatio[i.yaxisIndex]), h = L.y, l = L.x, p.push(l), x.push(h);
          var P = i.barHelpers.getPathFillColor(t, s, A, b);
          m = i.renderSeries({
            realIndex: b,
            pathFill: P,
            j: A,
            i: s,
            pathFrom: L.pathFrom,
            pathTo: L.pathTo,
            strokeWidth: S,
            elSeries: m,
            x: l,
            y: h,
            series: t,
            barHeight: y,
            barWidth: w,
            elDataLabelsWrap: v,
            type: "bar",
            visibleSeries: 0
          });
        }

        a.globals.seriesXvalues[b] = p, a.globals.seriesYvalues[b] = x, i.prevY.push(i.yArrj), i.prevYF.push(i.yArrjF), i.prevYVal.push(i.yArrjVal), i.prevX.push(i.xArrj), i.prevXF.push(i.xArrjF), i.prevXVal.push(i.xArrjVal), o.add(m);
      }, d = 0, g = 0; d < t.length; d++, g++) {
        c(d, g);
      }

      return o;
    }
  }, {
    key: "initialPositions",
    value: function value(t, e, i, a, s, r) {
      var n,
          o,
          l = this.w;
      return this.isHorizontal ? (n = (n = a = l.globals.gridHeight / l.globals.dataPoints) * parseInt(l.config.plotOptions.bar.barHeight, 10) / 100, r = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e = (a - n) / 2) : (o = i = l.globals.gridWidth / l.globals.dataPoints, o = l.globals.isXNumeric && l.globals.dataPoints > 1 ? (i = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : o * parseInt(l.config.plotOptions.bar.columnWidth, 10) / 100, s = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t = l.globals.padHorizontal + (i - o) / 2), {
        x: t,
        y: e,
        yDivision: a,
        xDivision: i,
        barHeight: n,
        barWidth: o,
        zeroH: s,
        zeroW: r
      };
    }
  }, {
    key: "drawStackedBarPaths",
    value: function value(t) {
      for (var e, i = t.indexes, a = t.barHeight, s = t.strokeWidth, r = t.zeroW, n = t.x, o = t.y, l = t.yDivision, h = t.elSeries, c = this.w, d = o, g = i.i, u = i.j, f = 0, p = 0; p < this.prevXF.length; p++) {
        f += this.prevXF[p][u];
      }

      if (g > 0) {
        var x = r;
        this.prevXVal[g - 1][u] < 0 ? x = this.series[g][u] >= 0 ? this.prevX[g - 1][u] + f - 2 * (this.isReversed ? f : 0) : this.prevX[g - 1][u] : this.prevXVal[g - 1][u] >= 0 && (x = this.series[g][u] >= 0 ? this.prevX[g - 1][u] : this.prevX[g - 1][u] - f + 2 * (this.isReversed ? f : 0)), e = x;
      } else e = r;

      n = null === this.series[g][u] ? e : e + this.series[g][u] / this.invertedYRatio - 2 * (this.isReversed ? this.series[g][u] / this.invertedYRatio : 0);
      var b = this.barHelpers.getBarpaths({
        barYPosition: d,
        barHeight: a,
        x1: e,
        x2: n,
        strokeWidth: s,
        series: this.series,
        realIndex: i.realIndex,
        i: g,
        j: u,
        w: c
      });
      return this.barHelpers.barBackground({
        j: u,
        i: g,
        y1: d,
        y2: a,
        elSeries: h
      }), o += l, {
        pathTo: b.pathTo,
        pathFrom: b.pathFrom,
        x: n,
        y: o
      };
    }
  }, {
    key: "drawStackedColumnPaths",
    value: function value(t) {
      var e = t.indexes,
          i = t.x,
          a = t.y,
          s = t.xDivision,
          r = t.barWidth,
          n = t.zeroH,
          o = (t.strokeWidth, t.elSeries),
          l = this.w,
          h = e.i,
          c = e.j,
          d = e.bc;

      if (l.globals.isXNumeric) {
        var g = l.globals.seriesX[h][c];
        g || (g = 0), i = (g - l.globals.minX) / this.xRatio - r / 2;
      }

      for (var u, f = i, p = 0, x = 0; x < this.prevYF.length; x++) {
        p += isNaN(this.prevYF[x][c]) ? 0 : this.prevYF[x][c];
      }

      if (h > 0 && !l.globals.isXNumeric || h > 0 && l.globals.isXNumeric && l.globals.seriesX[h - 1][c] === l.globals.seriesX[h][c]) {
        var b,
            m,
            v = Math.min(this.yRatio.length + 1, h + 1);
        if (void 0 !== this.prevY[h - 1]) for (var y = 1; y < v; y++) {
          if (!isNaN(this.prevY[h - y][c])) {
            m = this.prevY[h - y][c];
            break;
          }
        }

        for (var w = 1; w < v; w++) {
          if (this.prevYVal[h - w][c] < 0) {
            b = this.series[h][c] >= 0 ? m - p + 2 * (this.isReversed ? p : 0) : m;
            break;
          }

          if (this.prevYVal[h - w][c] >= 0) {
            b = this.series[h][c] >= 0 ? m : m + p - 2 * (this.isReversed ? p : 0);
            break;
          }
        }

        void 0 === b && (b = l.globals.gridHeight), u = this.prevYF[0].every(function (t) {
          return 0 === t;
        }) && this.prevYF.slice(1, h).every(function (t) {
          return t.every(function (t) {
            return isNaN(t);
          });
        }) ? l.globals.gridHeight - n : b;
      } else u = l.globals.gridHeight - n;

      a = u - this.series[h][c] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[h][c] / this.yRatio[this.yaxisIndex] : 0);
      var k = this.barHelpers.getColumnPaths({
        barXPosition: f,
        barWidth: r,
        y1: u,
        y2: a,
        yRatio: this.yRatio[this.yaxisIndex],
        strokeWidth: this.strokeWidth,
        series: this.series,
        realIndex: e.realIndex,
        i: h,
        j: c,
        w: l
      });
      return this.barHelpers.barBackground({
        bc: d,
        j: c,
        i: h,
        x1: f,
        x2: r,
        elSeries: o
      }), i += s, {
        pathTo: k.pathTo,
        pathFrom: k.pathFrom,
        x: l.globals.isXNumeric ? i - s : i,
        y: a
      };
    }
  }]), s;
}(),
    vt = function (t) {
  o(s, X);
  var i = d(s);

  function s() {
    return e(this, s), i.apply(this, arguments);
  }

  return a(s, [{
    key: "draw",
    value: function value(t, e) {
      var i = this,
          a = this.w,
          s = new b(this.ctx),
          r = new L(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot;
      var n = new y(this.ctx, a);
      t = n.getLogSeries(t), this.series = t, this.yRatio = n.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);

      for (var o = s.group({
        "class": "apexcharts-".concat(a.config.chart.type, "-series apexcharts-plot-series")
      }), l = function l(n) {
        i.isBoxPlot = "boxPlot" === a.config.chart.type || "boxPlot" === a.config.series[n].type;
        var l,
            h,
            c = void 0,
            d = void 0,
            g = [],
            u = [],
            p = a.globals.comboCharts ? e[n] : n,
            x = s.group({
          "class": "apexcharts-series",
          seriesName: f.escapeString(a.globals.seriesNames[p]),
          rel: n + 1,
          "data:realIndex": p
        });
        t[n].length > 0 && (i.visibleI = i.visibleI + 1);
        var b, m;
        i.yRatio.length > 1 && (i.yaxisIndex = p);
        var v = i.barHelpers.initialPositions();
        d = v.y, b = v.barHeight, c = v.x, m = v.barWidth, l = v.xDivision, h = v.zeroH, u.push(c + m / 2);

        for (var y = s.group({
          "class": "apexcharts-datalabels",
          "data:realIndex": p
        }), w = function w(e) {
          var s = i.barHelpers.getStrokeWidth(n, e, p),
              o = i.drawBoxPaths({
            indexes: {
              i: n,
              j: e,
              realIndex: p
            },
            x: c,
            y: d,
            xDivision: l,
            barWidth: m,
            zeroH: h,
            strokeWidth: s,
            elSeries: x
          });
          d = o.y, c = o.x, e > 0 && u.push(c + m / 2), g.push(d), o.pathTo.forEach(function (l, h) {
            var g = !i.isBoxPlot && i.candlestickOptions.wick.useFillColor ? o.color[h] : a.globals.stroke.colors[n],
                u = r.fillPath({
              seriesNumber: p,
              dataPointIndex: e,
              color: o.color[h],
              value: t[n][e]
            });
            i.renderSeries({
              realIndex: p,
              pathFill: u,
              lineFill: g,
              j: e,
              i: n,
              pathFrom: o.pathFrom,
              pathTo: l,
              strokeWidth: s,
              elSeries: x,
              x: c,
              y: d,
              series: t,
              barHeight: b,
              barWidth: m,
              elDataLabelsWrap: y,
              visibleSeries: i.visibleI,
              type: a.config.chart.type
            });
          });
        }, k = 0; k < a.globals.dataPoints; k++) {
          w(k);
        }

        a.globals.seriesXvalues[p] = u, a.globals.seriesYvalues[p] = g, o.add(x);
      }, h = 0; h < t.length; h++) {
        l(h);
      }

      return o;
    }
  }, {
    key: "drawBoxPaths",
    value: function value(t) {
      var e = t.indexes,
          i = t.x,
          a = (t.y, t.xDivision),
          s = t.barWidth,
          r = t.zeroH,
          n = t.strokeWidth,
          o = this.w,
          l = new b(this.ctx),
          h = e.i,
          c = e.j,
          d = !0,
          g = o.config.plotOptions.candlestick.colors.upward,
          u = o.config.plotOptions.candlestick.colors.downward,
          f = "";
      this.isBoxPlot && (f = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var p = this.yRatio[this.yaxisIndex],
          x = e.realIndex,
          m = this.getOHLCValue(x, c),
          v = r,
          y = r;
      m.o > m.c && (d = !1);
      var w = Math.min(m.o, m.c),
          k = Math.max(m.o, m.c),
          A = m.m;
      o.globals.isXNumeric && (i = (o.globals.seriesX[x][c] - o.globals.minX) / this.xRatio - s / 2);
      var S = i + s * this.visibleI;
      void 0 === this.series[h][c] || null === this.series[h][c] ? (w = r, k = r) : (w = r - w / p, k = r - k / p, v = r - m.h / p, y = r - m.l / p, A = r - m.m / p);
      var C = l.move(S, r),
          L = l.move(S + s / 2, w);
      return o.globals.previousPaths.length > 0 && (L = this.getPreviousPath(x, c, !0)), C = this.isBoxPlot ? [l.move(S, w) + l.line(S + s / 2, w) + l.line(S + s / 2, v) + l.line(S + s / 4, v) + l.line(S + s - s / 4, v) + l.line(S + s / 2, v) + l.line(S + s / 2, w) + l.line(S + s, w) + l.line(S + s, A) + l.line(S, A) + l.line(S, w + n / 2), l.move(S, A) + l.line(S + s, A) + l.line(S + s, k) + l.line(S + s / 2, k) + l.line(S + s / 2, y) + l.line(S + s - s / 4, y) + l.line(S + s / 4, y) + l.line(S + s / 2, y) + l.line(S + s / 2, k) + l.line(S, k) + l.line(S, A) + "z"] : [l.move(S, k) + l.line(S + s / 2, k) + l.line(S + s / 2, v) + l.line(S + s / 2, k) + l.line(S + s, k) + l.line(S + s, w) + l.line(S + s / 2, w) + l.line(S + s / 2, y) + l.line(S + s / 2, w) + l.line(S, w) + l.line(S, k - n / 2)], L += l.move(S, w), o.globals.isXNumeric || (i += a), {
        pathTo: C,
        pathFrom: L,
        x: i,
        y: k,
        barXPosition: S,
        color: this.isBoxPlot ? f : d ? [g] : [u]
      };
    }
  }, {
    key: "getOHLCValue",
    value: function value(t, e) {
      var i = this.w;
      return {
        o: this.isBoxPlot ? i.globals.seriesCandleH[t][e] : i.globals.seriesCandleO[t][e],
        h: this.isBoxPlot ? i.globals.seriesCandleO[t][e] : i.globals.seriesCandleH[t][e],
        m: i.globals.seriesCandleM[t][e],
        l: this.isBoxPlot ? i.globals.seriesCandleC[t][e] : i.globals.seriesCandleL[t][e],
        c: this.isBoxPlot ? i.globals.seriesCandleL[t][e] : i.globals.seriesCandleC[t][e]
      };
    }
  }]), s;
}(),
    yt = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "checkColorRange",
    value: function value() {
      var t = this.w,
          e = !1,
          i = t.config.plotOptions[t.config.chart.type];
      return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function (t, i) {
        t.from <= 0 && (e = !0);
      }), e;
    }
  }, {
    key: "getShadeColor",
    value: function value(t, e, i, a) {
      var s = this.w,
          r = 1,
          n = s.config.plotOptions[t].shadeIntensity,
          o = this.determineColor(t, e, i);
      s.globals.hasNegs || a ? r = s.config.plotOptions[t].reverseNegativeShade ? o.percent < 0 ? o.percent / 100 * (1.25 * n) : (1 - o.percent / 100) * (1.25 * n) : o.percent <= 0 ? 1 - (1 + o.percent / 100) * n : (1 - o.percent / 100) * n : (r = 1 - o.percent / 100, "treemap" === t && (r = (1 - o.percent / 100) * (1.25 * n)));
      var l = o.color,
          h = new f();
      return s.config.plotOptions[t].enableShades && (r < 0 && (r = 0), l = "dark" === this.w.config.theme.mode ? f.hexToRgba(h.shadeColor(-1 * r, o.color), s.config.fill.opacity) : f.hexToRgba(h.shadeColor(r, o.color), s.config.fill.opacity)), {
        color: l,
        colorProps: o
      };
    }
  }, {
    key: "determineColor",
    value: function value(t, e, i) {
      var a = this.w,
          s = a.globals.series[e][i],
          r = a.config.plotOptions[t],
          n = r.colorScale.inverse ? i : e;
      a.config.plotOptions[t].distributed && (n = i);
      var o = a.globals.colors[n],
          l = null,
          h = Math.min.apply(Math, g(a.globals.series[e])),
          c = Math.max.apply(Math, g(a.globals.series[e]));
      r.distributed || "heatmap" !== t || (h = a.globals.minY, c = a.globals.maxY), void 0 !== r.colorScale.min && (h = r.colorScale.min < a.globals.minY ? r.colorScale.min : a.globals.minY, c = r.colorScale.max > a.globals.maxY ? r.colorScale.max : a.globals.maxY);
      var d = Math.abs(c) + Math.abs(h),
          u = 100 * s / (0 === d ? d - 1e-6 : d);
      r.colorScale.ranges.length > 0 && r.colorScale.ranges.map(function (t, e) {
        if (s >= t.from && s <= t.to) {
          o = t.color, l = t.foreColor ? t.foreColor : null, h = t.from, c = t.to;
          var i = Math.abs(c) + Math.abs(h);
          u = 100 * s / (0 === i ? i - 1e-6 : i);
        }
      });
      return {
        color: o,
        foreColor: l,
        percent: u
      };
    }
  }, {
    key: "calculateDataLabels",
    value: function value(t) {
      var e = t.text,
          i = t.x,
          a = t.y,
          s = t.i,
          r = t.j,
          n = t.colorProps,
          o = t.fontSize,
          l = this.w.config.dataLabels,
          h = new b(this.ctx),
          c = new z(this.ctx),
          d = null;

      if (l.enabled) {
        d = h.group({
          "class": "apexcharts-data-labels"
        });
        var g = l.offsetX,
            u = l.offsetY,
            f = i + g,
            p = a + parseFloat(l.style.fontSize) / 3 + u;
        c.plotDataLabelsText({
          x: f,
          y: p,
          text: e,
          i: s,
          j: r,
          color: n.foreColor,
          parent: d,
          fontSize: o,
          dataLabelsConfig: l
        });
      }

      return d;
    }
  }, {
    key: "addListeners",
    value: function value(t) {
      var e = new b(this.ctx);
      t.node.addEventListener("mouseenter", e.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", e.pathMouseLeave.bind(this, t)), t.node.addEventListener("mousedown", e.pathMouseDown.bind(this, t));
    }
  }]), t;
}(),
    wt = function () {
  function t(i, a) {
    e(this, t), this.ctx = i, this.w = i.w, this.xRatio = a.xRatio, this.yRatio = a.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new yt(i), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }

  return a(t, [{
    key: "draw",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx),
          a = i.group({
        "class": "apexcharts-heatmap"
      });
      a.attr("clip-path", "url(#gridRectMask".concat(e.globals.cuid, ")"));
      var s = e.globals.gridWidth / e.globals.dataPoints,
          r = e.globals.gridHeight / e.globals.series.length,
          n = 0,
          o = !1;
      this.negRange = this.helpers.checkColorRange();
      var l = t.slice();
      e.config.yaxis[0].reversed && (o = !0, l.reverse());

      for (var h = o ? 0 : l.length - 1; o ? h < l.length : h >= 0; o ? h++ : h--) {
        var c = i.group({
          "class": "apexcharts-series apexcharts-heatmap-series",
          seriesName: f.escapeString(e.globals.seriesNames[h]),
          rel: h + 1,
          "data:realIndex": h
        });

        if (this.ctx.series.addCollapsedClassToSeries(c, h), e.config.chart.dropShadow.enabled) {
          var d = e.config.chart.dropShadow;
          new x(this.ctx).dropShadow(c, d, h);
        }

        for (var g = 0, u = e.config.plotOptions.heatmap.shadeIntensity, p = 0; p < l[h].length; p++) {
          var m = this.helpers.getShadeColor(e.config.chart.type, h, p, this.negRange),
              v = m.color,
              y = m.colorProps;
          if ("image" === e.config.fill.type) v = new L(this.ctx).fillPath({
            seriesNumber: h,
            dataPointIndex: p,
            opacity: e.globals.hasNegs ? y.percent < 0 ? 1 - (1 + y.percent / 100) : u + y.percent / 100 : y.percent / 100,
            patternID: f.randomId(),
            width: e.config.fill.image.width ? e.config.fill.image.width : s,
            height: e.config.fill.image.height ? e.config.fill.image.height : r
          });
          var w = this.rectRadius,
              k = i.drawRect(g, n, s, r, w);

          if (k.attr({
            cx: g,
            cy: n
          }), k.node.classList.add("apexcharts-heatmap-rect"), c.add(k), k.attr({
            fill: v,
            i: h,
            index: h,
            j: p,
            val: l[h][p],
            "stroke-width": this.strokeWidth,
            stroke: e.config.plotOptions.heatmap.useFillColorAsStroke ? v : e.globals.stroke.colors[0],
            color: v
          }), this.helpers.addListeners(k), e.config.chart.animations.enabled && !e.globals.dataChanged) {
            var A = 1;
            e.globals.resized || (A = e.config.chart.animations.speed), this.animateHeatMap(k, g, n, s, r, A);
          }

          if (e.globals.dataChanged) {
            var S = 1;

            if (this.dynamicAnim.enabled && e.globals.shouldAnimate) {
              S = this.dynamicAnim.speed;
              var C = e.globals.previousPaths[h] && e.globals.previousPaths[h][p] && e.globals.previousPaths[h][p].color;
              C || (C = "rgba(255, 255, 255, 0)"), this.animateHeatColor(k, f.isColorHex(C) ? C : f.rgb2hex(C), f.isColorHex(v) ? v : f.rgb2hex(v), S);
            }
          }

          var P = (0, e.config.dataLabels.formatter)(e.globals.series[h][p], {
            value: e.globals.series[h][p],
            seriesIndex: h,
            dataPointIndex: p,
            w: e
          }),
              T = this.helpers.calculateDataLabels({
            text: P,
            x: g + s / 2,
            y: n + r / 2,
            i: h,
            j: p,
            colorProps: y,
            series: l
          });
          null !== T && c.add(T), g += s;
        }

        n += r, a.add(c);
      }

      var z = e.globals.yAxisScale[0].result.slice();
      e.config.yaxis[0].reversed ? z.unshift("") : z.push(""), e.globals.yAxisScale[0].result = z;
      var I = e.globals.gridHeight / e.globals.series.length;
      return e.config.yaxis[0].labels.offsetY = -I / 2, a;
    }
  }, {
    key: "animateHeatMap",
    value: function value(t, e, i, a, s, r) {
      var n = new p(this.ctx);
      n.animateRect(t, {
        x: e + a / 2,
        y: i + s / 2,
        width: 0,
        height: 0
      }, {
        x: e,
        y: i,
        width: a,
        height: s
      }, r, function () {
        n.animationCompleted(t);
      });
    }
  }, {
    key: "animateHeatColor",
    value: function value(t, e, i, a) {
      t.attr({
        fill: e
      }).animate(a).attr({
        fill: i
      });
    }
  }]), t;
}(),
    kt = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "drawYAxisTexts",
    value: function value(t, e, i, a) {
      var s = this.w,
          r = s.config.yaxis[0],
          n = s.globals.yLabelFormatters[0];
      return new b(this.ctx).drawText({
        x: t + r.labels.offsetX,
        y: e + r.labels.offsetY,
        text: n(a, i),
        textAnchor: "middle",
        fontSize: r.labels.style.fontSize,
        fontFamily: r.labels.style.fontFamily,
        foreColor: Array.isArray(r.labels.style.colors) ? r.labels.style.colors[i] : r.labels.style.colors
      });
    }
  }]), t;
}(),
    At = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
    var a = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== a.globals.stroke.colors ? a.globals.stroke.colors : a.globals.colors, this.defaultSize = Math.min(a.globals.gridWidth, a.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = a.globals.gridWidth / 2, "radialBar" === a.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(a.config.plotOptions.pie.endAngle - a.config.plotOptions.pie.startAngle), this.initialAngle = a.config.plotOptions.pie.startAngle % this.fullAngle, a.globals.radialSize = this.defaultSize / 2.05 - a.config.stroke.width - (a.config.chart.sparkline.enabled ? 0 : a.config.chart.dropShadow.blur), this.donutSize = a.globals.radialSize * parseInt(a.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }

  return a(t, [{
    key: "draw",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = new b(this.ctx);
      if (this.ret = a.group({
        "class": "apexcharts-pie"
      }), i.globals.noData) return this.ret;

      for (var s = 0, r = 0; r < t.length; r++) {
        s += f.negToZero(t[r]);
      }

      var n = [],
          o = a.group();
      0 === s && (s = 1e-5), t.forEach(function (t) {
        e.maxY = Math.max(e.maxY, t);
      }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), "back" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);

      for (var l = 0; l < t.length; l++) {
        var h = this.fullAngle * f.negToZero(t[l]) / s;
        n.push(h), "polarArea" === this.chartType ? (n[l] = this.fullAngle / t.length, this.sliceSizes.push(i.globals.radialSize * t[l] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
      }

      if (i.globals.dataChanged) {
        for (var c, d = 0, g = 0; g < i.globals.previousPaths.length; g++) {
          d += f.negToZero(i.globals.previousPaths[g]);
        }

        for (var u = 0; u < i.globals.previousPaths.length; u++) {
          c = this.fullAngle * f.negToZero(i.globals.previousPaths[u]) / d, this.prevSectorAngleArr.push(c);
        }
      }

      this.donutSize < 0 && (this.donutSize = 0);
      var p = i.config.plotOptions.pie.customScale,
          x = i.globals.gridWidth / 2,
          m = i.globals.gridHeight / 2,
          v = x - i.globals.gridWidth / 2 * p,
          y = m - i.globals.gridHeight / 2 * p;

      if ("donut" === this.chartType) {
        var w = a.drawCircle(this.donutSize);
        w.attr({
          cx: this.centerX,
          cy: this.centerY,
          fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent"
        }), o.add(w);
      }

      var k = this.drawArcs(n, t);

      if (this.sliceLabels.forEach(function (t) {
        k.add(t);
      }), o.attr({
        transform: "translate(".concat(v, ", ").concat(y, ") scale(").concat(p, ")")
      }), o.add(k), this.ret.add(o), this.donutDataLabels.show) {
        var A = this.renderInnerDataLabels(this.donutDataLabels, {
          hollowSize: this.donutSize,
          centerX: this.centerX,
          centerY: this.centerY,
          opacity: this.donutDataLabels.show,
          translateX: v,
          translateY: y
        });
        this.ret.add(A);
      }

      return "front" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret), this.ret;
    }
  }, {
    key: "drawArcs",
    value: function value(t, e) {
      var i = this.w,
          a = new x(this.ctx),
          s = new b(this.ctx),
          r = new L(this.ctx),
          n = s.group({
        "class": "apexcharts-slices"
      }),
          o = this.initialAngle,
          l = this.initialAngle,
          h = this.initialAngle,
          c = this.initialAngle;
      this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;

      for (var d = 0; d < t.length; d++) {
        var g = s.group({
          "class": "apexcharts-series apexcharts-pie-series",
          seriesName: f.escapeString(i.globals.seriesNames[d]),
          rel: d + 1,
          "data:realIndex": d
        });
        n.add(g), l = c, h = (o = h) + t[d], c = l + this.prevSectorAngleArr[d];
        var u = h < o ? this.fullAngle + h - o : h - o,
            p = r.fillPath({
          seriesNumber: d,
          size: this.sliceSizes[d],
          value: e[d]
        }),
            m = this.getChangedPath(l, c),
            v = s.drawPath({
          d: m,
          stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d] : this.lineColorArr,
          strokeWidth: 0,
          fill: p,
          fillOpacity: i.config.fill.opacity,
          classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d)
        });

        if (v.attr({
          index: 0,
          j: d
        }), a.setSelectionFilter(v, 0, d), i.config.chart.dropShadow.enabled) {
          var y = i.config.chart.dropShadow;
          a.dropShadow(v, y, d);
        }

        this.addListeners(v, this.donutDataLabels), b.setAttrs(v.node, {
          "data:angle": u,
          "data:startAngle": o,
          "data:strokeWidth": this.strokeWidth,
          "data:value": e[d]
        });
        var w = {
          x: 0,
          y: 0
        };
        "pie" === this.chartType || "polarArea" === this.chartType ? w = f.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (o + u / 2) % this.fullAngle) : "donut" === this.chartType && (w = f.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (o + u / 2) % this.fullAngle)), g.add(v);
        var k = 0;

        if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (k = u / this.fullAngle * i.config.chart.animations.speed) && (k = 1), this.animDur = k + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(v, {
          size: this.sliceSizes[d],
          endAngle: h,
          startAngle: o,
          prevStartAngle: l,
          prevEndAngle: c,
          animateStartingPos: !0,
          i: d,
          animBeginArr: this.animBeginArr,
          shouldSetPrevPaths: !0,
          dur: i.config.chart.animations.dynamicAnimation.speed
        }) : this.animatePaths(v, {
          size: this.sliceSizes[d],
          endAngle: h,
          startAngle: o,
          i: d,
          totalItems: t.length - 1,
          animBeginArr: this.animBeginArr,
          dur: k
        }), i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && v.click(this.pieClicked.bind(this, d)), void 0 !== i.globals.selectedDataPoints[0] && i.globals.selectedDataPoints[0].indexOf(d) > -1 && this.pieClicked(d), i.config.dataLabels.enabled) {
          var A = w.x,
              S = w.y,
              C = 100 * u / this.fullAngle + "%";

          if (0 !== u && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[d]) {
            var P = i.config.dataLabels.formatter;
            void 0 !== P && (C = P(i.globals.seriesPercent[d][0], {
              seriesIndex: d,
              w: i
            }));
            var T = i.globals.dataLabels.style.colors[d],
                z = s.group({
              "class": "apexcharts-datalabels"
            }),
                I = s.drawText({
              x: A,
              y: S,
              text: C,
              textAnchor: "middle",
              fontSize: i.config.dataLabels.style.fontSize,
              fontFamily: i.config.dataLabels.style.fontFamily,
              fontWeight: i.config.dataLabels.style.fontWeight,
              foreColor: T
            });

            if (z.add(I), i.config.dataLabels.dropShadow.enabled) {
              var M = i.config.dataLabels.dropShadow;
              a.dropShadow(I, M);
            }

            I.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && !1 === i.globals.resized && (I.node.classList.add("apexcharts-pie-label-delay"), I.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(z);
          }
        }
      }

      return n;
    }
  }, {
    key: "addListeners",
    value: function value(t, e) {
      var i = new b(this.ctx);
      t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, e)));
    }
  }, {
    key: "animatePaths",
    value: function value(t, e) {
      var i = this.w,
          a = e.endAngle < e.startAngle ? this.fullAngle + e.endAngle - e.startAngle : e.endAngle - e.startAngle,
          s = a,
          r = e.startAngle,
          n = e.startAngle;
      void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (r = e.prevEndAngle, s = e.prevEndAngle < e.prevStartAngle ? this.fullAngle + e.prevEndAngle - e.prevStartAngle : e.prevEndAngle - e.prevStartAngle), e.i === i.config.series.length - 1 && (a + n > this.fullAngle ? e.endAngle = e.endAngle - (a + n) : a + n < this.fullAngle && (e.endAngle = e.endAngle + (this.fullAngle - (a + n)))), a === this.fullAngle && (a = this.fullAngle - .01), this.animateArc(t, r, n, a, s, e);
    }
  }, {
    key: "animateArc",
    value: function value(t, e, i, a, s, r) {
      var n,
          o = this,
          l = this.w,
          h = new p(this.ctx),
          c = r.size;
      (isNaN(e) || isNaN(s)) && (e = i, s = a, r.dur = 0);
      var d = a,
          g = i,
          u = e < i ? this.fullAngle + e - i : e - i;
      l.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (n = o.getPiePath({
        me: o,
        startAngle: r.prevStartAngle,
        angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle,
        size: c
      }), t.attr({
        d: n
      })), 0 !== r.dur ? t.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll(function () {
        "pie" !== o.chartType && "donut" !== o.chartType && "polarArea" !== o.chartType || this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({
          "stroke-width": o.strokeWidth
        }), r.i === l.config.series.length - 1 && h.animationCompleted(t);
      }).during(function (l) {
        d = u + (a - u) * l, r.animateStartingPos && (d = s + (a - s) * l, g = e - s + (i - (e - s)) * l), n = o.getPiePath({
          me: o,
          startAngle: g,
          angle: d,
          size: c
        }), t.node.setAttribute("data:pathOrig", n), t.attr({
          d: n
        });
      }) : (n = o.getPiePath({
        me: o,
        startAngle: g,
        angle: a,
        size: c
      }), r.isTrack || (l.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", n), t.attr({
        d: n,
        "stroke-width": o.strokeWidth
      }));
    }
  }, {
    key: "pieClicked",
    value: function value(t) {
      var e,
          i = this.w,
          a = this,
          s = a.sliceSizes[t] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0),
          r = i.globals.dom.Paper.select(".apexcharts-".concat(a.chartType.toLowerCase(), "-slice-").concat(t)).members[0];

      if ("true" !== r.attr("data:pieClicked")) {
        var n = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
        Array.prototype.forEach.call(n, function (t) {
          t.setAttribute("data:pieClicked", "false");
          var e = t.getAttribute("data:pathOrig");
          t.setAttribute("d", e);
        }), r.attr("data:pieClicked", "true");
        var o = parseInt(r.attr("data:startAngle"), 10),
            l = parseInt(r.attr("data:angle"), 10);
        e = a.getPiePath({
          me: a,
          startAngle: o,
          angle: l,
          size: s
        }), 360 !== l && r.plot(e);
      } else {
        r.attr({
          "data:pieClicked": "false"
        }), this.revertDataLabelsInner(r.node, this.donutDataLabels);
        var h = r.attr("data:pathOrig");
        r.attr({
          d: h
        });
      }
    }
  }, {
    key: "getChangedPath",
    value: function value(t, e) {
      var i = "";
      return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
        me: this,
        startAngle: t,
        angle: e - t,
        size: this.size
      })), i;
    }
  }, {
    key: "getPiePath",
    value: function value(t) {
      var e = t.me,
          i = t.startAngle,
          a = t.angle,
          s = t.size,
          r = i,
          n = Math.PI * (r - 90) / 180,
          o = a + i;
      Math.ceil(o) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (o = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(o) > this.fullAngle && (o -= this.fullAngle);
      var l = Math.PI * (o - 90) / 180,
          h = e.centerX + s * Math.cos(n),
          c = e.centerY + s * Math.sin(n),
          d = e.centerX + s * Math.cos(l),
          g = e.centerY + s * Math.sin(l),
          u = f.polarToCartesian(e.centerX, e.centerY, e.donutSize, o),
          p = f.polarToCartesian(e.centerX, e.centerY, e.donutSize, r),
          x = a > 180 ? 1 : 0,
          b = ["M", h, c, "A", s, s, 0, x, 1, d, g];
      return "donut" === e.chartType ? [].concat(b, ["L", u.x, u.y, "A", e.donutSize, e.donutSize, 0, x, 0, p.x, p.y, "L", h, c, "z"]).join(" ") : "pie" === e.chartType || "polarArea" === e.chartType ? [].concat(b, ["L", e.centerX, e.centerY, "L", h, c]).join(" ") : [].concat(b).join(" ");
    }
  }, {
    key: "drawPolarElements",
    value: function value(t) {
      var e = this.w,
          i = new j(this.ctx),
          a = new b(this.ctx),
          s = new kt(this.ctx),
          r = a.group(),
          n = a.group(),
          o = i.niceScale(0, Math.ceil(this.maxY), e.config.yaxis[0].tickAmount, 0, !0),
          l = o.result.reverse(),
          h = o.result.length;
      this.maxY = o.niceMax;

      for (var c = e.globals.radialSize, d = c / (h - 1), g = 0; g < h - 1; g++) {
        var u = a.drawCircle(c);

        if (u.attr({
          cx: this.centerX,
          cy: this.centerY,
          fill: "none",
          "stroke-width": e.config.plotOptions.polarArea.rings.strokeWidth,
          stroke: e.config.plotOptions.polarArea.rings.strokeColor
        }), e.config.yaxis[0].show) {
          var f = s.drawYAxisTexts(this.centerX, this.centerY - c + parseInt(e.config.yaxis[0].labels.style.fontSize, 10) / 2, g, l[g]);
          n.add(f);
        }

        r.add(u), c -= d;
      }

      this.drawSpokes(t), t.add(r), t.add(n);
    }
  }, {
    key: "renderInnerDataLabels",
    value: function value(t, e) {
      var i = this.w,
          a = new b(this.ctx),
          s = a.group({
        "class": "apexcharts-datalabels-group",
        transform: "translate(".concat(e.translateX ? e.translateX : 0, ", ").concat(e.translateY ? e.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")")
      }),
          r = t.total.show;
      s.node.style.opacity = e.opacity;
      var n,
          o,
          l = e.centerX,
          h = e.centerY;
      n = void 0 === t.name.color ? i.globals.colors[0] : t.name.color;
      var c = t.name.fontSize,
          d = t.name.fontFamily,
          g = t.value.fontWeight;
      o = void 0 === t.value.color ? i.config.chart.foreColor : t.value.color;
      var u = t.value.formatter,
          f = "",
          p = "";

      if (r ? (n = t.total.color, c = t.total.fontSize, d = t.total.fontFamily, g = t.total.fontWeight, p = t.total.label, f = t.total.formatter(i)) : 1 === i.globals.series.length && (f = u(i.globals.series[0], i), p = i.globals.seriesNames[0]), p && (p = t.name.formatter(p, t.total.show, i)), t.name.show) {
        var x = a.drawText({
          x: l,
          y: h + parseFloat(t.name.offsetY),
          text: p,
          textAnchor: "middle",
          foreColor: n,
          fontSize: c,
          fontWeight: g,
          fontFamily: d
        });
        x.node.classList.add("apexcharts-datalabel-label"), s.add(x);
      }

      if (t.value.show) {
        var m = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY,
            v = a.drawText({
          x: l,
          y: h + m,
          text: f,
          textAnchor: "middle",
          foreColor: o,
          fontWeight: t.value.fontWeight,
          fontSize: t.value.fontSize,
          fontFamily: t.value.fontFamily
        });
        v.node.classList.add("apexcharts-datalabel-value"), s.add(v);
      }

      return s;
    }
  }, {
    key: "printInnerLabels",
    value: function value(t, e, i, a) {
      var s,
          r = this.w;
      a ? s = void 0 === t.name.color ? r.globals.colors[parseInt(a.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : r.globals.series.length > 1 && t.total.show && (s = t.total.color);
      var n = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),
          o = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
      i = (0, t.value.formatter)(i, r), a || "function" != typeof t.total.formatter || (i = t.total.formatter(r));
      var l = e === t.total.label;
      e = t.name.formatter(e, l, r), null !== n && (n.textContent = e), null !== o && (o.textContent = i), null !== n && (n.style.fill = s);
    }
  }, {
    key: "printDataLabelsInner",
    value: function value(t, e) {
      var i = this.w,
          a = t.getAttribute("data:value"),
          s = i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
      i.globals.series.length > 1 && this.printInnerLabels(e, s, a, t);
      var r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
      null !== r && (r.style.opacity = 1);
    }
  }, {
    key: "drawSpokes",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = new b(this.ctx),
          s = i.config.plotOptions.polarArea.spokes;

      if (0 !== s.strokeWidth) {
        for (var r = [], n = 360 / i.globals.series.length, o = 0; o < i.globals.series.length; o++) {
          r.push(f.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + n * o));
        }

        r.forEach(function (i, r) {
          var n = a.drawLine(i.x, i.y, e.centerX, e.centerY, Array.isArray(s.connectorColors) ? s.connectorColors[r] : s.connectorColors);
          t.add(n);
        });
      }
    }
  }, {
    key: "revertDataLabelsInner",
    value: function value(t, e, i) {
      var a = this,
          s = this.w,
          r = s.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),
          n = !1,
          o = s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),
          l = function l(t) {
        var i = t.makeSliceOut,
            s = t.printLabel;
        Array.prototype.forEach.call(o, function (t) {
          "true" === t.getAttribute("data:pieClicked") && (i && (n = !0), s && a.printDataLabelsInner(t, e));
        });
      };

      if (l({
        makeSliceOut: !0,
        printLabel: !1
      }), e.total.show && s.globals.series.length > 1) n && !e.total.showAlways ? l({
        makeSliceOut: !1,
        printLabel: !0
      }) : this.printInnerLabels(e, e.total.label, e.total.formatter(s));else if (l({
        makeSliceOut: !1,
        printLabel: !0
      }), !n) if (s.globals.selectedDataPoints.length && s.globals.series.length > 1) {
        if (s.globals.selectedDataPoints[0].length > 0) {
          var h = s.globals.selectedDataPoints[0],
              c = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(h));
          this.printDataLabelsInner(c, e);
        } else r && s.globals.selectedDataPoints.length && 0 === s.globals.selectedDataPoints[0].length && (r.style.opacity = 0);
      } else r && s.globals.series.length > 1 && (r.style.opacity = 0);
    }
  }]), t;
}(),
    St = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var a = this.w;
    this.graphics = new b(this.ctx), this.lineColorArr = void 0 !== a.globals.stroke.colors ? a.globals.stroke.colors : a.globals.colors, this.defaultSize = a.globals.svgHeight < a.globals.svgWidth ? a.globals.gridHeight + 1.5 * a.globals.goldenPadding : a.globals.gridWidth, this.isLog = a.config.yaxis[0].logarithmic, this.coreUtils = new y(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(a.globals.maxY, 0) : a.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : a.globals.minY, this.polygons = a.config.plotOptions.radar.polygons, this.strokeWidth = a.config.stroke.show ? a.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a.config.chart.dropShadow.blur, a.config.xaxis.labels.show && (this.size = this.size - a.globals.xAxisLabelsWidth / 1.75), void 0 !== a.config.plotOptions.radar.size && (this.size = a.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }

  return a(t, [{
    key: "draw",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = new L(this.ctx),
          s = [],
          r = new z(this.ctx);
      t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
      var o = i.globals.gridWidth / 2,
          l = i.globals.gridHeight / 2,
          h = o + i.config.plotOptions.radar.offsetX,
          c = l + i.config.plotOptions.radar.offsetY,
          d = this.graphics.group({
        "class": "apexcharts-radar-series apexcharts-plot-series",
        transform: "translate(".concat(h || 0, ", ").concat(c || 0, ")")
      }),
          g = [],
          u = null,
          p = null;

      if (this.yaxisLabels = this.graphics.group({
        "class": "apexcharts-yaxis"
      }), t.forEach(function (t, o) {
        var l = t.length === i.globals.dataPoints,
            h = e.graphics.group().attr({
          "class": "apexcharts-series",
          "data:longestSeries": l,
          seriesName: f.escapeString(i.globals.seriesNames[o]),
          rel: o + 1,
          "data:realIndex": o
        });
        e.dataRadiusOfPercent[o] = [], e.dataRadius[o] = [], e.angleArr[o] = [], t.forEach(function (t, i) {
          var a = Math.abs(e.maxValue - e.minValue);
          t += Math.abs(e.minValue), e.isLog && (t = e.coreUtils.getLogVal(t, 0)), e.dataRadiusOfPercent[o][i] = t / a, e.dataRadius[o][i] = e.dataRadiusOfPercent[o][i] * e.size, e.angleArr[o][i] = i * e.disAngle;
        }), g = e.getDataPointsPos(e.dataRadius[o], e.angleArr[o]);
        var c = e.createPaths(g, {
          x: 0,
          y: 0
        });
        u = e.graphics.group({
          "class": "apexcharts-series-markers-wrap apexcharts-element-hidden"
        }), p = e.graphics.group({
          "class": "apexcharts-datalabels",
          "data:realIndex": o
        }), i.globals.delayedElements.push({
          el: u.node,
          index: o
        });
        var d = {
          i: o,
          realIndex: o,
          animationDelay: o,
          initialSpeed: i.config.chart.animations.speed,
          dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-radar",
          shouldClipToGrid: !1,
          bindEventsOnPaths: !1,
          stroke: i.globals.stroke.colors[o],
          strokeLineCap: i.config.stroke.lineCap
        },
            b = null;
        i.globals.previousPaths.length > 0 && (b = e.getPreviousPath(o));

        for (var m = 0; m < c.linePathsTo.length; m++) {
          var v = e.graphics.renderPaths(n(n({}, d), {}, {
            pathFrom: null === b ? c.linePathsFrom[m] : b,
            pathTo: c.linePathsTo[m],
            strokeWidth: Array.isArray(e.strokeWidth) ? e.strokeWidth[o] : e.strokeWidth,
            fill: "none",
            drawShadow: !1
          }));
          h.add(v);
          var y = a.fillPath({
            seriesNumber: o
          }),
              w = e.graphics.renderPaths(n(n({}, d), {}, {
            pathFrom: null === b ? c.areaPathsFrom[m] : b,
            pathTo: c.areaPathsTo[m],
            strokeWidth: 0,
            fill: y,
            drawShadow: !1
          }));

          if (i.config.chart.dropShadow.enabled) {
            var k = new x(e.ctx),
                A = i.config.chart.dropShadow;
            k.dropShadow(w, Object.assign({}, A, {
              noUserSpaceOnUse: !0
            }), o);
          }

          h.add(w);
        }

        t.forEach(function (t, a) {
          var s = new P(e.ctx).getMarkerConfig("apexcharts-marker", o, a),
              l = e.graphics.drawMarker(g[a].x, g[a].y, s);
          l.attr("rel", a), l.attr("j", a), l.attr("index", o), l.node.setAttribute("default-marker-size", s.pSize);
          var c = e.graphics.group({
            "class": "apexcharts-series-markers"
          });
          c && c.add(l), u.add(c), h.add(u);
          var d = i.config.dataLabels;

          if (d.enabled) {
            var f = d.formatter(i.globals.series[o][a], {
              seriesIndex: o,
              dataPointIndex: a,
              w: i
            });
            r.plotDataLabelsText({
              x: g[a].x,
              y: g[a].y,
              text: f,
              textAnchor: "middle",
              i: o,
              j: o,
              parent: p,
              offsetCorrection: !1,
              dataLabelsConfig: n({}, d)
            });
          }

          h.add(p);
        }), s.push(h);
      }), this.drawPolygons({
        parent: d
      }), i.config.xaxis.labels.show) {
        var b = this.drawXAxisTexts();
        d.add(b);
      }

      return s.forEach(function (t) {
        d.add(t);
      }), d.add(this.yaxisLabels), d;
    }
  }, {
    key: "drawPolygons",
    value: function value(t) {
      for (var e = this, i = this.w, a = t.parent, s = new kt(this.ctx), r = i.globals.yAxisScale[0].result.reverse(), n = r.length, o = [], l = this.size / (n - 1), h = 0; h < n; h++) {
        o[h] = l * h;
      }

      o.reverse();
      var c = [],
          d = [];
      o.forEach(function (t, i) {
        var a = f.getPolygonPos(t, e.dataPointsLen),
            s = "";
        a.forEach(function (t, a) {
          if (0 === i) {
            var r = e.graphics.drawLine(t.x, t.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[a] : e.polygons.connectorColors);
            d.push(r);
          }

          0 === a && e.yaxisLabelsTextsPos.push({
            x: t.x,
            y: t.y
          }), s += t.x + "," + t.y + " ";
        }), c.push(s);
      }), c.forEach(function (t, s) {
        var r = e.polygons.strokeColors,
            n = e.polygons.strokeWidth,
            o = e.graphics.drawPolygon(t, Array.isArray(r) ? r[s] : r, Array.isArray(n) ? n[s] : n, i.globals.radarPolygons.fill.colors[s]);
        a.add(o);
      }), d.forEach(function (t) {
        a.add(t);
      }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function (t, i) {
        var a = s.drawYAxisTexts(t.x, t.y, i, r[i]);
        e.yaxisLabels.add(a);
      });
    }
  }, {
    key: "drawXAxisTexts",
    value: function value() {
      var t = this,
          e = this.w,
          i = e.config.xaxis.labels,
          a = this.graphics.group({
        "class": "apexcharts-xaxis"
      }),
          s = f.getPolygonPos(this.size, this.dataPointsLen);
      return e.globals.labels.forEach(function (r, o) {
        var l = e.config.xaxis.labels.formatter,
            h = new z(t.ctx);

        if (s[o]) {
          var c = t.getTextPos(s[o], t.size),
              d = l(r, {
            seriesIndex: -1,
            dataPointIndex: o,
            w: e
          });
          h.plotDataLabelsText({
            x: c.newX,
            y: c.newY,
            text: d,
            textAnchor: c.textAnchor,
            i: o,
            j: o,
            parent: a,
            color: Array.isArray(i.style.colors) && i.style.colors[o] ? i.style.colors[o] : "#a8a8a8",
            dataLabelsConfig: n({
              textAnchor: c.textAnchor,
              dropShadow: {
                enabled: !1
              }
            }, i),
            offsetCorrection: !1
          });
        }
      }), a;
    }
  }, {
    key: "createPaths",
    value: function value(t, e) {
      var i = this,
          a = [],
          s = [],
          r = [],
          n = [];

      if (t.length) {
        s = [this.graphics.move(e.x, e.y)], n = [this.graphics.move(e.x, e.y)];
        var o = this.graphics.move(t[0].x, t[0].y),
            l = this.graphics.move(t[0].x, t[0].y);
        t.forEach(function (e, a) {
          o += i.graphics.line(e.x, e.y), l += i.graphics.line(e.x, e.y), a === t.length - 1 && (o += "Z", l += "Z");
        }), a.push(o), r.push(l);
      }

      return {
        linePathsFrom: s,
        linePathsTo: a,
        areaPathsFrom: n,
        areaPathsTo: r
      };
    }
  }, {
    key: "getTextPos",
    value: function value(t, e) {
      var i = "middle",
          a = t.x,
          s = t.y;
      return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = "start", a += 10) : t.x < 0 && (i = "end", a -= 10) : i = "middle", Math.abs(t.y) >= e - 10 && (t.y < 0 ? s -= 10 : t.y > 0 && (s += 10)), {
        textAnchor: i,
        newX: a,
        newY: s
      };
    }
  }, {
    key: "getPreviousPath",
    value: function value(t) {
      for (var e = this.w, i = null, a = 0; a < e.globals.previousPaths.length; a++) {
        var s = e.globals.previousPaths[a];
        s.paths.length > 0 && parseInt(s.realIndex, 10) === parseInt(t, 10) && void 0 !== e.globals.previousPaths[a].paths[0] && (i = e.globals.previousPaths[a].paths[0].d);
      }

      return i;
    }
  }, {
    key: "getDataPointsPos",
    value: function value(t, e) {
      var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
      t = t || [], e = e || [];

      for (var a = [], s = 0; s < i; s++) {
        var r = {};
        r.x = t[s] * Math.sin(e[s]), r.y = -t[s] * Math.cos(e[s]), a.push(r);
      }

      return a;
    }
  }]), t;
}(),
    Ct = function (t) {
  o(s, At);
  var i = d(s);

  function s(t) {
    var a;
    e(this, s), (a = i.call(this, t)).ctx = t, a.w = t.w, a.animBeginArr = [0], a.animDur = 0;
    var r = a.w;
    return a.startAngle = r.config.plotOptions.radialBar.startAngle, a.endAngle = r.config.plotOptions.radialBar.endAngle, a.totalAngle = Math.abs(r.config.plotOptions.radialBar.endAngle - r.config.plotOptions.radialBar.startAngle), a.trackStartAngle = r.config.plotOptions.radialBar.track.startAngle, a.trackEndAngle = r.config.plotOptions.radialBar.track.endAngle, a.radialDataLabels = r.config.plotOptions.radialBar.dataLabels, a.trackStartAngle || (a.trackStartAngle = a.startAngle), a.trackEndAngle || (a.trackEndAngle = a.endAngle), 360 === a.endAngle && (a.endAngle = 359.99), a.margin = parseInt(r.config.plotOptions.radialBar.track.margin, 10), a;
  }

  return a(s, [{
    key: "draw",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx),
          a = i.group({
        "class": "apexcharts-radialbar"
      });
      if (e.globals.noData) return a;
      var s = i.group(),
          r = this.defaultSize / 2,
          n = e.globals.gridWidth / 2,
          o = this.defaultSize / 2.05;
      e.config.chart.sparkline.enabled || (o = o - e.config.stroke.width - e.config.chart.dropShadow.blur);
      var l = e.globals.fill.colors;

      if (e.config.plotOptions.radialBar.track.show) {
        var h = this.drawTracks({
          size: o,
          centerX: n,
          centerY: r,
          colorArr: l,
          series: t
        });
        s.add(h);
      }

      var c = this.drawArcs({
        size: o,
        centerX: n,
        centerY: r,
        colorArr: l,
        series: t
      }),
          d = 360;
      e.config.plotOptions.radialBar.startAngle < 0 && (d = this.totalAngle);
      var g = (360 - d) / 360;

      if (e.globals.radialSize = o - o * g, this.radialDataLabels.value.show) {
        var u = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
        e.globals.radialSize += u * g;
      }

      return s.add(c.g), "front" === e.config.plotOptions.radialBar.hollow.position && (c.g.add(c.elHollow), c.dataLabels && c.g.add(c.dataLabels)), a.add(s), a;
    }
  }, {
    key: "drawTracks",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx),
          a = i.group({
        "class": "apexcharts-tracks"
      }),
          s = new x(this.ctx),
          r = new L(this.ctx),
          n = this.getStrokeWidth(t);
      t.size = t.size - n / 2;

      for (var o = 0; o < t.series.length; o++) {
        var l = i.group({
          "class": "apexcharts-radialbar-track apexcharts-track"
        });
        a.add(l), l.attr({
          rel: o + 1
        }), t.size = t.size - n - this.margin;
        var h = e.config.plotOptions.radialBar.track,
            c = r.fillPath({
          seriesNumber: 0,
          size: t.size,
          fillColors: Array.isArray(h.background) ? h.background[o] : h.background,
          solid: !0
        }),
            d = this.trackStartAngle,
            g = this.trackEndAngle;
        Math.abs(g) + Math.abs(d) >= 360 && (g = 360 - Math.abs(this.startAngle) - .1);
        var u = i.drawPath({
          d: "",
          stroke: c,
          strokeWidth: n * parseInt(h.strokeWidth, 10) / 100,
          fill: "none",
          strokeOpacity: h.opacity,
          classes: "apexcharts-radialbar-area"
        });

        if (h.dropShadow.enabled) {
          var f = h.dropShadow;
          s.dropShadow(u, f);
        }

        l.add(u), u.attr("id", "apexcharts-radialbarTrack-" + o), this.animatePaths(u, {
          centerX: t.centerX,
          centerY: t.centerY,
          endAngle: g,
          startAngle: d,
          size: t.size,
          i: o,
          totalItems: 2,
          animBeginArr: 0,
          dur: 0,
          isTrack: !0,
          easing: e.globals.easing
        });
      }

      return a;
    }
  }, {
    key: "drawArcs",
    value: function value(t) {
      var e = this.w,
          i = new b(this.ctx),
          a = new L(this.ctx),
          s = new x(this.ctx),
          r = i.group(),
          n = this.getStrokeWidth(t);
      t.size = t.size - n / 2;
      var o = e.config.plotOptions.radialBar.hollow.background,
          l = t.size - n * t.series.length - this.margin * t.series.length - n * parseInt(e.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2,
          h = l - e.config.plotOptions.radialBar.hollow.margin;
      void 0 !== e.config.plotOptions.radialBar.hollow.image && (o = this.drawHollowImage(t, r, l, o));
      var c = this.drawHollow({
        size: h,
        centerX: t.centerX,
        centerY: t.centerY,
        fill: o || "transparent"
      });

      if (e.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var d = e.config.plotOptions.radialBar.hollow.dropShadow;
        s.dropShadow(c, d);
      }

      var g = 1;
      !this.radialDataLabels.total.show && e.globals.series.length > 1 && (g = 0);
      var u = null;
      this.radialDataLabels.show && (u = this.renderInnerDataLabels(this.radialDataLabels, {
        hollowSize: l,
        centerX: t.centerX,
        centerY: t.centerY,
        opacity: g
      })), "back" === e.config.plotOptions.radialBar.hollow.position && (r.add(c), u && r.add(u));
      var p = !1;
      e.config.plotOptions.radialBar.inverseOrder && (p = !0);

      for (var m = p ? t.series.length - 1 : 0; p ? m >= 0 : m < t.series.length; p ? m-- : m++) {
        var v = i.group({
          "class": "apexcharts-series apexcharts-radial-series",
          seriesName: f.escapeString(e.globals.seriesNames[m])
        });
        r.add(v), v.attr({
          rel: m + 1,
          "data:realIndex": m
        }), this.ctx.series.addCollapsedClassToSeries(v, m), t.size = t.size - n - this.margin;
        var y = a.fillPath({
          seriesNumber: m,
          size: t.size,
          value: t.series[m]
        }),
            w = this.startAngle,
            k = void 0,
            A = f.negToZero(t.series[m] > 100 ? 100 : t.series[m]) / 100,
            S = Math.round(this.totalAngle * A) + this.startAngle,
            C = void 0;
        e.globals.dataChanged && (k = this.startAngle, C = Math.round(this.totalAngle * f.negToZero(e.globals.previousPaths[m]) / 100) + k), Math.abs(S) + Math.abs(w) >= 360 && (S -= .01), Math.abs(C) + Math.abs(k) >= 360 && (C -= .01);
        var P = S - w,
            T = Array.isArray(e.config.stroke.dashArray) ? e.config.stroke.dashArray[m] : e.config.stroke.dashArray,
            z = i.drawPath({
          d: "",
          stroke: y,
          strokeWidth: n,
          fill: "none",
          fillOpacity: e.config.fill.opacity,
          classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + m,
          strokeDashArray: T
        });

        if (b.setAttrs(z.node, {
          "data:angle": P,
          "data:value": t.series[m]
        }), e.config.chart.dropShadow.enabled) {
          var I = e.config.chart.dropShadow;
          s.dropShadow(z, I, m);
        }

        s.setSelectionFilter(z, 0, m), this.addListeners(z, this.radialDataLabels), v.add(z), z.attr({
          index: 0,
          j: m
        });
        var M = 0;
        !this.initialAnim || e.globals.resized || e.globals.dataChanged || (M = (S - w) / 360 * e.config.chart.animations.speed, this.animDur = M / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), e.globals.dataChanged && (M = (S - w) / 360 * e.config.chart.animations.dynamicAnimation.speed, this.animDur = M / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(z, {
          centerX: t.centerX,
          centerY: t.centerY,
          endAngle: S,
          startAngle: w,
          prevEndAngle: C,
          prevStartAngle: k,
          size: t.size,
          i: m,
          totalItems: 2,
          animBeginArr: this.animBeginArr,
          dur: M,
          shouldSetPrevPaths: !0,
          easing: e.globals.easing
        });
      }

      return {
        g: r,
        elHollow: c,
        dataLabels: u
      };
    }
  }, {
    key: "drawHollow",
    value: function value(t) {
      var e = new b(this.ctx).drawCircle(2 * t.size);
      return e.attr({
        "class": "apexcharts-radialbar-hollow",
        cx: t.centerX,
        cy: t.centerY,
        r: t.size,
        fill: t.fill
      }), e;
    }
  }, {
    key: "drawHollowImage",
    value: function value(t, e, i, a) {
      var s = this.w,
          r = new L(this.ctx),
          n = f.randomId(),
          o = s.config.plotOptions.radialBar.hollow.image;
      if (s.config.plotOptions.radialBar.hollow.imageClipped) r.clippedImgArea({
        width: i,
        height: i,
        image: o,
        patternID: "pattern".concat(s.globals.cuid).concat(n)
      }), a = "url(#pattern".concat(s.globals.cuid).concat(n, ")");else {
        var l = s.config.plotOptions.radialBar.hollow.imageWidth,
            h = s.config.plotOptions.radialBar.hollow.imageHeight;

        if (void 0 === l && void 0 === h) {
          var c = s.globals.dom.Paper.image(o).loaded(function (e) {
            this.move(t.centerX - e.width / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - e.height / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          e.add(c);
        } else {
          var d = s.globals.dom.Paper.image(o).loaded(function (e) {
            this.move(t.centerX - l / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - h / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l, h);
          });
          e.add(d);
        }
      }
      return a;
    }
  }, {
    key: "getStrokeWidth",
    value: function value(t) {
      var e = this.w;
      return t.size * (100 - parseInt(e.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t.series.length + 1) - this.margin;
    }
  }]), s;
}(),
    Lt = function () {
  function t(i) {
    e(this, t), this.w = i.w, this.lineCtx = i;
  }

  return a(t, [{
    key: "sameValueSeriesFix",
    value: function value(t, e) {
      var i = this.w;

      if ("line" === i.config.chart.type && ("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[t]) && new y(this.lineCtx.ctx, i).seriesHaveSameValues(t)) {
        var a = e[t].slice();
        a[a.length - 1] = a[a.length - 1] + 1e-6, e[t] = a;
      }

      return e;
    }
  }, {
    key: "calculatePoints",
    value: function value(t) {
      var e = t.series,
          i = t.realIndex,
          a = t.x,
          s = t.y,
          r = t.i,
          n = t.j,
          o = t.prevY,
          l = this.w,
          h = [],
          c = [];

      if (0 === n) {
        var d = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX;
        l.globals.isXNumeric && (d = (l.globals.seriesX[i][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX), h.push(d), c.push(f.isNumber(e[r][0]) ? o + l.config.markers.offsetY : null), h.push(a + l.config.markers.offsetX), c.push(f.isNumber(e[r][n + 1]) ? s + l.config.markers.offsetY : null);
      } else h.push(a + l.config.markers.offsetX), c.push(f.isNumber(e[r][n + 1]) ? s + l.config.markers.offsetY : null);

      return {
        x: h,
        y: c
      };
    }
  }, {
    key: "checkPreviousPaths",
    value: function value(t) {
      for (var e = t.pathFromLine, i = t.pathFromArea, a = t.realIndex, s = this.w, r = 0; r < s.globals.previousPaths.length; r++) {
        var n = s.globals.previousPaths[r];
        ("line" === n.type || "area" === n.type) && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(a, 10) && ("line" === n.type ? (this.lineCtx.appendPathFrom = !1, e = s.globals.previousPaths[r].paths[0].d) : "area" === n.type && (this.lineCtx.appendPathFrom = !1, i = s.globals.previousPaths[r].paths[0].d, s.config.stroke.show && s.globals.previousPaths[r].paths[1] && (e = s.globals.previousPaths[r].paths[1].d)));
      }

      return {
        pathFromLine: e,
        pathFromArea: i
      };
    }
  }, {
    key: "determineFirstPrevY",
    value: function value(t) {
      var e = t.i,
          i = t.series,
          a = t.prevY,
          s = t.lineYPosition,
          r = this.w;
      if (void 0 !== i[e][0]) a = (s = r.config.chart.stacked && e > 0 ? this.lineCtx.prevSeriesY[e - 1][0] : this.lineCtx.zeroY) - i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);else if (r.config.chart.stacked && e > 0 && void 0 === i[e][0]) for (var n = e - 1; n >= 0; n--) {
        if (null !== i[n][0] && void 0 !== i[n][0]) {
          a = s = this.lineCtx.prevSeriesY[n][0];
          break;
        }
      }
      return {
        prevY: a,
        lineYPosition: s
      };
    }
  }]), t;
}(),
    Pt = function () {
  function t(i, a, s) {
    e(this, t), this.ctx = i, this.w = i.w, this.xyRatios = a, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s, this.scatter = new T(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Lt(this), this.markers = new P(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }

  return a(t, [{
    key: "draw",
    value: function value(t, e, i) {
      var a = this.w,
          s = new b(this.ctx),
          r = a.globals.comboCharts ? e : a.config.chart.type,
          n = s.group({
        "class": "apexcharts-".concat(r, "-series apexcharts-plot-series")
      }),
          o = new y(this.ctx, a);
      this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = o.getLogSeries(t), this.yRatio = o.getLogYRatios(this.yRatio);

      for (var l = [], h = 0; h < t.length; h++) {
        t = this.lineHelpers.sameValueSeriesFix(h, t);
        var c = a.globals.comboCharts ? i[h] : h;

        this._initSerieVariables(t, h, c);

        var d = [],
            g = [],
            u = a.globals.padHorizontal + this.categoryAxisCorrection;
        this.ctx.series.addCollapsedClassToSeries(this.elSeries, c), a.globals.isXNumeric && a.globals.seriesX.length > 0 && (u = (a.globals.seriesX[c][0] - a.globals.minX) / this.xRatio), g.push(u);
        var f,
            p = u,
            x = p,
            m = this.zeroY;
        m = this.lineHelpers.determineFirstPrevY({
          i: h,
          series: t,
          prevY: m,
          lineYPosition: 0
        }).prevY, d.push(m), f = m;

        var v = this._calculatePathsFrom({
          series: t,
          i: h,
          realIndex: c,
          prevX: x,
          prevY: m
        }),
            w = this._iterateOverDataPoints({
          series: t,
          realIndex: c,
          i: h,
          x: u,
          y: 1,
          pX: p,
          pY: f,
          pathsFrom: v,
          linePaths: [],
          areaPaths: [],
          seriesIndex: i,
          lineYPosition: 0,
          xArrj: g,
          yArrj: d
        });

        this._handlePaths({
          type: r,
          realIndex: c,
          i: h,
          paths: w
        }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l.push(this.elSeries);
      }

      if (a.config.chart.stacked) for (var k = l.length; k > 0; k--) {
        n.add(l[k - 1]);
      } else for (var A = 0; A < l.length; A++) {
        n.add(l[A]);
      }
      return n;
    }
  }, {
    key: "_initSerieVariables",
    value: function value(t, e, i) {
      var a = this.w,
          s = new b(this.ctx);
      this.xDivision = a.globals.gridWidth / (a.globals.dataPoints - ("on" === a.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a.config.stroke.width) ? a.config.stroke.width[i] : a.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a.globals.gridHeight || "end" === a.config.plotOptions.area.fillTo) && (this.areaBottomY = a.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s.group({
        "class": "apexcharts-series",
        seriesName: f.escapeString(a.globals.seriesNames[i])
      }), this.elPointsMain = s.group({
        "class": "apexcharts-series-markers-wrap",
        "data:realIndex": i
      }), this.elDataLabelsWrap = s.group({
        "class": "apexcharts-datalabels",
        "data:realIndex": i
      });
      var r = t[e].length === a.globals.dataPoints;
      this.elSeries.attr({
        "data:longestSeries": r,
        rel: e + 1,
        "data:realIndex": i
      }), this.appendPathFrom = !0;
    }
  }, {
    key: "_calculatePathsFrom",
    value: function value(t) {
      var e,
          i,
          a,
          s,
          r = t.series,
          n = t.i,
          o = t.realIndex,
          l = t.prevX,
          h = t.prevY,
          c = this.w,
          d = new b(this.ctx);

      if (null === r[n][0]) {
        for (var g = 0; g < r[n].length; g++) {
          if (null !== r[n][g]) {
            l = this.xDivision * g, h = this.zeroY - r[n][g] / this.yRatio[this.yaxisIndex], e = d.move(l, h), i = d.move(l, this.areaBottomY);
            break;
          }
        }
      } else e = d.move(l, h), i = d.move(l, this.areaBottomY) + d.line(l, h);

      if (a = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), s = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), c.globals.previousPaths.length > 0) {
        var u = this.lineHelpers.checkPreviousPaths({
          pathFromLine: a,
          pathFromArea: s,
          realIndex: o
        });
        a = u.pathFromLine, s = u.pathFromArea;
      }

      return {
        prevX: l,
        prevY: h,
        linePath: e,
        areaPath: i,
        pathFromLine: a,
        pathFromArea: s
      };
    }
  }, {
    key: "_handlePaths",
    value: function value(t) {
      var e = t.type,
          i = t.realIndex,
          a = t.i,
          s = t.paths,
          r = this.w,
          o = new b(this.ctx),
          l = new L(this.ctx);
      this.prevSeriesY.push(s.yArrj), r.globals.seriesXvalues[i] = s.xArrj, r.globals.seriesYvalues[i] = s.yArrj, this.pointsChart || r.globals.delayedElements.push({
        el: this.elPointsMain.node,
        index: i
      });
      var h = {
        i: a,
        realIndex: i,
        animationDelay: a,
        initialSpeed: r.config.chart.animations.speed,
        dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
        className: "apexcharts-".concat(e)
      };
      if ("area" === e) for (var c = l.fillPath({
        seriesNumber: i
      }), d = 0; d < s.areaPaths.length; d++) {
        var g = o.renderPaths(n(n({}, h), {}, {
          pathFrom: s.pathFromArea,
          pathTo: s.areaPaths[d],
          stroke: "none",
          strokeWidth: 0,
          strokeLineCap: null,
          fill: c
        }));
        this.elSeries.add(g);
      }

      if (r.config.stroke.show && !this.pointsChart) {
        var u = null;
        u = "line" === e ? l.fillPath({
          seriesNumber: i,
          i: a
        }) : r.globals.stroke.colors[i];

        for (var f = 0; f < s.linePaths.length; f++) {
          var p = o.renderPaths(n(n({}, h), {}, {
            pathFrom: s.pathFromLine,
            pathTo: s.linePaths[f],
            stroke: u,
            strokeWidth: this.strokeWidth,
            strokeLineCap: r.config.stroke.lineCap,
            fill: "none"
          }));
          this.elSeries.add(p);
        }
      }
    }
  }, {
    key: "_iterateOverDataPoints",
    value: function value(t) {
      for (var e = t.series, i = t.realIndex, a = t.i, s = t.x, r = t.y, n = t.pX, o = t.pY, l = t.pathsFrom, h = t.linePaths, c = t.areaPaths, d = t.seriesIndex, g = t.lineYPosition, u = t.xArrj, p = t.yArrj, x = this.w, m = new b(this.ctx), v = this.yRatio, y = l.prevY, w = l.linePath, k = l.areaPath, A = l.pathFromLine, S = l.pathFromArea, C = f.isNumber(x.globals.minYArr[i]) ? x.globals.minYArr[i] : x.globals.minY, L = x.globals.dataPoints > 1 ? x.globals.dataPoints - 1 : x.globals.dataPoints, P = 0; P < L; P++) {
        var T = void 0 === e[a][P + 1] || null === e[a][P + 1];

        if (x.globals.isXNumeric) {
          var z = x.globals.seriesX[i][P + 1];
          void 0 === x.globals.seriesX[i][P + 1] && (z = x.globals.seriesX[i][L - 1]), s = (z - x.globals.minX) / this.xRatio;
        } else s += this.xDivision;

        if (x.config.chart.stacked) {
          if (a > 0 && x.globals.collapsedSeries.length < x.config.series.length - 1) {
            g = this.prevSeriesY[function (t) {
              for (var e = t, i = 0; i < x.globals.series.length; i++) {
                if (x.globals.collapsedSeriesIndices.indexOf(t) > -1) {
                  e--;
                  break;
                }
              }

              return e >= 0 ? e : 0;
            }(a - 1)][P + 1];
          } else g = this.zeroY;
        } else g = this.zeroY;
        r = T ? g - C / v[this.yaxisIndex] + 2 * (this.isReversed ? C / v[this.yaxisIndex] : 0) : g - e[a][P + 1] / v[this.yaxisIndex] + 2 * (this.isReversed ? e[a][P + 1] / v[this.yaxisIndex] : 0), u.push(s), p.push(r);

        var I = this.lineHelpers.calculatePoints({
          series: e,
          x: s,
          y: r,
          realIndex: i,
          i: a,
          j: P,
          prevY: y
        }),
            M = this._createPaths({
          series: e,
          i: a,
          realIndex: i,
          j: P,
          x: s,
          y: r,
          pX: n,
          pY: o,
          linePath: w,
          areaPath: k,
          linePaths: h,
          areaPaths: c,
          seriesIndex: d
        });

        c = M.areaPaths, h = M.linePaths, n = M.pX, o = M.pY, k = M.areaPath, w = M.linePath, this.appendPathFrom && (A += m.line(s, this.zeroY), S += m.line(s, this.zeroY)), this.handleNullDataPoints(e, I, a, P, i), this._handleMarkersAndLabels({
          pointsPos: I,
          series: e,
          x: s,
          y: r,
          prevY: y,
          i: a,
          j: P,
          realIndex: i
        });
      }

      return {
        yArrj: p,
        xArrj: u,
        pathFromArea: S,
        areaPaths: c,
        pathFromLine: A,
        linePaths: h
      };
    }
  }, {
    key: "_handleMarkersAndLabels",
    value: function value(t) {
      var e = t.pointsPos,
          i = (t.series, t.x, t.y, t.prevY, t.i),
          a = t.j,
          s = t.realIndex,
          r = this.w,
          n = new z(this.ctx);
      if (this.pointsChart) this.scatter.draw(this.elSeries, a, {
        realIndex: s,
        pointsPos: e,
        zRatio: this.zRatio,
        elParent: this.elPointsMain
      });else {
        r.globals.series[i].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
        var o = this.markers.plotChartMarkers(e, s, a + 1);
        null !== o && this.elPointsMain.add(o);
      }
      var l = n.drawDataLabel(e, s, a + 1, null);
      null !== l && this.elDataLabelsWrap.add(l);
    }
  }, {
    key: "_createPaths",
    value: function value(t) {
      var e = t.series,
          i = t.i,
          a = t.realIndex,
          s = t.j,
          r = t.x,
          n = t.y,
          o = t.pX,
          l = t.pY,
          h = t.linePath,
          c = t.areaPath,
          d = t.linePaths,
          g = t.areaPaths,
          u = t.seriesIndex,
          f = this.w,
          p = new b(this.ctx),
          x = f.config.stroke.curve,
          m = this.areaBottomY;

      if (Array.isArray(f.config.stroke.curve) && (x = Array.isArray(u) ? f.config.stroke.curve[u[i]] : f.config.stroke.curve[i]), "smooth" === x) {
        var v = .35 * (r - o);
        f.globals.hasNullValues ? (null !== e[i][s] && (null !== e[i][s + 1] ? (h = p.move(o, l) + p.curve(o + v, l, r - v, n, r + 1, n), c = p.move(o + 1, l) + p.curve(o + v, l, r - v, n, r + 1, n) + p.line(r, m) + p.line(o, m) + "z") : (h = p.move(o, l), c = p.move(o, l) + "z")), d.push(h), g.push(c)) : (h += p.curve(o + v, l, r - v, n, r, n), c += p.curve(o + v, l, r - v, n, r, n)), o = r, l = n, s === e[i].length - 2 && (c = c + p.curve(o, l, r, n, r, m) + p.move(r, n) + "z", f.globals.hasNullValues || (d.push(h), g.push(c)));
      } else {
        if (null === e[i][s + 1]) {
          h += p.move(r, n);
          var y = f.globals.isXNumeric ? (f.globals.seriesX[a][s] - f.globals.minX) / this.xRatio : r - this.xDivision;
          c = c + p.line(y, m) + p.move(r, n) + "z";
        }

        null === e[i][s] && (h += p.move(r, n), c += p.move(r, m)), "stepline" === x ? (h = h + p.line(r, null, "H") + p.line(null, n, "V"), c = c + p.line(r, null, "H") + p.line(null, n, "V")) : "straight" === x && (h += p.line(r, n), c += p.line(r, n)), s === e[i].length - 2 && (c = c + p.line(r, m) + p.move(r, n) + "z", d.push(h), g.push(c));
      }

      return {
        linePaths: d,
        areaPaths: g,
        pX: o,
        pY: l,
        linePath: h,
        areaPath: c
      };
    }
  }, {
    key: "handleNullDataPoints",
    value: function value(t, e, i, a, s) {
      var r = this.w;

      if (null === t[i][a] && r.config.markers.showNullDataPoints || 1 === t[i].length) {
        var n = this.markers.plotChartMarkers(e, s, a + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, !0);
        null !== n && this.elPointsMain.add(n);
      }
    }
  }]), t;
}();

window.TreemapSquared = {}, window.TreemapSquared.generate = function () {
  function t(e, i, a, s) {
    this.xoffset = e, this.yoffset = i, this.height = s, this.width = a, this.shortestEdge = function () {
      return Math.min(this.height, this.width);
    }, this.getCoordinates = function (t) {
      var e,
          i = [],
          a = this.xoffset,
          s = this.yoffset,
          n = r(t) / this.height,
          o = r(t) / this.width;
      if (this.width >= this.height) for (e = 0; e < t.length; e++) {
        i.push([a, s, a + n, s + t[e] / n]), s += t[e] / n;
      } else for (e = 0; e < t.length; e++) {
        i.push([a, s, a + t[e] / o, s + o]), a += t[e] / o;
      }
      return i;
    }, this.cutArea = function (e) {
      var i;

      if (this.width >= this.height) {
        var a = e / this.height,
            s = this.width - a;
        i = new t(this.xoffset + a, this.yoffset, s, this.height);
      } else {
        var r = e / this.width,
            n = this.height - r;
        i = new t(this.xoffset, this.yoffset + r, this.width, n);
      }

      return i;
    };
  }

  function e(e, a, s, n, o) {
    return n = void 0 === n ? 0 : n, o = void 0 === o ? 0 : o, function (t) {
      var e,
          i,
          a = [];

      for (e = 0; e < t.length; e++) {
        for (i = 0; i < t[e].length; i++) {
          a.push(t[e][i]);
        }
      }

      return a;
    }(i(function (t, e) {
      var i,
          a = [],
          s = e / r(t);

      for (i = 0; i < t.length; i++) {
        a[i] = t[i] * s;
      }

      return a;
    }(e, a * s), [], new t(n, o, a, s), []));
  }

  function i(t, e, s, n) {
    var o, l, h;
    if (0 !== t.length) return o = s.shortestEdge(), function (t, e, i) {
      var s;
      if (0 === t.length) return !0;
      (s = t.slice()).push(e);
      var r = a(t, i),
          n = a(s, i);
      return r >= n;
    }(e, l = t[0], o) ? (e.push(l), i(t.slice(1), e, s, n)) : (h = s.cutArea(r(e), n), n.push(s.getCoordinates(e)), i(t, [], h, n)), n;
    n.push(s.getCoordinates(e));
  }

  function a(t, e) {
    var i = Math.min.apply(Math, t),
        a = Math.max.apply(Math, t),
        s = r(t);
    return Math.max(Math.pow(e, 2) * a / Math.pow(s, 2), Math.pow(s, 2) / (Math.pow(e, 2) * i));
  }

  function s(t) {
    return t && t.constructor === Array;
  }

  function r(t) {
    var e,
        i = 0;

    for (e = 0; e < t.length; e++) {
      i += t[e];
    }

    return i;
  }

  function n(t) {
    var e,
        i = 0;
    if (s(t[0])) for (e = 0; e < t.length; e++) {
      i += n(t[e]);
    } else i = r(t);
    return i;
  }

  return function t(i, a, r, o, l) {
    o = void 0 === o ? 0 : o, l = void 0 === l ? 0 : l;
    var h,
        c,
        d = [],
        g = [];

    if (s(i[0])) {
      for (c = 0; c < i.length; c++) {
        d[c] = n(i[c]);
      }

      for (h = e(d, a, r, o, l), c = 0; c < i.length; c++) {
        g.push(t(i[c], h[c][2] - h[c][0], h[c][3] - h[c][1], h[c][0], h[c][1]));
      }
    } else g = e(i, a, r, o, l);

    return g;
  };
}();

var Tt,
    zt,
    It = function () {
  function t(i, a) {
    e(this, t), this.ctx = i, this.w = i.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new yt(i), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }

  return a(t, [{
    key: "draw",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = new b(this.ctx),
          s = new L(this.ctx),
          r = a.group({
        "class": "apexcharts-treemap"
      });
      if (i.globals.noData) return r;
      var n = [];
      return t.forEach(function (t) {
        var e = t.map(function (t) {
          return Math.abs(t);
        });
        n.push(e);
      }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function (t, i) {
        t.data.forEach(function (t) {
          Array.isArray(e.labels[i]) || (e.labels[i] = []), e.labels[i].push(t.x);
        });
      }), window.TreemapSquared.generate(n, i.globals.gridWidth, i.globals.gridHeight).forEach(function (n, o) {
        var l = a.group({
          "class": "apexcharts-series apexcharts-treemap-series",
          seriesName: f.escapeString(i.globals.seriesNames[o]),
          rel: o + 1,
          "data:realIndex": o
        });

        if (i.config.chart.dropShadow.enabled) {
          var h = i.config.chart.dropShadow;
          new x(e.ctx).dropShadow(r, h, o);
        }

        var c = a.group({
          "class": "apexcharts-data-labels"
        });
        n.forEach(function (r, n) {
          var h = r[0],
              c = r[1],
              d = r[2],
              g = r[3],
              u = a.drawRect(h, c, d - h, g - c, 0, "#fff", 1, e.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? p : i.globals.stroke.colors[o]);
          u.attr({
            cx: h,
            cy: c,
            index: o,
            i: o,
            j: n,
            width: d - h,
            height: g - c
          });
          var f = e.helpers.getShadeColor(i.config.chart.type, o, n, e.negRange),
              p = f.color;
          void 0 !== i.config.series[o].data[n] && i.config.series[o].data[n].fillColor && (p = i.config.series[o].data[n].fillColor);
          var x = s.fillPath({
            color: p,
            seriesNumber: o,
            dataPointIndex: n
          });
          u.node.classList.add("apexcharts-treemap-rect"), u.attr({
            fill: x
          }), e.helpers.addListeners(u);
          var b = {
            x: h + (d - h) / 2,
            y: c + (g - c) / 2,
            width: 0,
            height: 0
          },
              m = {
            x: h,
            y: c,
            width: d - h,
            height: g - c
          };

          if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
            var v = 1;
            i.globals.resized || (v = i.config.chart.animations.speed), e.animateTreemap(u, b, m, v);
          }

          if (i.globals.dataChanged) {
            var y = 1;
            e.dynamicAnim.enabled && i.globals.shouldAnimate && (y = e.dynamicAnim.speed, i.globals.previousPaths[o][n] && i.globals.previousPaths[o][n].rect && (b = i.globals.previousPaths[o][n].rect), e.animateTreemap(u, b, m, y));
          }

          var w = e.getFontSize(r),
              k = i.config.dataLabels.formatter(e.labels[o][n], {
            value: i.globals.series[o][n],
            seriesIndex: o,
            dataPointIndex: n,
            w: i
          }),
              A = e.helpers.calculateDataLabels({
            text: k,
            x: (h + d) / 2,
            y: (c + g) / 2 + e.strokeWidth / 2 + w / 3,
            i: o,
            j: n,
            colorProps: f,
            fontSize: w,
            series: t
          });
          i.config.dataLabels.enabled && A && e.rotateToFitLabel(A, k, h, c, d, g), l.add(u), null !== A && l.add(A);
        }), l.add(c), r.add(l);
      }), r;
    }
  }, {
    key: "getFontSize",
    value: function value(t) {
      var e = this.w;

      var i,
          a,
          s,
          r,
          n = function t(e) {
        var i,
            a = 0;
        if (Array.isArray(e[0])) for (i = 0; i < e.length; i++) {
          a += t(e[i]);
        } else for (i = 0; i < e.length; i++) {
          a += e[i].length;
        }
        return a;
      }(this.labels) / function t(e) {
        var i,
            a = 0;
        if (Array.isArray(e[0])) for (i = 0; i < e.length; i++) {
          a += t(e[i]);
        } else for (i = 0; i < e.length; i++) {
          a += 1;
        }
        return a;
      }(this.labels);

      return i = t[2] - t[0], a = t[3] - t[1], s = i * a, r = Math.pow(s, .5), Math.min(r / n, parseInt(e.config.dataLabels.style.fontSize, 10));
    }
  }, {
    key: "rotateToFitLabel",
    value: function value(t, e, i, a, s, r) {
      var n = new b(this.ctx),
          o = n.getTextRects(e);

      if (o.width + 5 > s - i && o.width <= r - a) {
        var l = n.rotateAroundCenter(t.node);
        t.node.setAttribute("transform", "rotate(-90 ".concat(l.x, " ").concat(l.y, ")"));
      }
    }
  }, {
    key: "animateTreemap",
    value: function value(t, e, i, a) {
      var s = new p(this.ctx);
      s.animateRect(t, {
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      }, {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      }, a, function () {
        s.animationCompleted(t);
      });
    }
  }]), t;
}(),
    Mt = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }

  return a(t, [{
    key: "calculateTimeScaleTicks",
    value: function value(t, e) {
      var i = this,
          a = this.w;
      if (a.globals.allSeriesCollapsed) return a.globals.labels = [], a.globals.timescaleLabels = [], [];
      var s = new Y(this.ctx),
          r = (e - t) / 864e5;
      this.determineInterval(r), a.globals.disableZoomIn = !1, a.globals.disableZoomOut = !1, r < .005 ? a.globals.disableZoomIn = !0 : r > 5e4 && (a.globals.disableZoomOut = !0);
      var o = s.getTimeUnitsfromTimestamp(t, e, this.utc),
          l = a.globals.gridWidth / r,
          h = l / 24,
          c = h / 60,
          d = c / 60,
          g = Math.floor(24 * r),
          u = Math.floor(24 * r * 60),
          f = Math.floor(24 * r * 60 * 60),
          p = Math.floor(r),
          x = Math.floor(r / 30),
          b = Math.floor(r / 365),
          m = {
        minSecond: o.minSecond,
        minMinute: o.minMinute,
        minHour: o.minHour,
        minDate: o.minDate,
        minMonth: o.minMonth,
        minYear: o.minYear
      },
          v = {
        firstVal: m,
        currentSecond: m.minSecond,
        currentMinute: m.minMinute,
        currentHour: m.minHour,
        currentMonthDate: m.minDate,
        currentDate: m.minDate,
        currentMonth: m.minMonth,
        currentYear: m.minYear,
        daysWidthOnXAxis: l,
        hoursWidthOnXAxis: h,
        minutesWidthOnXAxis: c,
        secondsWidthOnXAxis: d,
        numberOfSeconds: f,
        numberOfMinutes: u,
        numberOfHours: g,
        numberOfDays: p,
        numberOfMonths: x,
        numberOfYears: b
      };

      switch (this.tickInterval) {
        case "years":
          this.generateYearScale(v);
          break;

        case "months":
        case "half_year":
          this.generateMonthScale(v);
          break;

        case "months_days":
        case "months_fortnight":
        case "days":
        case "week_days":
          this.generateDayScale(v);
          break;

        case "hours":
          this.generateHourScale(v);
          break;

        case "minutes":
          this.generateMinuteScale(v);
      }

      var y = this.timeScaleArray.map(function (t) {
        var e = {
          position: t.position,
          unit: t.unit,
          year: t.year,
          day: t.day ? t.day : 1,
          hour: t.hour ? t.hour : 0,
          month: t.month + 1
        };
        return "month" === t.unit ? n(n({}, e), {}, {
          day: 1,
          value: t.value + 1
        }) : "day" === t.unit || "hour" === t.unit ? n(n({}, e), {}, {
          value: t.value
        }) : "minute" === t.unit ? n(n({}, e), {}, {
          value: t.value,
          minute: t.value
        }) : t;
      });
      return y.filter(function (t) {
        var e = 1,
            s = Math.ceil(a.globals.gridWidth / 120),
            r = t.value;
        void 0 !== a.config.xaxis.tickAmount && (s = a.config.xaxis.tickAmount), y.length > s && (e = Math.floor(y.length / s));
        var n = !1,
            o = !1;

        switch (i.tickInterval) {
          case "years":
            "year" === t.unit && (n = !0);
            break;

          case "half_year":
            e = 7, "year" === t.unit && (n = !0);
            break;

          case "months":
            e = 1, "year" === t.unit && (n = !0);
            break;

          case "months_fortnight":
            e = 15, "year" !== t.unit && "month" !== t.unit || (n = !0), 30 === r && (o = !0);
            break;

          case "months_days":
            e = 10, "month" === t.unit && (n = !0), 30 === r && (o = !0);
            break;

          case "week_days":
            e = 8, "month" === t.unit && (n = !0);
            break;

          case "days":
            e = 1, "month" === t.unit && (n = !0);
            break;

          case "hours":
            "day" === t.unit && (n = !0);
            break;

          case "minutes":
            r % 5 != 0 && (o = !0);
        }

        if ("minutes" === i.tickInterval || "hours" === i.tickInterval) {
          if (!o) return !0;
        } else if ((r % e == 0 || n) && !o) return !0;
      });
    }
  }, {
    key: "recalcDimensionsBasedOnFormat",
    value: function value(t, e) {
      var i = this.w,
          a = this.formatDates(t),
          s = this.removeOverlappingTS(a);
      i.globals.timescaleLabels = s.slice(), new nt(this.ctx).plotCoords();
    }
  }, {
    key: "determineInterval",
    value: function value(t) {
      switch (!0) {
        case t > 1825:
          this.tickInterval = "years";
          break;

        case t > 800 && t <= 1825:
          this.tickInterval = "half_year";
          break;

        case t > 180 && t <= 800:
          this.tickInterval = "months";
          break;

        case t > 90 && t <= 180:
          this.tickInterval = "months_fortnight";
          break;

        case t > 60 && t <= 90:
          this.tickInterval = "months_days";
          break;

        case t > 30 && t <= 60:
          this.tickInterval = "week_days";
          break;

        case t > 2 && t <= 30:
          this.tickInterval = "days";
          break;

        case t > .1 && t <= 2:
          this.tickInterval = "hours";
          break;

        case t < .1:
          this.tickInterval = "minutes";
          break;

        default:
          this.tickInterval = "days";
      }
    }
  }, {
    key: "generateYearScale",
    value: function value(t) {
      var e = t.firstVal,
          i = t.currentMonth,
          a = t.currentYear,
          s = t.daysWidthOnXAxis,
          r = t.numberOfYears,
          n = e.minYear,
          o = 0,
          l = new Y(this.ctx),
          h = "year";

      if (e.minDate > 1 || e.minMonth > 0) {
        var c = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate);
        o = (l.determineDaysOfYear(e.minYear) - c + 1) * s, n = e.minYear + 1, this.timeScaleArray.push({
          position: o,
          value: n,
          unit: h,
          year: n,
          month: f.monthMod(i + 1)
        });
      } else 1 === e.minDate && 0 === e.minMonth && this.timeScaleArray.push({
        position: o,
        value: n,
        unit: h,
        year: a,
        month: f.monthMod(i + 1)
      });

      for (var d = n, g = o, u = 0; u < r; u++) {
        d++, g = l.determineDaysOfYear(d - 1) * s + g, this.timeScaleArray.push({
          position: g,
          value: d,
          unit: h,
          year: d,
          month: 1
        });
      }
    }
  }, {
    key: "generateMonthScale",
    value: function value(t) {
      var e = t.firstVal,
          i = t.currentMonthDate,
          a = t.currentMonth,
          s = t.currentYear,
          r = t.daysWidthOnXAxis,
          n = t.numberOfMonths,
          o = a,
          l = 0,
          h = new Y(this.ctx),
          c = "month",
          d = 0;

      if (e.minDate > 1) {
        l = (h.determineDaysOfMonths(a + 1, e.minYear) - i + 1) * r, o = f.monthMod(a + 1);
        var g = s + d,
            u = f.monthMod(o),
            p = o;
        0 === o && (c = "year", p = g, u = 1, g += d += 1), this.timeScaleArray.push({
          position: l,
          value: p,
          unit: c,
          year: g,
          month: u
        });
      } else this.timeScaleArray.push({
        position: l,
        value: o,
        unit: c,
        year: s,
        month: f.monthMod(a)
      });

      for (var x = o + 1, b = l, m = 0, v = 1; m < n; m++, v++) {
        0 === (x = f.monthMod(x)) ? (c = "year", d += 1) : c = "month";

        var y = this._getYear(s, x, d);

        b = h.determineDaysOfMonths(x, y) * r + b;
        var w = 0 === x ? y : x;
        this.timeScaleArray.push({
          position: b,
          value: w,
          unit: c,
          year: y,
          month: 0 === x ? 1 : x
        }), x++;
      }
    }
  }, {
    key: "generateDayScale",
    value: function value(t) {
      var e = t.firstVal,
          i = t.currentMonth,
          a = t.currentYear,
          s = t.hoursWidthOnXAxis,
          r = t.numberOfDays,
          n = new Y(this.ctx),
          o = "day",
          l = e.minDate + 1,
          h = l,
          c = function c(t, e, i) {
        return t > n.determineDaysOfMonths(e + 1, i) ? (h = 1, o = "month", g = e += 1, e) : e;
      },
          d = (24 - e.minHour) * s,
          g = l,
          u = c(h, i, a);

      0 === e.minHour && 1 === e.minDate && (d = 0, g = f.monthMod(e.minMonth), o = "month", h = e.minDate, r++), this.timeScaleArray.push({
        position: d,
        value: g,
        unit: o,
        year: this._getYear(a, u, 0),
        month: f.monthMod(u),
        day: h
      });

      for (var p = d, x = 0; x < r; x++) {
        o = "day", u = c(h += 1, u, this._getYear(a, u, 0));

        var b = this._getYear(a, u, 0);

        p = 24 * s + p;
        var m = 1 === h ? f.monthMod(u) : h;
        this.timeScaleArray.push({
          position: p,
          value: m,
          unit: o,
          year: b,
          month: f.monthMod(u),
          day: m
        });
      }
    }
  }, {
    key: "generateHourScale",
    value: function value(t) {
      var e = t.firstVal,
          i = t.currentDate,
          a = t.currentMonth,
          s = t.currentYear,
          r = t.minutesWidthOnXAxis,
          n = t.numberOfHours,
          o = new Y(this.ctx),
          l = "hour",
          h = function h(t, e) {
        return t > o.determineDaysOfMonths(e + 1, s) && (x = 1, e += 1), {
          month: e,
          date: x
        };
      },
          c = function c(t, e) {
        return t > o.determineDaysOfMonths(e + 1, s) ? e += 1 : e;
      },
          d = 60 - (e.minMinute + e.minSecond / 60),
          g = d * r,
          u = e.minHour + 1,
          p = u + 1;

      60 === d && (g = 0, p = (u = e.minHour) + 1);
      var x = i,
          b = c(x, a);
      this.timeScaleArray.push({
        position: g,
        value: u,
        unit: l,
        day: x,
        hour: p,
        year: s,
        month: f.monthMod(b)
      });

      for (var m = g, v = 0; v < n; v++) {
        if (l = "hour", p >= 24) p = 0, l = "day", b = h(x += 1, b).month, b = c(x, b);

        var y = this._getYear(s, b, 0);

        m = 0 === p && 0 === v ? d * r : 60 * r + m;
        var w = 0 === p ? x : p;
        this.timeScaleArray.push({
          position: m,
          value: w,
          unit: l,
          hour: p,
          day: x,
          year: y,
          month: f.monthMod(b)
        }), p++;
      }
    }
  }, {
    key: "generateMinuteScale",
    value: function value(t) {
      var e = t.firstVal,
          i = (t.currentSecond, t.currentMinute, t.currentHour),
          a = t.currentDate,
          s = t.currentMonth,
          r = t.currentYear,
          n = t.minutesWidthOnXAxis,
          o = t.secondsWidthOnXAxis,
          l = t.numberOfMinutes,
          h = "minute",
          c = (60 - e.minSecond) * o,
          d = e.minMinute + 1,
          g = d + 1,
          u = a,
          p = s,
          x = r,
          b = i;
      this.timeScaleArray.push({
        position: c,
        value: d,
        unit: h,
        day: u,
        hour: b,
        minute: g,
        year: x,
        month: f.monthMod(p)
      });

      for (var m = c, v = 0; v < l; v++) {
        g >= 60 && (g = 0, 24 === (b += 1) && (b = 0)), m = n + m, this.timeScaleArray.push({
          position: m,
          value: g,
          unit: h,
          hour: b,
          minute: g,
          day: u,
          year: this._getYear(r, p, 0),
          month: f.monthMod(p)
        }), g++;
      }
    }
  }, {
    key: "createRawDateString",
    value: function value(t, e) {
      var i = t.year;
      return i += "-" + ("0" + t.month.toString()).slice(-2), "day" === t.unit ? i += "day" === t.unit ? "-" + ("0" + e).slice(-2) : "-01" : i += "-" + ("0" + (t.day ? t.day : "1")).slice(-2), "hour" === t.unit ? i += "hour" === t.unit ? "T" + ("0" + e).slice(-2) : "T00" : i += "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), i += "minute" === t.unit ? ":" + ("0" + e).slice(-2) + ":00" : ":00:00", this.utc && (i += ".000Z"), i;
    }
  }, {
    key: "formatDates",
    value: function value(t) {
      var e = this,
          i = this.w;
      return t.map(function (t) {
        var a = t.value.toString(),
            s = new Y(e.ctx),
            r = e.createRawDateString(t, a),
            n = s.getDate(s.parseDate(r));

        if (e.utc || (n = s.getDate(s.parseDateWithTimezone(r))), void 0 === i.config.xaxis.labels.format) {
          var o = "dd MMM",
              l = i.config.xaxis.labels.datetimeFormatter;
          "year" === t.unit && (o = l.year), "month" === t.unit && (o = l.month), "day" === t.unit && (o = l.day), "hour" === t.unit && (o = l.hour), "minute" === t.unit && (o = l.minute), a = s.formatDate(n, o);
        } else a = s.formatDate(n, i.config.xaxis.labels.format);

        return {
          dateString: r,
          position: t.position,
          value: a,
          unit: t.unit,
          year: t.year,
          month: t.month
        };
      });
    }
  }, {
    key: "removeOverlappingTS",
    value: function value(t) {
      var e,
          i = this,
          a = new b(this.ctx),
          s = !1;
      t.length > 0 && t[0].value && t.every(function (e) {
        return e.value.length === t[0].value.length;
      }) && (s = !0, e = a.getTextRects(t[0].value).width);
      var r = 0,
          n = t.map(function (n, o) {
        if (o > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
          var l = s ? e : a.getTextRects(t[r].value).width,
              h = t[r].position;
          return n.position > h + l + 10 ? (r = o, n) : null;
        }

        return n;
      });
      return n = n.filter(function (t) {
        return null !== t;
      });
    }
  }, {
    key: "_getYear",
    value: function value(t, e, i) {
      return t + Math.floor(e / 12) + i;
    }
  }]), t;
}(),
    Et = function () {
  function t(i, a) {
    e(this, t), this.ctx = a, this.w = a.w, this.el = i;
  }

  return a(t, [{
    key: "setupElements",
    value: function value() {
      var t = this.w.globals,
          e = this.w.config,
          i = e.chart.type;
      t.axisCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1, t.isBarHorizontal = ("bar" === e.chart.type || "rangeBar" === e.chart.type) && e.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.chartID, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), b.setAttrs(t.dom.elWrap, {
        id: t.chartClass.substring(1),
        "class": "apexcharts-canvas " + t.chartClass.substring(1)
      }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({
        "class": "apexcharts-svg",
        "xmlns:data": "ApexChartsNS",
        transform: "translate(".concat(e.chart.offsetX, ", ").concat(e.chart.offsetY, ")")
      }), t.dom.Paper.node.style.background = e.chart.background, this.setSVGDimensions(), t.dom.elGraphical = t.dom.Paper.group().attr({
        "class": "apexcharts-inner apexcharts-graphical"
      }), t.dom.elAnnotations = t.dom.Paper.group().attr({
        "class": "apexcharts-annotations"
      }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs);
    }
  }, {
    key: "plotChartType",
    value: function value(t, e) {
      var i = this.w,
          a = i.config,
          s = i.globals,
          r = {
        series: [],
        i: []
      },
          n = {
        series: [],
        i: []
      },
          o = {
        series: [],
        i: []
      },
          l = {
        series: [],
        i: []
      },
          h = {
        series: [],
        i: []
      },
          c = {
        series: [],
        i: []
      },
          d = {
        series: [],
        i: []
      };
      s.series.map(function (e, g) {
        var u = 0;
        void 0 !== t[g].type ? ("column" === t[g].type || "bar" === t[g].type ? (s.series.length > 1 && a.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), h.series.push(e), h.i.push(g), u++, i.globals.columnSeries = h.series) : "area" === t[g].type ? (n.series.push(e), n.i.push(g), u++) : "line" === t[g].type ? (r.series.push(e), r.i.push(g), u++) : "scatter" === t[g].type ? (o.series.push(e), o.i.push(g)) : "bubble" === t[g].type ? (l.series.push(e), l.i.push(g), u++) : "candlestick" === t[g].type ? (c.series.push(e), c.i.push(g), u++) : "boxPlot" === t[g].type ? (d.series.push(e), d.i.push(g), u++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble"), u > 1 && (s.comboCharts = !0)) : (r.series.push(e), r.i.push(g));
      });
      var g = new Pt(this.ctx, e),
          u = new vt(this.ctx, e);
      this.ctx.pie = new At(this.ctx);
      var f = new Ct(this.ctx);
      this.ctx.rangeBar = new F(this.ctx, e);
      var p = new St(this.ctx),
          x = [];

      if (s.comboCharts) {
        if (n.series.length > 0 && x.push(g.draw(n.series, "area", n.i)), h.series.length > 0) if (i.config.chart.stacked) {
          var b = new mt(this.ctx, e);
          x.push(b.draw(h.series, h.i));
        } else this.ctx.bar = new X(this.ctx, e), x.push(this.ctx.bar.draw(h.series, h.i));

        if (r.series.length > 0 && x.push(g.draw(r.series, "line", r.i)), c.series.length > 0 && x.push(u.draw(c.series, c.i)), d.series.length > 0 && x.push(u.draw(d.series, d.i)), o.series.length > 0) {
          var m = new Pt(this.ctx, e, !0);
          x.push(m.draw(o.series, "scatter", o.i));
        }

        if (l.series.length > 0) {
          var v = new Pt(this.ctx, e, !0);
          x.push(v.draw(l.series, "bubble", l.i));
        }
      } else switch (a.chart.type) {
        case "line":
          x = g.draw(s.series, "line");
          break;

        case "area":
          x = g.draw(s.series, "area");
          break;

        case "bar":
          if (a.chart.stacked) x = new mt(this.ctx, e).draw(s.series);else this.ctx.bar = new X(this.ctx, e), x = this.ctx.bar.draw(s.series);
          break;

        case "candlestick":
          x = new vt(this.ctx, e).draw(s.series);
          break;

        case "boxPlot":
          x = new vt(this.ctx, e).draw(s.series);
          break;

        case "rangeBar":
          x = this.ctx.rangeBar.draw(s.series);
          break;

        case "heatmap":
          x = new wt(this.ctx, e).draw(s.series);
          break;

        case "treemap":
          x = new It(this.ctx, e).draw(s.series);
          break;

        case "pie":
        case "donut":
        case "polarArea":
          x = this.ctx.pie.draw(s.series);
          break;

        case "radialBar":
          x = f.draw(s.series);
          break;

        case "radar":
          x = p.draw(s.series);
          break;

        default:
          x = g.draw(s.series);
      }

      return x;
    }
  }, {
    key: "setSVGDimensions",
    value: function value() {
      var t = this.w.globals,
          e = this.w.config;
      t.svgWidth = e.chart.width, t.svgHeight = e.chart.height;
      var i = f.getDimensions(this.el),
          a = e.chart.width.toString().split(/[0-9]+/g).pop();
      "%" === a ? f.isNumber(i[0]) && (0 === i[0].width && (i = f.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(e.chart.width, 10) / 100) : "px" !== a && "" !== a || (t.svgWidth = parseInt(e.chart.width, 10));
      var s = e.chart.height.toString().split(/[0-9]+/g).pop();
      if ("auto" !== t.svgHeight && "" !== t.svgHeight) {
        if ("%" === s) {
          var r = f.getDimensions(this.el.parentNode);
          t.svgHeight = r[1] * parseInt(e.chart.height, 10) / 100;
        } else t.svgHeight = parseInt(e.chart.height, 10);
      } else t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2;

      if (t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), b.setAttrs(t.dom.Paper.node, {
        width: t.svgWidth,
        height: t.svgHeight
      }), "%" !== s) {
        var n = e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0;
        t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + n + "px";
      }

      t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px";
    }
  }, {
    key: "shiftGraphPosition",
    value: function value() {
      var t = this.w.globals,
          e = t.translateY,
          i = {
        transform: "translate(" + t.translateX + ", " + e + ")"
      };
      b.setAttrs(t.dom.elGraphical.node, i);
    }
  }, {
    key: "resizeNonAxisCharts",
    value: function value() {
      var t = this.w,
          e = t.globals,
          i = 0,
          a = t.config.chart.sparkline.enabled ? 1 : 15;
      a += t.config.grid.padding.bottom, "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || !t.config.legend.show || t.config.legend.floating || (i = new lt(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
      var s = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),
          r = 2.05 * t.globals.radialSize;

      if (s && !t.config.chart.sparkline.enabled) {
        var n = f.getBoundingClientRect(s);
        r = n.bottom;
        var o = n.bottom - n.top;
        r = Math.max(2.05 * t.globals.radialSize, o);
      }

      var l = r + e.translateY + i + a;
      e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute("height", l), e.dom.elWrap.style.height = l + "px", b.setAttrs(e.dom.Paper.node, {
        height: l
      }), e.dom.Paper.node.parentNode.parentNode.style.minHeight = l + "px";
    }
  }, {
    key: "coreCalculations",
    value: function value() {
      new U(this.ctx).init();
    }
  }, {
    key: "resetGlobals",
    value: function value() {
      var t = this,
          e = function e() {
        return t.w.config.series.map(function (t) {
          return [];
        });
      },
          i = new H(),
          a = this.w.globals;

      i.initGlobalVars(a), a.seriesXvalues = e(), a.seriesYvalues = e();
    }
  }, {
    key: "isMultipleY",
    value: function value() {
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0;
    }
  }, {
    key: "xySettings",
    value: function value() {
      var t = null,
          e = this.w;

      if (e.globals.axisCharts) {
        if ("back" === e.config.xaxis.crosshairs.position) new Q(this.ctx).drawXCrosshairs();
        if ("back" === e.config.yaxis[0].crosshairs.position) new Q(this.ctx).drawYCrosshairs();

        if ("datetime" === e.config.xaxis.type && void 0 === e.config.xaxis.labels.formatter) {
          this.ctx.timeScale = new Mt(this.ctx);
          var i = [];
          isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
        }

        t = new y(this.ctx).getCalculatedRatios();
      }

      return t;
    }
  }, {
    key: "updateSourceChart",
    value: function value(t) {
      this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
        chart: {
          selection: {
            xaxis: {
              min: t.w.globals.minX,
              max: t.w.globals.maxX
            }
          }
        }
      }, !1, !1);
    }
  }, {
    key: "setupBrushHandler",
    value: function value() {
      var t = this,
          e = this.w;

      if (e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection) {
        var i = e.config.chart.brush.targets || [e.config.chart.brush.target];
        i.forEach(function (e) {
          var i = ApexCharts.getChartByID(e);
          i.w.globals.brushSource = t.ctx, "function" != typeof i.w.config.chart.events.zoomed && (i.w.config.chart.events.zoomed = function () {
            t.updateSourceChart(i);
          }), "function" != typeof i.w.config.chart.events.scrolled && (i.w.config.chart.events.scrolled = function () {
            t.updateSourceChart(i);
          });
        }), e.config.chart.events.selection = function (t, a) {
          i.forEach(function (t) {
            var i = ApexCharts.getChartByID(t),
                s = f.clone(e.config.yaxis);

            if (e.config.chart.brush.autoScaleYaxis && 1 === i.w.globals.series.length) {
              var r = new j(i);
              s = r.autoScaleY(i, s, a);
            }

            var o = i.w.config.yaxis.reduce(function (t, e, a) {
              return [].concat(g(t), [n(n({}, i.w.config.yaxis[a]), {}, {
                min: s[0].min,
                max: s[0].max
              })]);
            }, []);

            i.ctx.updateHelpers._updateOptions({
              xaxis: {
                min: a.xaxis.min,
                max: a.xaxis.max
              },
              yaxis: o
            }, !1, !1, !1, !1);
          });
        };
      }
    }
  }]), t;
}(),
    Xt = function () {
  function i(t) {
    e(this, i), this.ctx = t, this.w = t.w;
  }

  return a(i, [{
    key: "_updateOptions",
    value: function value(e) {
      var i = this,
          a = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
          r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
          n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
          o = [this.ctx];
      r && (o = this.ctx.getSyncedCharts()), this.ctx.w.globals.isExecCalled && (o = [this.ctx], this.ctx.w.globals.isExecCalled = !1), o.forEach(function (r) {
        var o = r.w;
        return o.globals.shouldAnimate = s, a || (o.globals.resized = !0, o.globals.dataChanged = !0, s && r.series.getPreviousPaths()), e && "object" === t(e) && (r.config = new D(e), e = y.extendArrayProps(r.config, e, o), r.w.globals.chartID !== i.ctx.w.globals.chartID && delete e.series, o.config = f.extend(o.config, e), n && (o.globals.lastXAxis = e.xaxis ? f.clone(e.xaxis) : [], o.globals.lastYAxis = e.yaxis ? f.clone(e.yaxis) : [], o.globals.initialConfig = f.extend({}, o.config), o.globals.initialSeries = f.clone(o.config.series))), r.update(e);
      });
    }
  }, {
    key: "_updateSeries",
    value: function value(t, e) {
      var i,
          a = this,
          s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          r = this.w;
      return r.globals.shouldAnimate = e, r.globals.dataChanged = !0, e && this.ctx.series.getPreviousPaths(), r.globals.axisCharts ? (0 === (i = t.map(function (t, e) {
        return a._extendSeries(t, e);
      })).length && (i = [{
        data: []
      }]), r.config.series = i) : r.config.series = t.slice(), s && (r.globals.initialSeries = f.clone(r.config.series)), this.ctx.update();
    }
  }, {
    key: "_extendSeries",
    value: function value(t, e) {
      var i = this.w,
          a = i.config.series[e];
      return n(n({}, i.config.series[e]), {}, {
        name: t.name ? t.name : a && a.name,
        color: t.color ? t.color : a && a.color,
        type: t.type ? t.type : a && a.type,
        data: t.data ? t.data : a && a.data
      });
    }
  }, {
    key: "toggleDataPointSelection",
    value: function value(t, e) {
      var i = this.w,
          a = null,
          s = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
      return i.globals.axisCharts ? a = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(e, "'], ").concat(s, " circle[j='").concat(e, "'], ").concat(s, " rect[j='").concat(e, "']")).members[0] : void 0 === e && (a = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(t, "']")).members[0], "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(t)), a ? (new b(this.ctx).pathMouseDown(a, null), a.node ? a.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
    }
  }, {
    key: "forceXAxisUpdate",
    value: function value(t) {
      var e = this.w;

      if (["min", "max"].forEach(function (i) {
        void 0 !== t.xaxis[i] && (e.config.xaxis[i] = t.xaxis[i], e.globals.lastXAxis[i] = t.xaxis[i]);
      }), t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories), e.config.xaxis.convertedCatToNumeric) {
        var i = new R(t);
        t = i.convertCatToNumericXaxis(t, this.ctx);
      }

      return t;
    }
  }, {
    key: "forceYAxisUpdate",
    value: function value(t) {
      var e = this.w;
      return e.config.chart.stacked && "100%" === e.config.chart.stackType && (Array.isArray(t.yaxis) ? t.yaxis.forEach(function (e, i) {
        t.yaxis[i].min = 0, t.yaxis[i].max = 100;
      }) : (t.yaxis.min = 0, t.yaxis.max = 100)), t;
    }
  }, {
    key: "revertDefaultAxisMinMax",
    value: function value(t) {
      var e = this,
          i = this.w,
          a = i.globals.lastXAxis,
          s = i.globals.lastYAxis;
      t && t.xaxis && (a = t.xaxis), t && t.yaxis && (s = t.yaxis), i.config.xaxis.min = a.min, i.config.xaxis.max = a.max;

      var r = function r(t) {
        void 0 !== s[t] && (i.config.yaxis[t].min = s[t].min, i.config.yaxis[t].max = s[t].max);
      };

      i.config.yaxis.map(function (t, a) {
        i.globals.zoomed || void 0 !== s[a] ? r(a) : void 0 !== e.ctx.opts.yaxis[a] && (t.min = e.ctx.opts.yaxis[a].min, t.max = e.ctx.opts.yaxis[a].max);
      });
    }
  }]), i;
}();

Tt = "undefined" != typeof window ? window : void 0, zt = function zt(e, i) {
  var a = (void 0 !== this ? this : e).SVG = function (t) {
    if (a.supported) return t = new a.Doc(t), a.parser.draw || a.prepare(), t;
  };

  if (a.ns = "http://www.w3.org/2000/svg", a.xmlns = "http://www.w3.org/2000/xmlns/", a.xlink = "http://www.w3.org/1999/xlink", a.svgjs = "http://svgjs.com/svgjs", a.supported = !0, !a.supported) return !1;
  a.did = 1e3, a.eid = function (t) {
    return "Svgjs" + d(t) + a.did++;
  }, a.create = function (t) {
    var e = i.createElementNS(this.ns, t);
    return e.setAttribute("id", this.eid(t)), e;
  }, a.extend = function () {
    var t, e;
    e = (t = [].slice.call(arguments)).pop();

    for (var i = t.length - 1; i >= 0; i--) {
      if (t[i]) for (var s in e) {
        t[i].prototype[s] = e[s];
      }
    }

    a.Set && a.Set.inherit && a.Set.inherit();
  }, a.invent = function (t) {
    var e = "function" == typeof t.create ? t.create : function () {
      this.constructor.call(this, a.create(t.create));
    };
    return t.inherit && (e.prototype = new t.inherit()), t.extend && a.extend(e, t.extend), t.construct && a.extend(t.parent || a.Container, t.construct), e;
  }, a.adopt = function (t) {
    return t ? t.instance ? t.instance : ((i = "svg" == t.nodeName ? t.parentNode instanceof e.SVGElement ? new a.Nested() : new a.Doc() : "linearGradient" == t.nodeName ? new a.Gradient("linear") : "radialGradient" == t.nodeName ? new a.Gradient("radial") : a[d(t.nodeName)] ? new a[d(t.nodeName)]() : new a.Element(t)).type = t.nodeName, i.node = t, t.instance = i, i instanceof a.Doc && i.namespace().defs(), i.setData(JSON.parse(t.getAttribute("svgjs:data")) || {}), i) : null;
    var i;
  }, a.prepare = function () {
    var t = i.getElementsByTagName("body")[0],
        e = (t ? new a.Doc(t) : a.adopt(i.documentElement).nested()).size(2, 0);
    a.parser = {
      body: t || i.documentElement,
      draw: e.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
      poly: e.polyline().node,
      path: e.path().node,
      "native": a.create("svg")
    };
  }, a.parser = {
    "native": a.create("svg")
  }, i.addEventListener("DOMContentLoaded", function () {
    a.parser.draw || a.prepare();
  }, !1), a.regex = {
    numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
    hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
    rgb: /rgb\((\d+),(\d+),(\d+)\)/,
    reference: /#([a-z0-9\-_]+)/i,
    transforms: /\)\s*,?\s*/,
    whitespace: /\s/g,
    isHex: /^#[a-f0-9]{3,6}$/i,
    isRgb: /^rgb\(/,
    isCss: /[^:]+:[^;]+;?/,
    isBlank: /^(\s+)?$/,
    isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    isPercent: /^-?[\d\.]+%$/,
    isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
    delimiter: /[\s,]+/,
    hyphen: /([^e])\-/gi,
    pathLetters: /[MLHVCSQTAZ]/gi,
    isPathLetter: /[MLHVCSQTAZ]/i,
    numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
    dots: /\./g
  }, a.utils = {
    map: function map(t, e) {
      for (var i = t.length, a = [], s = 0; s < i; s++) {
        a.push(e(t[s]));
      }

      return a;
    },
    filter: function filter(t, e) {
      for (var i = t.length, a = [], s = 0; s < i; s++) {
        e(t[s]) && a.push(t[s]);
      }

      return a;
    },
    filterSVGElements: function filterSVGElements(t) {
      return this.filter(t, function (t) {
        return t instanceof e.SVGElement;
      });
    }
  }, a.defaults = {
    attrs: {
      "fill-opacity": 1,
      "stroke-opacity": 1,
      "stroke-width": 0,
      "stroke-linejoin": "miter",
      "stroke-linecap": "butt",
      fill: "#000000",
      stroke: "#000000",
      opacity: 1,
      x: 0,
      y: 0,
      cx: 0,
      cy: 0,
      width: 0,
      height: 0,
      r: 0,
      rx: 0,
      ry: 0,
      offset: 0,
      "stop-opacity": 1,
      "stop-color": "#000000",
      "font-size": 16,
      "font-family": "Helvetica, Arial, sans-serif",
      "text-anchor": "start"
    }
  }, a.Color = function (e) {
    var i, s;
    this.r = 0, this.g = 0, this.b = 0, e && ("string" == typeof e ? a.regex.isRgb.test(e) ? (i = a.regex.rgb.exec(e.replace(a.regex.whitespace, "")), this.r = parseInt(i[1]), this.g = parseInt(i[2]), this.b = parseInt(i[3])) : a.regex.isHex.test(e) && (i = a.regex.hex.exec(4 == (s = e).length ? ["#", s.substring(1, 2), s.substring(1, 2), s.substring(2, 3), s.substring(2, 3), s.substring(3, 4), s.substring(3, 4)].join("") : s), this.r = parseInt(i[1], 16), this.g = parseInt(i[2], 16), this.b = parseInt(i[3], 16)) : "object" === t(e) && (this.r = e.r, this.g = e.g, this.b = e.b));
  }, a.extend(a.Color, {
    toString: function toString() {
      return this.toHex();
    },
    toHex: function toHex() {
      return "#" + g(this.r) + g(this.g) + g(this.b);
    },
    toRgb: function toRgb() {
      return "rgb(" + [this.r, this.g, this.b].join() + ")";
    },
    brightness: function brightness() {
      return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11;
    },
    morph: function morph(t) {
      return this.destination = new a.Color(t), this;
    },
    at: function at(t) {
      return this.destination ? (t = t < 0 ? 0 : t > 1 ? 1 : t, new a.Color({
        r: ~~(this.r + (this.destination.r - this.r) * t),
        g: ~~(this.g + (this.destination.g - this.g) * t),
        b: ~~(this.b + (this.destination.b - this.b) * t)
      })) : this;
    }
  }), a.Color.test = function (t) {
    return t += "", a.regex.isHex.test(t) || a.regex.isRgb.test(t);
  }, a.Color.isRgb = function (t) {
    return t && "number" == typeof t.r && "number" == typeof t.g && "number" == typeof t.b;
  }, a.Color.isColor = function (t) {
    return a.Color.isRgb(t) || a.Color.test(t);
  }, a.Array = function (t, e) {
    0 == (t = (t || []).valueOf()).length && e && (t = e.valueOf()), this.value = this.parse(t);
  }, a.extend(a.Array, {
    toString: function toString() {
      return this.value.join(" ");
    },
    valueOf: function valueOf() {
      return this.value;
    },
    parse: function parse(t) {
      return t = t.valueOf(), Array.isArray(t) ? t : this.split(t);
    }
  }), a.PointArray = function (t, e) {
    a.Array.call(this, t, e || [[0, 0]]);
  }, a.PointArray.prototype = new a.Array(), a.PointArray.prototype.constructor = a.PointArray;

  for (var s = {
    M: function M(t, e, i) {
      return e.x = i.x = t[0], e.y = i.y = t[1], ["M", e.x, e.y];
    },
    L: function L(t, e) {
      return e.x = t[0], e.y = t[1], ["L", t[0], t[1]];
    },
    H: function H(t, e) {
      return e.x = t[0], ["H", t[0]];
    },
    V: function V(t, e) {
      return e.y = t[0], ["V", t[0]];
    },
    C: function C(t, e) {
      return e.x = t[4], e.y = t[5], ["C", t[0], t[1], t[2], t[3], t[4], t[5]];
    },
    Q: function Q(t, e) {
      return e.x = t[2], e.y = t[3], ["Q", t[0], t[1], t[2], t[3]];
    },
    Z: function Z(t, e, i) {
      return e.x = i.x, e.y = i.y, ["Z"];
    }
  }, r = "mlhvqtcsaz".split(""), n = 0, o = r.length; n < o; ++n) {
    s[r[n]] = function (t) {
      return function (e, i, a) {
        if ("H" == t) e[0] = e[0] + i.x;else if ("V" == t) e[0] = e[0] + i.y;else if ("A" == t) e[5] = e[5] + i.x, e[6] = e[6] + i.y;else for (var r = 0, n = e.length; r < n; ++r) {
          e[r] = e[r] + (r % 2 ? i.y : i.x);
        }
        return s[t](e, i, a);
      };
    }(r[n].toUpperCase());
  }

  a.PathArray = function (t, e) {
    a.Array.call(this, t, e || [["M", 0, 0]]);
  }, a.PathArray.prototype = new a.Array(), a.PathArray.prototype.constructor = a.PathArray, a.extend(a.PathArray, {
    toString: function toString() {
      return function (t) {
        for (var e = 0, i = t.length, a = ""; e < i; e++) {
          a += t[e][0], null != t[e][1] && (a += t[e][1], null != t[e][2] && (a += " ", a += t[e][2], null != t[e][3] && (a += " ", a += t[e][3], a += " ", a += t[e][4], null != t[e][5] && (a += " ", a += t[e][5], a += " ", a += t[e][6], null != t[e][7] && (a += " ", a += t[e][7])))));
        }

        return a + " ";
      }(this.value);
    },
    move: function move(t, e) {
      var i = this.bbox();
      return i.x, i.y, this;
    },
    at: function at(t) {
      if (!this.destination) return this;

      for (var e = this.value, i = this.destination.value, s = [], r = new a.PathArray(), n = 0, o = e.length; n < o; n++) {
        s[n] = [e[n][0]];

        for (var l = 1, h = e[n].length; l < h; l++) {
          s[n][l] = e[n][l] + (i[n][l] - e[n][l]) * t;
        }

        "A" === s[n][0] && (s[n][4] = +(0 != s[n][4]), s[n][5] = +(0 != s[n][5]));
      }

      return r.value = s, r;
    },
    parse: function parse(t) {
      if (t instanceof a.PathArray) return t.valueOf();
      var e,
          i = {
        M: 2,
        L: 2,
        H: 1,
        V: 1,
        C: 6,
        S: 4,
        Q: 4,
        T: 2,
        A: 7,
        Z: 0
      };
      t = "string" == typeof t ? t.replace(a.regex.numbersWithDots, h).replace(a.regex.pathLetters, " $& ").replace(a.regex.hyphen, "$1 -").trim().split(a.regex.delimiter) : t.reduce(function (t, e) {
        return [].concat.call(t, e);
      }, []);
      var r = [],
          n = new a.Point(),
          o = new a.Point(),
          l = 0,
          c = t.length;

      do {
        a.regex.isPathLetter.test(t[l]) ? (e = t[l], ++l) : "M" == e ? e = "L" : "m" == e && (e = "l"), r.push(s[e].call(null, t.slice(l, l += i[e.toUpperCase()]).map(parseFloat), n, o));
      } while (c > l);

      return r;
    },
    bbox: function bbox() {
      return a.parser.draw || a.prepare(), a.parser.path.setAttribute("d", this.toString()), a.parser.path.getBBox();
    }
  }), a.Number = a.invent({
    create: function create(t, e) {
      this.value = 0, this.unit = e || "", "number" == typeof t ? this.value = isNaN(t) ? 0 : isFinite(t) ? t : t < 0 ? -34e37 : 34e37 : "string" == typeof t ? (e = t.match(a.regex.numberAndUnit)) && (this.value = parseFloat(e[1]), "%" == e[5] ? this.value /= 100 : "s" == e[5] && (this.value *= 1e3), this.unit = e[5]) : t instanceof a.Number && (this.value = t.valueOf(), this.unit = t.unit);
    },
    extend: {
      toString: function toString() {
        return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
      },
      toJSON: function toJSON() {
        return this.toString();
      },
      valueOf: function valueOf() {
        return this.value;
      },
      plus: function plus(t) {
        return t = new a.Number(t), new a.Number(this + t, this.unit || t.unit);
      },
      minus: function minus(t) {
        return t = new a.Number(t), new a.Number(this - t, this.unit || t.unit);
      },
      times: function times(t) {
        return t = new a.Number(t), new a.Number(this * t, this.unit || t.unit);
      },
      divide: function divide(t) {
        return t = new a.Number(t), new a.Number(this / t, this.unit || t.unit);
      },
      to: function to(t) {
        var e = new a.Number(this);
        return "string" == typeof t && (e.unit = t), e;
      },
      morph: function morph(t) {
        return this.destination = new a.Number(t), t.relative && (this.destination.value += this.value), this;
      },
      at: function at(t) {
        return this.destination ? new a.Number(this.destination).minus(this).times(t).plus(this) : this;
      }
    }
  }), a.Element = a.invent({
    create: function create(t) {
      this._stroke = a.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t) && (this.type = t.nodeName, this.node.instance = this, this._stroke = t.getAttribute("stroke") || this._stroke);
    },
    extend: {
      x: function x(t) {
        return this.attr("x", t);
      },
      y: function y(t) {
        return this.attr("y", t);
      },
      cx: function cx(t) {
        return null == t ? this.x() + this.width() / 2 : this.x(t - this.width() / 2);
      },
      cy: function cy(t) {
        return null == t ? this.y() + this.height() / 2 : this.y(t - this.height() / 2);
      },
      move: function move(t, e) {
        return this.x(t).y(e);
      },
      center: function center(t, e) {
        return this.cx(t).cy(e);
      },
      width: function width(t) {
        return this.attr("width", t);
      },
      height: function height(t) {
        return this.attr("height", t);
      },
      size: function size(t, e) {
        var i = u(this, t, e);
        return this.width(new a.Number(i.width)).height(new a.Number(i.height));
      },
      clone: function clone(t) {
        this.writeDataToDom();
        var e = x(this.node.cloneNode(!0));
        return t ? t.add(e) : this.after(e), e;
      },
      remove: function remove() {
        return this.parent() && this.parent().removeElement(this), this;
      },
      replace: function replace(t) {
        return this.after(t).remove(), t;
      },
      addTo: function addTo(t) {
        return t.put(this);
      },
      putIn: function putIn(t) {
        return t.add(this);
      },
      id: function id(t) {
        return this.attr("id", t);
      },
      show: function show() {
        return this.style("display", "");
      },
      hide: function hide() {
        return this.style("display", "none");
      },
      visible: function visible() {
        return "none" != this.style("display");
      },
      toString: function toString() {
        return this.attr("id");
      },
      classes: function classes() {
        var t = this.attr("class");
        return null == t ? [] : t.trim().split(a.regex.delimiter);
      },
      hasClass: function hasClass(t) {
        return -1 != this.classes().indexOf(t);
      },
      addClass: function addClass(t) {
        if (!this.hasClass(t)) {
          var e = this.classes();
          e.push(t), this.attr("class", e.join(" "));
        }

        return this;
      },
      removeClass: function removeClass(t) {
        return this.hasClass(t) && this.attr("class", this.classes().filter(function (e) {
          return e != t;
        }).join(" ")), this;
      },
      toggleClass: function toggleClass(t) {
        return this.hasClass(t) ? this.removeClass(t) : this.addClass(t);
      },
      reference: function reference(t) {
        return a.get(this.attr(t));
      },
      parent: function parent(t) {
        var i = this;
        if (!i.node.parentNode) return null;
        if (i = a.adopt(i.node.parentNode), !t) return i;

        for (; i && i.node instanceof e.SVGElement;) {
          if ("string" == typeof t ? i.matches(t) : i instanceof t) return i;
          if (!i.node.parentNode || "#document" == i.node.parentNode.nodeName) return null;
          i = a.adopt(i.node.parentNode);
        }
      },
      doc: function doc() {
        return this instanceof a.Doc ? this : this.parent(a.Doc);
      },
      parents: function parents(t) {
        var e = [],
            i = this;

        do {
          if (!(i = i.parent(t)) || !i.node) break;
          e.push(i);
        } while (i.parent);

        return e;
      },
      matches: function matches(t) {
        return function (t, e) {
          return (t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, e);
        }(this.node, t);
      },
      "native": function native() {
        return this.node;
      },
      svg: function svg(t) {
        var e = i.createElement("svg");
        if (!(t && this instanceof a.Parent)) return e.appendChild(t = i.createElement("svg")), this.writeDataToDom(), t.appendChild(this.node.cloneNode(!0)), e.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
        e.innerHTML = "<svg>" + t.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";

        for (var s = 0, r = e.firstChild.childNodes.length; s < r; s++) {
          this.node.appendChild(e.firstChild.firstChild);
        }

        return this;
      },
      writeDataToDom: function writeDataToDom() {
        return (this.each || this.lines) && (this.each ? this : this.lines()).each(function () {
          this.writeDataToDom();
        }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
      },
      setData: function setData(t) {
        return this.dom = t, this;
      },
      is: function is(t) {
        return function (t, e) {
          return t instanceof e;
        }(this, t);
      }
    }
  }), a.easing = {
    "-": function _(t) {
      return t;
    },
    "<>": function _(t) {
      return -Math.cos(t * Math.PI) / 2 + .5;
    },
    ">": function _(t) {
      return Math.sin(t * Math.PI / 2);
    },
    "<": function _(t) {
      return 1 - Math.cos(t * Math.PI / 2);
    }
  }, a.morph = function (t) {
    return function (e, i) {
      return new a.MorphObj(e, i).at(t);
    };
  }, a.Situation = a.invent({
    create: function create(t) {
      this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new a.Number(t.duration).valueOf(), this.delay = new a.Number(t.delay).valueOf(), this.start = +new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
    }
  }), a.FX = a.invent({
    create: function create(t) {
      this._target = t, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
    },
    extend: {
      animate: function animate(e, i, s) {
        "object" === t(e) && (i = e.ease, s = e.delay, e = e.duration);
        var r = new a.Situation({
          duration: e || 1e3,
          delay: s || 0,
          ease: a.easing[i || "-"] || i
        });
        return this.queue(r), this;
      },
      target: function target(t) {
        return t && t instanceof a.Element ? (this._target = t, this) : this._target;
      },
      timeToAbsPos: function timeToAbsPos(t) {
        return (t - this.situation.start) / (this.situation.duration / this._speed);
      },
      absPosToTime: function absPosToTime(t) {
        return this.situation.duration / this._speed * t + this.situation.start;
      },
      startAnimFrame: function startAnimFrame() {
        this.stopAnimFrame(), this.animationFrame = e.requestAnimationFrame(function () {
          this.step();
        }.bind(this));
      },
      stopAnimFrame: function stopAnimFrame() {
        e.cancelAnimationFrame(this.animationFrame);
      },
      start: function start() {
        return !this.active && this.situation && (this.active = !0, this.startCurrent()), this;
      },
      startCurrent: function startCurrent() {
        return this.situation.start = +new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
      },
      queue: function queue(t) {
        return ("function" == typeof t || t instanceof a.Situation) && this.situations.push(t), this.situation || (this.situation = this.situations.shift()), this;
      },
      dequeue: function dequeue() {
        return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a.Situation ? this.start() : this.situation.call(this)), this;
      },
      initAnimations: function initAnimations() {
        var t,
            e = this.situation;
        if (e.init) return this;

        for (var i in e.animations) {
          t = this.target()[i](), Array.isArray(t) || (t = [t]), Array.isArray(e.animations[i]) || (e.animations[i] = [e.animations[i]]);

          for (var s = t.length; s--;) {
            e.animations[i][s] instanceof a.Number && (t[s] = new a.Number(t[s])), e.animations[i][s] = t[s].morph(e.animations[i][s]);
          }
        }

        for (var i in e.attrs) {
          e.attrs[i] = new a.MorphObj(this.target().attr(i), e.attrs[i]);
        }

        for (var i in e.styles) {
          e.styles[i] = new a.MorphObj(this.target().style(i), e.styles[i]);
        }

        return e.initialTransformation = this.target().matrixify(), e.init = !0, this;
      },
      clearQueue: function clearQueue() {
        return this.situations = [], this;
      },
      clearCurrent: function clearCurrent() {
        return this.situation = null, this;
      },
      stop: function stop(t, e) {
        var i = this.active;
        return this.active = !1, e && this.clearQueue(), t && this.situation && (!i && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
      },
      after: function after(t) {
        var e = this.last();
        return this.target().on("finished.fx", function i(a) {
          a.detail.situation == e && (t.call(this, e), this.off("finished.fx", i));
        }), this._callStart();
      },
      during: function during(t) {
        var e = this.last(),
            i = function i(_i3) {
          _i3.detail.situation == e && t.call(this, _i3.detail.pos, a.morph(_i3.detail.pos), _i3.detail.eased, e);
        };

        return this.target().off("during.fx", i).on("during.fx", i), this.after(function () {
          this.off("during.fx", i);
        }), this._callStart();
      },
      afterAll: function afterAll(t) {
        var e = function e(i) {
          t.call(this), this.off("allfinished.fx", e);
        };

        return this.target().off("allfinished.fx", e).on("allfinished.fx", e), this._callStart();
      },
      last: function last() {
        return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
      },
      add: function add(t, e, i) {
        return this.last()[i || "animations"][t] = e, this._callStart();
      },
      step: function step(t) {
        var e, i, a;
        t || (this.absPos = this.timeToAbsPos(+new Date())), !1 !== this.situation.loops ? (e = Math.max(this.absPos, 0), i = Math.floor(e), !0 === this.situation.loops || i < this.situation.loops ? (this.pos = e - i, a = this.situation.loop, this.situation.loop = i) : (this.absPos = this.situation.loops, this.pos = 1, a = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
        var s = this.situation.ease(this.pos);

        for (var r in this.situation.once) {
          r > this.lastPos && r <= s && (this.situation.once[r].call(this.target(), this.pos, s), delete this.situation.once[r]);
        }

        return this.active && this.target().fire("during", {
          pos: this.pos,
          eased: s,
          fx: this,
          situation: this.situation
        }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", {
          fx: this,
          situation: this.situation
        }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s, this) : this;
      },
      eachAt: function eachAt() {
        var t,
            e = this,
            i = this.target(),
            s = this.situation;

        for (var r in s.animations) {
          t = [].concat(s.animations[r]).map(function (t) {
            return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t;
          }), i[r].apply(i, t);
        }

        for (var r in s.attrs) {
          t = [r].concat(s.attrs[r]).map(function (t) {
            return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t;
          }), i.attr.apply(i, t);
        }

        for (var r in s.styles) {
          t = [r].concat(s.styles[r]).map(function (t) {
            return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t;
          }), i.style.apply(i, t);
        }

        if (s.transforms.length) {
          t = s.initialTransformation, r = 0;

          for (var n = s.transforms.length; r < n; r++) {
            var o = s.transforms[r];
            o instanceof a.Matrix ? t = o.relative ? t.multiply(new a.Matrix().morph(o).at(s.ease(this.pos))) : t.morph(o).at(s.ease(this.pos)) : (o.relative || o.undo(t.extract()), t = t.multiply(o.at(s.ease(this.pos))));
          }

          i.matrix(t);
        }

        return this;
      },
      once: function once(t, e, i) {
        var a = this.last();
        return i || (t = a.ease(t)), a.once[t] = e, this;
      },
      _callStart: function _callStart() {
        return setTimeout(function () {
          this.start();
        }.bind(this), 0), this;
      }
    },
    parent: a.Element,
    construct: {
      animate: function animate(t, e, i) {
        return (this.fx || (this.fx = new a.FX(this))).animate(t, e, i);
      },
      delay: function delay(t) {
        return (this.fx || (this.fx = new a.FX(this))).delay(t);
      },
      stop: function stop(t, e) {
        return this.fx && this.fx.stop(t, e), this;
      },
      finish: function finish() {
        return this.fx && this.fx.finish(), this;
      }
    }
  }), a.MorphObj = a.invent({
    create: function create(t, e) {
      return a.Color.isColor(e) ? new a.Color(t).morph(e) : a.regex.delimiter.test(t) ? a.regex.pathLetters.test(t) ? new a.PathArray(t).morph(e) : new a.Array(t).morph(e) : a.regex.numberAndUnit.test(e) ? new a.Number(t).morph(e) : (this.value = t, void (this.destination = e));
    },
    extend: {
      at: function at(t, e) {
        return e < 1 ? this.value : this.destination;
      },
      valueOf: function valueOf() {
        return this.value;
      }
    }
  }), a.extend(a.FX, {
    attr: function attr(e, i, a) {
      if ("object" === t(e)) for (var s in e) {
        this.attr(s, e[s]);
      } else this.add(e, i, "attrs");
      return this;
    },
    plot: function plot(t, e, i, a) {
      return 4 == arguments.length ? this.plot([t, e, i, a]) : this.add("plot", new (this.target().morphArray)(t));
    }
  }), a.Box = a.invent({
    create: function create(e, i, s, r) {
      if (!("object" !== t(e) || e instanceof a.Element)) return a.Box.call(this, null != e.left ? e.left : e.x, null != e.top ? e.top : e.y, e.width, e.height);
      4 == arguments.length && (this.x = e, this.y = i, this.width = s, this.height = r), b(this);
    }
  }), a.BBox = a.invent({
    create: function create(t) {
      if (a.Box.apply(this, [].slice.call(arguments)), t instanceof a.Element) {
        var e;

        try {
          if (!i.documentElement.contains) {
            for (var s = t.node; s.parentNode;) {
              s = s.parentNode;
            }

            if (s != i) throw new Error("Element not in the dom");
          }

          e = t.node.getBBox();
        } catch (i) {
          if (t instanceof a.Shape) {
            a.parser.draw || a.prepare();
            var r = t.clone(a.parser.draw.instance).show();
            e = r.node.getBBox(), r.remove();
          } else e = {
            x: t.node.clientLeft,
            y: t.node.clientTop,
            width: t.node.clientWidth,
            height: t.node.clientHeight
          };
        }

        a.Box.call(this, e);
      }
    },
    inherit: a.Box,
    parent: a.Element,
    construct: {
      bbox: function bbox() {
        return new a.BBox(this);
      }
    }
  }), a.BBox.prototype.constructor = a.BBox, a.Matrix = a.invent({
    create: function create(e) {
      var i = p([1, 0, 0, 1, 0, 0]);
      e = e instanceof a.Element ? e.matrixify() : "string" == typeof e ? p(e.split(a.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? p([].slice.call(arguments)) : Array.isArray(e) ? p(e) : "object" === t(e) ? e : i;

      for (var s = v.length - 1; s >= 0; --s) {
        this[v[s]] = null != e[v[s]] ? e[v[s]] : i[v[s]];
      }
    },
    extend: {
      extract: function extract() {
        var t = f(this, 0, 1),
            e = (f(this, 1, 0), 180 / Math.PI * Math.atan2(t.y, t.x) - 90);
        return {
          x: this.e,
          y: this.f,
          transformedX: (this.e * Math.cos(e * Math.PI / 180) + this.f * Math.sin(e * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
          transformedY: (this.f * Math.cos(e * Math.PI / 180) + this.e * Math.sin(-e * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
          rotation: e,
          a: this.a,
          b: this.b,
          c: this.c,
          d: this.d,
          e: this.e,
          f: this.f,
          matrix: new a.Matrix(this)
        };
      },
      clone: function clone() {
        return new a.Matrix(this);
      },
      morph: function morph(t) {
        return this.destination = new a.Matrix(t), this;
      },
      multiply: function multiply(t) {
        return new a.Matrix(this["native"]().multiply(function (t) {
          return t instanceof a.Matrix || (t = new a.Matrix(t)), t;
        }(t)["native"]()));
      },
      inverse: function inverse() {
        return new a.Matrix(this["native"]().inverse());
      },
      translate: function translate(t, e) {
        return new a.Matrix(this["native"]().translate(t || 0, e || 0));
      },
      "native": function native() {
        for (var t = a.parser["native"].createSVGMatrix(), e = v.length - 1; e >= 0; e--) {
          t[v[e]] = this[v[e]];
        }

        return t;
      },
      toString: function toString() {
        return "matrix(" + m(this.a) + "," + m(this.b) + "," + m(this.c) + "," + m(this.d) + "," + m(this.e) + "," + m(this.f) + ")";
      }
    },
    parent: a.Element,
    construct: {
      ctm: function ctm() {
        return new a.Matrix(this.node.getCTM());
      },
      screenCTM: function screenCTM() {
        if (this instanceof a.Nested) {
          var t = this.rect(1, 1),
              e = t.node.getScreenCTM();
          return t.remove(), new a.Matrix(e);
        }

        return new a.Matrix(this.node.getScreenCTM());
      }
    }
  }), a.Point = a.invent({
    create: function create(e, i) {
      var a;
      a = Array.isArray(e) ? {
        x: e[0],
        y: e[1]
      } : "object" === t(e) ? {
        x: e.x,
        y: e.y
      } : null != e ? {
        x: e,
        y: null != i ? i : e
      } : {
        x: 0,
        y: 0
      }, this.x = a.x, this.y = a.y;
    },
    extend: {
      clone: function clone() {
        return new a.Point(this);
      },
      morph: function morph(t, e) {
        return this.destination = new a.Point(t, e), this;
      }
    }
  }), a.extend(a.Element, {
    point: function point(t, e) {
      return new a.Point(t, e).transform(this.screenCTM().inverse());
    }
  }), a.extend(a.Element, {
    attr: function attr(e, i, s) {
      if (null == e) {
        for (e = {}, s = (i = this.node.attributes).length - 1; s >= 0; s--) {
          e[i[s].nodeName] = a.regex.isNumber.test(i[s].nodeValue) ? parseFloat(i[s].nodeValue) : i[s].nodeValue;
        }

        return e;
      }

      if ("object" === t(e)) for (var r in e) {
        this.attr(r, e[r]);
      } else if (null === i) this.node.removeAttribute(e);else {
        if (null == i) return null == (i = this.node.getAttribute(e)) ? a.defaults.attrs[e] : a.regex.isNumber.test(i) ? parseFloat(i) : i;
        "stroke-width" == e ? this.attr("stroke", parseFloat(i) > 0 ? this._stroke : null) : "stroke" == e && (this._stroke = i), "fill" != e && "stroke" != e || (a.regex.isImage.test(i) && (i = this.doc().defs().image(i, 0, 0)), i instanceof a.Image && (i = this.doc().defs().pattern(0, 0, function () {
          this.add(i);
        }))), "number" == typeof i ? i = new a.Number(i) : a.Color.isColor(i) ? i = new a.Color(i) : Array.isArray(i) && (i = new a.Array(i)), "leading" == e ? this.leading && this.leading(i) : "string" == typeof s ? this.node.setAttributeNS(s, e, i.toString()) : this.node.setAttribute(e, i.toString()), !this.rebuild || "font-size" != e && "x" != e || this.rebuild(e, i);
      }
      return this;
    }
  }), a.extend(a.Element, {
    transform: function transform(e, i) {
      var s;
      return "object" !== t(e) ? (s = new a.Matrix(this).extract(), "string" == typeof e ? s[e] : s) : (s = new a.Matrix(this), i = !!i || !!e.relative, null != e.a && (s = i ? s.multiply(new a.Matrix(e)) : new a.Matrix(e)), this.attr("transform", s));
    }
  }), a.extend(a.Element, {
    untransform: function untransform() {
      return this.attr("transform", null);
    },
    matrixify: function matrixify() {
      return (this.attr("transform") || "").split(a.regex.transforms).slice(0, -1).map(function (t) {
        var e = t.trim().split("(");
        return [e[0], e[1].split(a.regex.delimiter).map(function (t) {
          return parseFloat(t);
        })];
      }).reduce(function (t, e) {
        return "matrix" == e[0] ? t.multiply(p(e[1])) : t[e[0]].apply(t, e[1]);
      }, new a.Matrix());
    },
    toParent: function toParent(t) {
      if (this == t) return this;
      var e = this.screenCTM(),
          i = t.screenCTM().inverse();
      return this.addTo(t).untransform().transform(i.multiply(e)), this;
    },
    toDoc: function toDoc() {
      return this.toParent(this.doc());
    }
  }), a.Transformation = a.invent({
    create: function create(e, i) {
      if (arguments.length > 1 && "boolean" != typeof i) return this.constructor.call(this, [].slice.call(arguments));
      if (Array.isArray(e)) for (var a = 0, s = this.arguments.length; a < s; ++a) {
        this[this.arguments[a]] = e[a];
      } else if ("object" === t(e)) for (a = 0, s = this.arguments.length; a < s; ++a) {
        this[this.arguments[a]] = e[this.arguments[a]];
      }
      this.inversed = !1, !0 === i && (this.inversed = !0);
    }
  }), a.Translate = a.invent({
    parent: a.Matrix,
    inherit: a.Transformation,
    create: function create(t, e) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ["transformedX", "transformedY"],
      method: "translate"
    }
  }), a.extend(a.Element, {
    style: function style(e, i) {
      if (0 == arguments.length) return this.node.style.cssText || "";
      if (arguments.length < 2) {
        if ("object" === t(e)) for (var s in e) {
          this.style(s, e[s]);
        } else {
          if (!a.regex.isCss.test(e)) return this.node.style[c(e)];

          for (e = e.split(/\s*;\s*/).filter(function (t) {
            return !!t;
          }).map(function (t) {
            return t.split(/\s*:\s*/);
          }); i = e.pop();) {
            this.style(i[0], i[1]);
          }
        }
      } else this.node.style[c(e)] = null === i || a.regex.isBlank.test(i) ? "" : i;
      return this;
    }
  }), a.Parent = a.invent({
    create: function create(t) {
      this.constructor.call(this, t);
    },
    inherit: a.Element,
    extend: {
      children: function children() {
        return a.utils.map(a.utils.filterSVGElements(this.node.childNodes), function (t) {
          return a.adopt(t);
        });
      },
      add: function add(t, e) {
        return null == e ? this.node.appendChild(t.node) : t.node != this.node.childNodes[e] && this.node.insertBefore(t.node, this.node.childNodes[e]), this;
      },
      put: function put(t, e) {
        return this.add(t, e), t;
      },
      has: function has(t) {
        return this.index(t) >= 0;
      },
      index: function index(t) {
        return [].slice.call(this.node.childNodes).indexOf(t.node);
      },
      get: function get(t) {
        return a.adopt(this.node.childNodes[t]);
      },
      first: function first() {
        return this.get(0);
      },
      last: function last() {
        return this.get(this.node.childNodes.length - 1);
      },
      each: function each(t, e) {
        for (var i = this.children(), s = 0, r = i.length; s < r; s++) {
          i[s] instanceof a.Element && t.apply(i[s], [s, i]), e && i[s] instanceof a.Container && i[s].each(t, e);
        }

        return this;
      },
      removeElement: function removeElement(t) {
        return this.node.removeChild(t.node), this;
      },
      clear: function clear() {
        for (; this.node.hasChildNodes();) {
          this.node.removeChild(this.node.lastChild);
        }

        return delete this._defs, this;
      },
      defs: function defs() {
        return this.doc().defs();
      }
    }
  }), a.extend(a.Parent, {
    ungroup: function ungroup(t, e) {
      return 0 === e || this instanceof a.Defs || this.node == a.parser.draw || (t = t || (this instanceof a.Doc ? this : this.parent(a.Parent)), e = e || 1 / 0, this.each(function () {
        return this instanceof a.Defs ? this : this instanceof a.Parent ? this.ungroup(t, e - 1) : this.toParent(t);
      }), this.node.firstChild || this.remove()), this;
    },
    flatten: function flatten(t, e) {
      return this.ungroup(t, e);
    }
  }), a.Container = a.invent({
    create: function create(t) {
      this.constructor.call(this, t);
    },
    inherit: a.Parent
  }), a.ViewBox = a.invent({
    parent: a.Container,
    construct: {}
  }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function (t) {
    a.Element.prototype[t] = function (e) {
      return a.on(this.node, t, e), this;
    };
  }), a.listeners = [], a.handlerMap = [], a.listenerId = 0, a.on = function (t, e, i, s, r) {
    var n = i.bind(s || t.instance || t),
        o = (a.handlerMap.indexOf(t) + 1 || a.handlerMap.push(t)) - 1,
        l = e.split(".")[0],
        h = e.split(".")[1] || "*";
    a.listeners[o] = a.listeners[o] || {}, a.listeners[o][l] = a.listeners[o][l] || {}, a.listeners[o][l][h] = a.listeners[o][l][h] || {}, i._svgjsListenerId || (i._svgjsListenerId = ++a.listenerId), a.listeners[o][l][h][i._svgjsListenerId] = n, t.addEventListener(l, n, r || {
      passive: !0
    });
  }, a.off = function (t, e, i) {
    var s = a.handlerMap.indexOf(t),
        r = e && e.split(".")[0],
        n = e && e.split(".")[1],
        o = "";
    if (-1 != s) if (i) {
      if ("function" == typeof i && (i = i._svgjsListenerId), !i) return;
      a.listeners[s][r] && a.listeners[s][r][n || "*"] && (t.removeEventListener(r, a.listeners[s][r][n || "*"][i], !1), delete a.listeners[s][r][n || "*"][i]);
    } else if (n && r) {
      if (a.listeners[s][r] && a.listeners[s][r][n]) {
        for (var l in a.listeners[s][r][n]) {
          a.off(t, [r, n].join("."), l);
        }

        delete a.listeners[s][r][n];
      }
    } else if (n) for (var h in a.listeners[s]) {
      for (var o in a.listeners[s][h]) {
        n === o && a.off(t, [h, n].join("."));
      }
    } else if (r) {
      if (a.listeners[s][r]) {
        for (var o in a.listeners[s][r]) {
          a.off(t, [r, o].join("."));
        }

        delete a.listeners[s][r];
      }
    } else {
      for (var h in a.listeners[s]) {
        a.off(t, h);
      }

      delete a.listeners[s], delete a.handlerMap[s];
    }
  }, a.extend(a.Element, {
    on: function on(t, e, i, s) {
      return a.on(this.node, t, e, i, s), this;
    },
    off: function off(t, e) {
      return a.off(this.node, t, e), this;
    },
    fire: function fire(t, i) {
      return t instanceof e.Event ? this.node.dispatchEvent(t) : this.node.dispatchEvent(t = new a.CustomEvent(t, {
        detail: i,
        cancelable: !0
      })), this._event = t, this;
    },
    event: function event() {
      return this._event;
    }
  }), a.Defs = a.invent({
    create: "defs",
    inherit: a.Container
  }), a.G = a.invent({
    create: "g",
    inherit: a.Container,
    extend: {
      x: function x(t) {
        return null == t ? this.transform("x") : this.transform({
          x: t - this.x()
        }, !0);
      }
    },
    construct: {
      group: function group() {
        return this.put(new a.G());
      }
    }
  }), a.Doc = a.invent({
    create: function create(t) {
      t && ("svg" == (t = "string" == typeof t ? i.getElementById(t) : t).nodeName ? this.constructor.call(this, t) : (this.constructor.call(this, a.create("svg")), t.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
    },
    inherit: a.Container,
    extend: {
      namespace: function namespace() {
        return this.attr({
          xmlns: a.ns,
          version: "1.1"
        }).attr("xmlns:xlink", a.xlink, a.xmlns).attr("xmlns:svgjs", a.svgjs, a.xmlns);
      },
      defs: function defs() {
        var t;
        return this._defs || ((t = this.node.getElementsByTagName("defs")[0]) ? this._defs = a.adopt(t) : this._defs = new a.Defs(), this.node.appendChild(this._defs.node)), this._defs;
      },
      parent: function parent() {
        return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
      },
      remove: function remove() {
        return this.parent() && this.parent().removeChild(this.node), this;
      },
      clear: function clear() {
        for (; this.node.hasChildNodes();) {
          this.node.removeChild(this.node.lastChild);
        }

        return delete this._defs, a.parser.draw && !a.parser.draw.parentNode && this.node.appendChild(a.parser.draw), this;
      },
      clone: function clone(t) {
        this.writeDataToDom();
        var e = this.node,
            i = x(e.cloneNode(!0));
        return t ? (t.node || t).appendChild(i.node) : e.parentNode.insertBefore(i.node, e.nextSibling), i;
      }
    }
  }), a.extend(a.Element, {}), a.Gradient = a.invent({
    create: function create(t) {
      this.constructor.call(this, a.create(t + "Gradient")), this.type = t;
    },
    inherit: a.Container,
    extend: {
      at: function at(t, e, i) {
        return this.put(new a.Stop()).update(t, e, i);
      },
      update: function update(t) {
        return this.clear(), "function" == typeof t && t.call(this, this), this;
      },
      fill: function fill() {
        return "url(#" + this.id() + ")";
      },
      toString: function toString() {
        return this.fill();
      },
      attr: function attr(t, e, i) {
        return "transform" == t && (t = "gradientTransform"), a.Container.prototype.attr.call(this, t, e, i);
      }
    },
    construct: {
      gradient: function gradient(t, e) {
        return this.defs().gradient(t, e);
      }
    }
  }), a.extend(a.Gradient, a.FX, {
    from: function from(t, e) {
      return "radial" == (this._target || this).type ? this.attr({
        fx: new a.Number(t),
        fy: new a.Number(e)
      }) : this.attr({
        x1: new a.Number(t),
        y1: new a.Number(e)
      });
    },
    to: function to(t, e) {
      return "radial" == (this._target || this).type ? this.attr({
        cx: new a.Number(t),
        cy: new a.Number(e)
      }) : this.attr({
        x2: new a.Number(t),
        y2: new a.Number(e)
      });
    }
  }), a.extend(a.Defs, {
    gradient: function gradient(t, e) {
      return this.put(new a.Gradient(t)).update(e);
    }
  }), a.Stop = a.invent({
    create: "stop",
    inherit: a.Element,
    extend: {
      update: function update(t) {
        return ("number" == typeof t || t instanceof a.Number) && (t = {
          offset: arguments[0],
          color: arguments[1],
          opacity: arguments[2]
        }), null != t.opacity && this.attr("stop-opacity", t.opacity), null != t.color && this.attr("stop-color", t.color), null != t.offset && this.attr("offset", new a.Number(t.offset)), this;
      }
    }
  }), a.Pattern = a.invent({
    create: "pattern",
    inherit: a.Container,
    extend: {
      fill: function fill() {
        return "url(#" + this.id() + ")";
      },
      update: function update(t) {
        return this.clear(), "function" == typeof t && t.call(this, this), this;
      },
      toString: function toString() {
        return this.fill();
      },
      attr: function attr(t, e, i) {
        return "transform" == t && (t = "patternTransform"), a.Container.prototype.attr.call(this, t, e, i);
      }
    },
    construct: {
      pattern: function pattern(t, e, i) {
        return this.defs().pattern(t, e, i);
      }
    }
  }), a.extend(a.Defs, {
    pattern: function pattern(t, e, i) {
      return this.put(new a.Pattern()).update(i).attr({
        x: 0,
        y: 0,
        width: t,
        height: e,
        patternUnits: "userSpaceOnUse"
      });
    }
  }), a.Shape = a.invent({
    create: function create(t) {
      this.constructor.call(this, t);
    },
    inherit: a.Element
  }), a.Symbol = a.invent({
    create: "symbol",
    inherit: a.Container,
    construct: {
      symbol: function symbol() {
        return this.put(new a.Symbol());
      }
    }
  }), a.Use = a.invent({
    create: "use",
    inherit: a.Shape,
    extend: {
      element: function element(t, e) {
        return this.attr("href", (e || "") + "#" + t, a.xlink);
      }
    },
    construct: {
      use: function use(t, e) {
        return this.put(new a.Use()).element(t, e);
      }
    }
  }), a.Rect = a.invent({
    create: "rect",
    inherit: a.Shape,
    construct: {
      rect: function rect(t, e) {
        return this.put(new a.Rect()).size(t, e);
      }
    }
  }), a.Circle = a.invent({
    create: "circle",
    inherit: a.Shape,
    construct: {
      circle: function circle(t) {
        return this.put(new a.Circle()).rx(new a.Number(t).divide(2)).move(0, 0);
      }
    }
  }), a.extend(a.Circle, a.FX, {
    rx: function rx(t) {
      return this.attr("r", t);
    },
    ry: function ry(t) {
      return this.rx(t);
    }
  }), a.Ellipse = a.invent({
    create: "ellipse",
    inherit: a.Shape,
    construct: {
      ellipse: function ellipse(t, e) {
        return this.put(new a.Ellipse()).size(t, e).move(0, 0);
      }
    }
  }), a.extend(a.Ellipse, a.Rect, a.FX, {
    rx: function rx(t) {
      return this.attr("rx", t);
    },
    ry: function ry(t) {
      return this.attr("ry", t);
    }
  }), a.extend(a.Circle, a.Ellipse, {
    x: function x(t) {
      return null == t ? this.cx() - this.rx() : this.cx(t + this.rx());
    },
    y: function y(t) {
      return null == t ? this.cy() - this.ry() : this.cy(t + this.ry());
    },
    cx: function cx(t) {
      return null == t ? this.attr("cx") : this.attr("cx", t);
    },
    cy: function cy(t) {
      return null == t ? this.attr("cy") : this.attr("cy", t);
    },
    width: function width(t) {
      return null == t ? 2 * this.rx() : this.rx(new a.Number(t).divide(2));
    },
    height: function height(t) {
      return null == t ? 2 * this.ry() : this.ry(new a.Number(t).divide(2));
    },
    size: function size(t, e) {
      var i = u(this, t, e);
      return this.rx(new a.Number(i.width).divide(2)).ry(new a.Number(i.height).divide(2));
    }
  }), a.Line = a.invent({
    create: "line",
    inherit: a.Shape,
    extend: {
      array: function array() {
        return new a.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
      },
      plot: function plot(t, e, i, s) {
        return null == t ? this.array() : (t = void 0 !== e ? {
          x1: t,
          y1: e,
          x2: i,
          y2: s
        } : new a.PointArray(t).toLine(), this.attr(t));
      },
      move: function move(t, e) {
        return this.attr(this.array().move(t, e).toLine());
      },
      size: function size(t, e) {
        var i = u(this, t, e);
        return this.attr(this.array().size(i.width, i.height).toLine());
      }
    },
    construct: {
      line: function line(t, e, i, s) {
        return a.Line.prototype.plot.apply(this.put(new a.Line()), null != t ? [t, e, i, s] : [0, 0, 0, 0]);
      }
    }
  }), a.Polyline = a.invent({
    create: "polyline",
    inherit: a.Shape,
    construct: {
      polyline: function polyline(t) {
        return this.put(new a.Polyline()).plot(t || new a.PointArray());
      }
    }
  }), a.Polygon = a.invent({
    create: "polygon",
    inherit: a.Shape,
    construct: {
      polygon: function polygon(t) {
        return this.put(new a.Polygon()).plot(t || new a.PointArray());
      }
    }
  }), a.extend(a.Polyline, a.Polygon, {
    array: function array() {
      return this._array || (this._array = new a.PointArray(this.attr("points")));
    },
    plot: function plot(t) {
      return null == t ? this.array() : this.clear().attr("points", "string" == typeof t ? t : this._array = new a.PointArray(t));
    },
    clear: function clear() {
      return delete this._array, this;
    },
    move: function move(t, e) {
      return this.attr("points", this.array().move(t, e));
    },
    size: function size(t, e) {
      var i = u(this, t, e);
      return this.attr("points", this.array().size(i.width, i.height));
    }
  }), a.extend(a.Line, a.Polyline, a.Polygon, {
    morphArray: a.PointArray,
    x: function x(t) {
      return null == t ? this.bbox().x : this.move(t, this.bbox().y);
    },
    y: function y(t) {
      return null == t ? this.bbox().y : this.move(this.bbox().x, t);
    },
    width: function width(t) {
      var e = this.bbox();
      return null == t ? e.width : this.size(t, e.height);
    },
    height: function height(t) {
      var e = this.bbox();
      return null == t ? e.height : this.size(e.width, t);
    }
  }), a.Path = a.invent({
    create: "path",
    inherit: a.Shape,
    extend: {
      morphArray: a.PathArray,
      array: function array() {
        return this._array || (this._array = new a.PathArray(this.attr("d")));
      },
      plot: function plot(t) {
        return null == t ? this.array() : this.clear().attr("d", "string" == typeof t ? t : this._array = new a.PathArray(t));
      },
      clear: function clear() {
        return delete this._array, this;
      }
    },
    construct: {
      path: function path(t) {
        return this.put(new a.Path()).plot(t || new a.PathArray());
      }
    }
  }), a.Image = a.invent({
    create: "image",
    inherit: a.Shape,
    extend: {
      load: function load(t) {
        if (!t) return this;
        var i = this,
            s = new e.Image();
        return a.on(s, "load", function () {
          a.off(s);
          var e = i.parent(a.Pattern);
          null !== e && (0 == i.width() && 0 == i.height() && i.size(s.width, s.height), e && 0 == e.width() && 0 == e.height() && e.size(i.width(), i.height()), "function" == typeof i._loaded && i._loaded.call(i, {
            width: s.width,
            height: s.height,
            ratio: s.width / s.height,
            url: t
          }));
        }), a.on(s, "error", function (t) {
          a.off(s), "function" == typeof i._error && i._error.call(i, t);
        }), this.attr("href", s.src = this.src = t, a.xlink);
      },
      loaded: function loaded(t) {
        return this._loaded = t, this;
      },
      error: function error(t) {
        return this._error = t, this;
      }
    },
    construct: {
      image: function image(t, e, i) {
        return this.put(new a.Image()).load(t).size(e || 0, i || e || 0);
      }
    }
  }), a.Text = a.invent({
    create: function create() {
      this.constructor.call(this, a.create("text")), this.dom.leading = new a.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", a.defaults.attrs["font-family"]);
    },
    inherit: a.Shape,
    extend: {
      x: function x(t) {
        return null == t ? this.attr("x") : this.attr("x", t);
      },
      text: function text(t) {
        if (void 0 === t) {
          t = "";

          for (var e = this.node.childNodes, i = 0, s = e.length; i < s; ++i) {
            0 != i && 3 != e[i].nodeType && 1 == a.adopt(e[i]).dom.newLined && (t += "\n"), t += e[i].textContent;
          }

          return t;
        }

        if (this.clear().build(!0), "function" == typeof t) t.call(this, this);else {
          i = 0;

          for (var r = (t = t.split("\n")).length; i < r; i++) {
            this.tspan(t[i]).newLine();
          }
        }
        return this.build(!1).rebuild();
      },
      size: function size(t) {
        return this.attr("font-size", t).rebuild();
      },
      leading: function leading(t) {
        return null == t ? this.dom.leading : (this.dom.leading = new a.Number(t), this.rebuild());
      },
      lines: function lines() {
        var t = (this.textPath && this.textPath() || this).node,
            e = a.utils.map(a.utils.filterSVGElements(t.childNodes), function (t) {
          return a.adopt(t);
        });
        return new a.Set(e);
      },
      rebuild: function rebuild(t) {
        if ("boolean" == typeof t && (this._rebuild = t), this._rebuild) {
          var e = this,
              i = 0,
              s = this.dom.leading * new a.Number(this.attr("font-size"));
          this.lines().each(function () {
            this.dom.newLined && (e.textPath() || this.attr("x", e.attr("x")), "\n" == this.text() ? i += s : (this.attr("dy", s + i), i = 0));
          }), this.fire("rebuild");
        }

        return this;
      },
      build: function build(t) {
        return this._build = !!t, this;
      },
      setData: function setData(t) {
        return this.dom = t, this.dom.leading = new a.Number(t.leading || 1.3), this;
      }
    },
    construct: {
      text: function text(t) {
        return this.put(new a.Text()).text(t);
      },
      plain: function plain(t) {
        return this.put(new a.Text()).plain(t);
      }
    }
  }), a.Tspan = a.invent({
    create: "tspan",
    inherit: a.Shape,
    extend: {
      text: function text(t) {
        return null == t ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t ? t.call(this, this) : this.plain(t), this);
      },
      dx: function dx(t) {
        return this.attr("dx", t);
      },
      dy: function dy(t) {
        return this.attr("dy", t);
      },
      newLine: function newLine() {
        var t = this.parent(a.Text);
        return this.dom.newLined = !0, this.dy(t.dom.leading * t.attr("font-size")).attr("x", t.x());
      }
    }
  }), a.extend(a.Text, a.Tspan, {
    plain: function plain(t) {
      return !1 === this._build && this.clear(), this.node.appendChild(i.createTextNode(t)), this;
    },
    tspan: function tspan(t) {
      var e = (this.textPath && this.textPath() || this).node,
          i = new a.Tspan();
      return !1 === this._build && this.clear(), e.appendChild(i.node), i.text(t);
    },
    clear: function clear() {
      for (var t = (this.textPath && this.textPath() || this).node; t.hasChildNodes();) {
        t.removeChild(t.lastChild);
      }

      return this;
    },
    length: function length() {
      return this.node.getComputedTextLength();
    }
  }), a.TextPath = a.invent({
    create: "textPath",
    inherit: a.Parent,
    parent: a.Text,
    construct: {
      morphArray: a.PathArray,
      array: function array() {
        var t = this.track();
        return t ? t.array() : null;
      },
      plot: function plot(t) {
        var e = this.track(),
            i = null;
        return e && (i = e.plot(t)), null == t ? i : this;
      },
      track: function track() {
        var t = this.textPath();
        if (t) return t.reference("href");
      },
      textPath: function textPath() {
        if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return a.adopt(this.node.firstChild);
      }
    }
  }), a.Nested = a.invent({
    create: function create() {
      this.constructor.call(this, a.create("svg")), this.style("overflow", "visible");
    },
    inherit: a.Container,
    construct: {
      nested: function nested() {
        return this.put(new a.Nested());
      }
    }
  });
  var l = {
    stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
    fill: ["color", "opacity", "rule"],
    prefix: function prefix(t, e) {
      return "color" == e ? t : t + "-" + e;
    }
  };

  function h(t, e, i, s) {
    return i + s.replace(a.regex.dots, " .");
  }

  function c(t) {
    return t.toLowerCase().replace(/-(.)/g, function (t, e) {
      return e.toUpperCase();
    });
  }

  function d(t) {
    return t.charAt(0).toUpperCase() + t.slice(1);
  }

  function g(t) {
    var e = t.toString(16);
    return 1 == e.length ? "0" + e : e;
  }

  function u(t, e, i) {
    if (null == e || null == i) {
      var a = t.bbox();
      null == e ? e = a.width / a.height * i : null == i && (i = a.height / a.width * e);
    }

    return {
      width: e,
      height: i
    };
  }

  function f(t, e, i) {
    return {
      x: e * t.a + i * t.c + 0,
      y: e * t.b + i * t.d + 0
    };
  }

  function p(t) {
    return {
      a: t[0],
      b: t[1],
      c: t[2],
      d: t[3],
      e: t[4],
      f: t[5]
    };
  }

  function x(t) {
    for (var i = t.childNodes.length - 1; i >= 0; i--) {
      t.childNodes[i] instanceof e.SVGElement && x(t.childNodes[i]);
    }

    return a.adopt(t).id(a.eid(t.nodeName));
  }

  function b(t) {
    return null == t.x && (t.x = 0, t.y = 0, t.width = 0, t.height = 0), t.w = t.width, t.h = t.height, t.x2 = t.x + t.width, t.y2 = t.y + t.height, t.cx = t.x + t.width / 2, t.cy = t.y + t.height / 2, t;
  }

  function m(t) {
    return Math.abs(t) > 1e-37 ? t : 0;
  }

  ["fill", "stroke"].forEach(function (t) {
    var e = {};
    e[t] = function (e) {
      if (void 0 === e) return this;
      if ("string" == typeof e || a.Color.isRgb(e) || e && "function" == typeof e.fill) this.attr(t, e);else for (var i = l[t].length - 1; i >= 0; i--) {
        null != e[l[t][i]] && this.attr(l.prefix(t, l[t][i]), e[l[t][i]]);
      }
      return this;
    }, a.extend(a.Element, a.FX, e);
  }), a.extend(a.Element, a.FX, {
    translate: function translate(t, e) {
      return this.transform({
        x: t,
        y: e
      });
    },
    matrix: function matrix(t) {
      return this.attr("transform", new a.Matrix(6 == arguments.length ? [].slice.call(arguments) : t));
    },
    opacity: function opacity(t) {
      return this.attr("opacity", t);
    },
    dx: function dx(t) {
      return this.x(new a.Number(t).plus(this instanceof a.FX ? 0 : this.x()), !0);
    },
    dy: function dy(t) {
      return this.y(new a.Number(t).plus(this instanceof a.FX ? 0 : this.y()), !0);
    }
  }), a.extend(a.Path, {
    length: function length() {
      return this.node.getTotalLength();
    },
    pointAt: function pointAt(t) {
      return this.node.getPointAtLength(t);
    }
  }), a.Set = a.invent({
    create: function create(t) {
      Array.isArray(t) ? this.members = t : this.clear();
    },
    extend: {
      add: function add() {
        for (var t = [].slice.call(arguments), e = 0, i = t.length; e < i; e++) {
          this.members.push(t[e]);
        }

        return this;
      },
      remove: function remove(t) {
        var e = this.index(t);
        return e > -1 && this.members.splice(e, 1), this;
      },
      each: function each(t) {
        for (var e = 0, i = this.members.length; e < i; e++) {
          t.apply(this.members[e], [e, this.members]);
        }

        return this;
      },
      clear: function clear() {
        return this.members = [], this;
      },
      length: function length() {
        return this.members.length;
      },
      has: function has(t) {
        return this.index(t) >= 0;
      },
      index: function index(t) {
        return this.members.indexOf(t);
      },
      get: function get(t) {
        return this.members[t];
      },
      first: function first() {
        return this.get(0);
      },
      last: function last() {
        return this.get(this.members.length - 1);
      },
      valueOf: function valueOf() {
        return this.members;
      }
    },
    construct: {
      set: function set(t) {
        return new a.Set(t);
      }
    }
  }), a.FX.Set = a.invent({
    create: function create(t) {
      this.set = t;
    }
  }), a.Set.inherit = function () {
    var t = [];

    for (var e in a.Shape.prototype) {
      "function" == typeof a.Shape.prototype[e] && "function" != typeof a.Set.prototype[e] && t.push(e);
    }

    for (var e in t.forEach(function (t) {
      a.Set.prototype[t] = function () {
        for (var e = 0, i = this.members.length; e < i; e++) {
          this.members[e] && "function" == typeof this.members[e][t] && this.members[e][t].apply(this.members[e], arguments);
        }

        return "animate" == t ? this.fx || (this.fx = new a.FX.Set(this)) : this;
      };
    }), t = [], a.FX.prototype) {
      "function" == typeof a.FX.prototype[e] && "function" != typeof a.FX.Set.prototype[e] && t.push(e);
    }

    t.forEach(function (t) {
      a.FX.Set.prototype[t] = function () {
        for (var e = 0, i = this.set.members.length; e < i; e++) {
          this.set.members[e].fx[t].apply(this.set.members[e].fx, arguments);
        }

        return this;
      };
    });
  }, a.extend(a.Element, {}), a.extend(a.Element, {
    remember: function remember(e, i) {
      if ("object" === t(arguments[0])) for (var a in e) {
        this.remember(a, e[a]);
      } else {
        if (1 == arguments.length) return this.memory()[e];
        this.memory()[e] = i;
      }
      return this;
    },
    forget: function forget() {
      if (0 == arguments.length) this._memory = {};else for (var t = arguments.length - 1; t >= 0; t--) {
        delete this.memory()[arguments[t]];
      }
      return this;
    },
    memory: function memory() {
      return this._memory || (this._memory = {});
    }
  }), a.get = function (t) {
    var e = i.getElementById(function (t) {
      var e = (t || "").toString().match(a.regex.reference);
      if (e) return e[1];
    }(t) || t);
    return a.adopt(e);
  }, a.select = function (t, e) {
    return new a.Set(a.utils.map((e || i).querySelectorAll(t), function (t) {
      return a.adopt(t);
    }));
  }, a.extend(a.Parent, {
    select: function select(t) {
      return a.select(t, this.node);
    }
  });
  var v = "abcdef".split("");

  if ("function" != typeof e.CustomEvent) {
    var y = function y(t, e) {
      e = e || {
        bubbles: !1,
        cancelable: !1,
        detail: void 0
      };
      var a = i.createEvent("CustomEvent");
      return a.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), a;
    };

    y.prototype = e.Event.prototype, a.CustomEvent = y;
  } else a.CustomEvent = e.CustomEvent;

  return a;
},  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  return zt(Tt, Tt.document);
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined,
/*! svg.filter.js - v2.0.2 - 2016-02-24
* https://github.com/wout/svg.filter.js
* Copyright (c) 2016 Wout Fierens; Licensed MIT */
function () {
  SVG.Filter = SVG.invent({
    create: "filter",
    inherit: SVG.Parent,
    extend: {
      source: "SourceGraphic",
      sourceAlpha: "SourceAlpha",
      background: "BackgroundImage",
      backgroundAlpha: "BackgroundAlpha",
      fill: "FillPaint",
      stroke: "StrokePaint",
      autoSetIn: !0,
      put: function put(t, e) {
        return this.add(t, e), !t.attr("in") && this.autoSetIn && t.attr("in", this.source), t.attr("result") || t.attr("result", t), t;
      },
      blend: function blend(t, e, i) {
        return this.put(new SVG.BlendEffect(t, e, i));
      },
      colorMatrix: function colorMatrix(t, e) {
        return this.put(new SVG.ColorMatrixEffect(t, e));
      },
      convolveMatrix: function convolveMatrix(t) {
        return this.put(new SVG.ConvolveMatrixEffect(t));
      },
      componentTransfer: function componentTransfer(t) {
        return this.put(new SVG.ComponentTransferEffect(t));
      },
      composite: function composite(t, e, i) {
        return this.put(new SVG.CompositeEffect(t, e, i));
      },
      flood: function flood(t, e) {
        return this.put(new SVG.FloodEffect(t, e));
      },
      offset: function offset(t, e) {
        return this.put(new SVG.OffsetEffect(t, e));
      },
      image: function image(t) {
        return this.put(new SVG.ImageEffect(t));
      },
      merge: function merge() {
        var t = [void 0];

        for (var e in arguments) {
          t.push(arguments[e]);
        }

        return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t))());
      },
      gaussianBlur: function gaussianBlur(t, e) {
        return this.put(new SVG.GaussianBlurEffect(t, e));
      },
      morphology: function morphology(t, e) {
        return this.put(new SVG.MorphologyEffect(t, e));
      },
      diffuseLighting: function diffuseLighting(t, e, i) {
        return this.put(new SVG.DiffuseLightingEffect(t, e, i));
      },
      displacementMap: function displacementMap(t, e, i, a, s) {
        return this.put(new SVG.DisplacementMapEffect(t, e, i, a, s));
      },
      specularLighting: function specularLighting(t, e, i, a) {
        return this.put(new SVG.SpecularLightingEffect(t, e, i, a));
      },
      tile: function tile() {
        return this.put(new SVG.TileEffect());
      },
      turbulence: function turbulence(t, e, i, a, s) {
        return this.put(new SVG.TurbulenceEffect(t, e, i, a, s));
      },
      toString: function toString() {
        return "url(#" + this.attr("id") + ")";
      }
    }
  }), SVG.extend(SVG.Defs, {
    filter: function filter(t) {
      var e = this.put(new SVG.Filter());
      return "function" == typeof t && t.call(e, e), e;
    }
  }), SVG.extend(SVG.Container, {
    filter: function filter(t) {
      return this.defs().filter(t);
    }
  }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
    filter: function filter(t) {
      return this.filterer = t instanceof SVG.Element ? t : this.doc().filter(t), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    },
    unfilter: function unfilter(t) {
      return this.filterer && !0 === t && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    }
  }), SVG.Effect = SVG.invent({
    create: function create() {
      this.constructor.call(this);
    },
    inherit: SVG.Element,
    extend: {
      "in": function _in(t) {
        return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t);
      },
      result: function result(t) {
        return null == t ? this.attr("result") : this.attr("result", t);
      },
      toString: function toString() {
        return this.result();
      }
    }
  }), SVG.ParentEffect = SVG.invent({
    create: function create() {
      this.constructor.call(this);
    },
    inherit: SVG.Parent,
    extend: {
      "in": function _in(t) {
        return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t);
      },
      result: function result(t) {
        return null == t ? this.attr("result") : this.attr("result", t);
      },
      toString: function toString() {
        return this.result();
      }
    }
  });
  var t = {
    blend: function blend(t, e) {
      return this.parent() && this.parent().blend(this, t, e);
    },
    colorMatrix: function colorMatrix(t, e) {
      return this.parent() && this.parent().colorMatrix(t, e)["in"](this);
    },
    convolveMatrix: function convolveMatrix(t) {
      return this.parent() && this.parent().convolveMatrix(t)["in"](this);
    },
    componentTransfer: function componentTransfer(t) {
      return this.parent() && this.parent().componentTransfer(t)["in"](this);
    },
    composite: function composite(t, e) {
      return this.parent() && this.parent().composite(this, t, e);
    },
    flood: function flood(t, e) {
      return this.parent() && this.parent().flood(t, e);
    },
    offset: function offset(t, e) {
      return this.parent() && this.parent().offset(t, e)["in"](this);
    },
    image: function image(t) {
      return this.parent() && this.parent().image(t);
    },
    merge: function merge() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    },
    gaussianBlur: function gaussianBlur(t, e) {
      return this.parent() && this.parent().gaussianBlur(t, e)["in"](this);
    },
    morphology: function morphology(t, e) {
      return this.parent() && this.parent().morphology(t, e)["in"](this);
    },
    diffuseLighting: function diffuseLighting(t, e, i) {
      return this.parent() && this.parent().diffuseLighting(t, e, i)["in"](this);
    },
    displacementMap: function displacementMap(t, e, i, a) {
      return this.parent() && this.parent().displacementMap(this, t, e, i, a);
    },
    specularLighting: function specularLighting(t, e, i, a) {
      return this.parent() && this.parent().specularLighting(t, e, i, a)["in"](this);
    },
    tile: function tile() {
      return this.parent() && this.parent().tile()["in"](this);
    },
    turbulence: function turbulence(t, e, i, a, s) {
      return this.parent() && this.parent().turbulence(t, e, i, a, s)["in"](this);
    }
  };
  SVG.extend(SVG.Effect, t), SVG.extend(SVG.ParentEffect, t), SVG.ChildEffect = SVG.invent({
    create: function create() {
      this.constructor.call(this);
    },
    inherit: SVG.Element,
    extend: {
      "in": function _in(t) {
        this.attr("in", t);
      }
    }
  });
  var e = {
    blend: function blend(t, e, i) {
      this.attr({
        "in": t,
        in2: e,
        mode: i || "normal"
      });
    },
    colorMatrix: function colorMatrix(t, e) {
      "matrix" == t && (e = s(e)), this.attr({
        type: t,
        values: void 0 === e ? null : e
      });
    },
    convolveMatrix: function convolveMatrix(t) {
      t = s(t), this.attr({
        order: Math.sqrt(t.split(" ").length),
        kernelMatrix: t
      });
    },
    composite: function composite(t, e, i) {
      this.attr({
        "in": t,
        in2: e,
        operator: i
      });
    },
    flood: function flood(t, e) {
      this.attr("flood-color", t), null != e && this.attr("flood-opacity", e);
    },
    offset: function offset(t, e) {
      this.attr({
        dx: t,
        dy: e
      });
    },
    image: function image(t) {
      this.attr("href", t, SVG.xlink);
    },
    displacementMap: function displacementMap(t, e, i, a, s) {
      this.attr({
        "in": t,
        in2: e,
        scale: i,
        xChannelSelector: a,
        yChannelSelector: s
      });
    },
    gaussianBlur: function gaussianBlur(t, e) {
      null != t || null != e ? this.attr("stdDeviation", r(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    },
    morphology: function morphology(t, e) {
      this.attr({
        operator: t,
        radius: e
      });
    },
    tile: function tile() {},
    turbulence: function turbulence(t, e, i, a, s) {
      this.attr({
        numOctaves: e,
        seed: i,
        stitchTiles: a,
        baseFrequency: t,
        type: s
      });
    }
  },
      i = {
    merge: function merge() {
      var t;

      if (arguments[0] instanceof SVG.Set) {
        var e = this;
        arguments[0].each(function (t) {
          this instanceof SVG.MergeNode ? e.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e.put(new SVG.MergeNode(this));
        });
      } else {
        t = Array.isArray(arguments[0]) ? arguments[0] : arguments;

        for (var i = 0; i < t.length; i++) {
          t[i] instanceof SVG.MergeNode ? this.put(t[i]) : this.put(new SVG.MergeNode(t[i]));
        }
      }
    },
    componentTransfer: function componentTransfer(t) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach(function (t) {
        this[t] = new SVG["Func" + t.toUpperCase()]("identity"), this.rgb.add(this[t]), this.node.appendChild(this[t].node);
      }.bind(this)), t) for (var e in t.rgb && (["r", "g", "b"].forEach(function (e) {
        this[e].attr(t.rgb);
      }.bind(this)), delete t.rgb), t) {
        this[e].attr(t[e]);
      }
    },
    diffuseLighting: function diffuseLighting(t, e, i) {
      this.attr({
        surfaceScale: t,
        diffuseConstant: e,
        kernelUnitLength: i
      });
    },
    specularLighting: function specularLighting(t, e, i, a) {
      this.attr({
        surfaceScale: t,
        diffuseConstant: e,
        specularExponent: i,
        kernelUnitLength: a
      });
    }
  },
      a = {
    distantLight: function distantLight(t, e) {
      this.attr({
        azimuth: t,
        elevation: e
      });
    },
    pointLight: function pointLight(t, e, i) {
      this.attr({
        x: t,
        y: e,
        z: i
      });
    },
    spotLight: function spotLight(t, e, i, a, s, r) {
      this.attr({
        x: t,
        y: e,
        z: i,
        pointsAtX: a,
        pointsAtY: s,
        pointsAtZ: r
      });
    },
    mergeNode: function mergeNode(t) {
      this.attr("in", t);
    }
  };

  function s(t) {
    return Array.isArray(t) && (t = new SVG.Array(t)), t.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
  }

  function r(t) {
    if (!Array.isArray(t)) return t;

    for (var e = 0, i = t.length, a = []; e < i; e++) {
      a.push(t[e]);
    }

    return a.join(" ");
  }

  function n() {
    var t = function t() {};

    for (var e in "function" == typeof arguments[arguments.length - 1] && (t = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) {
      for (var i in arguments[e]) {
        t(arguments[e][i], i, arguments[e]);
      }
    }
  }

  ["r", "g", "b", "a"].forEach(function (t) {
    a["Func" + t.toUpperCase()] = function (t) {
      switch (this.attr("type", t), t) {
        case "table":
          this.attr("tableValues", arguments[1]);
          break;

        case "linear":
          this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
          break;

        case "gamma":
          this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
      }
    };
  }), n(e, function (t, e) {
    var i = e.charAt(0).toUpperCase() + e.slice(1);
    SVG[i + "Effect"] = SVG.invent({
      create: function create() {
        this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments), this.result(this.attr("id") + "Out");
      },
      inherit: SVG.Effect,
      extend: {}
    });
  }), n(i, function (t, e) {
    var i = e.charAt(0).toUpperCase() + e.slice(1);
    SVG[i + "Effect"] = SVG.invent({
      create: function create() {
        this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments), this.result(this.attr("id") + "Out");
      },
      inherit: SVG.ParentEffect,
      extend: {}
    });
  }), n(a, function (t, e) {
    var i = e.charAt(0).toUpperCase() + e.slice(1);
    SVG[i] = SVG.invent({
      create: function create() {
        this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments);
      },
      inherit: SVG.ChildEffect,
      extend: {}
    });
  }), SVG.extend(SVG.MergeEffect, {
    "in": function _in(t) {
      return t instanceof SVG.MergeNode ? this.add(t, 0) : this.add(new SVG.MergeNode(t), 0), this;
    }
  }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
    in2: function in2(t) {
      return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t);
    }
  }), SVG.filter = {
    sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
  };
}.call(void 0), function () {
  function t(t, s, r, n, o, l, h) {
    for (var c = t.slice(s, r || h), d = n.slice(o, l || h), g = 0, u = {
      pos: [0, 0],
      start: [0, 0]
    }, f = {
      pos: [0, 0],
      start: [0, 0]
    };;) {
      if (c[g] = e.call(u, c[g]), d[g] = e.call(f, d[g]), c[g][0] != d[g][0] || "M" == c[g][0] || "A" == c[g][0] && (c[g][4] != d[g][4] || c[g][5] != d[g][5]) ? (Array.prototype.splice.apply(c, [g, 1].concat(a.call(u, c[g]))), Array.prototype.splice.apply(d, [g, 1].concat(a.call(f, d[g])))) : (c[g] = i.call(u, c[g]), d[g] = i.call(f, d[g])), ++g == c.length && g == d.length) break;
      g == c.length && c.push(["C", u.pos[0], u.pos[1], u.pos[0], u.pos[1], u.pos[0], u.pos[1]]), g == d.length && d.push(["C", f.pos[0], f.pos[1], f.pos[0], f.pos[1], f.pos[0], f.pos[1]]);
    }

    return {
      start: c,
      dest: d
    };
  }

  function e(t) {
    switch (t[0]) {
      case "z":
      case "Z":
        t[0] = "L", t[1] = this.start[0], t[2] = this.start[1];
        break;

      case "H":
        t[0] = "L", t[2] = this.pos[1];
        break;

      case "V":
        t[0] = "L", t[2] = t[1], t[1] = this.pos[0];
        break;

      case "T":
        t[0] = "Q", t[3] = t[1], t[4] = t[2], t[1] = this.reflection[1], t[2] = this.reflection[0];
        break;

      case "S":
        t[0] = "C", t[6] = t[4], t[5] = t[3], t[4] = t[2], t[3] = t[1], t[2] = this.reflection[1], t[1] = this.reflection[0];
    }

    return t;
  }

  function i(t) {
    var e = t.length;
    return this.pos = [t[e - 2], t[e - 1]], -1 != "SCQT".indexOf(t[0]) && (this.reflection = [2 * this.pos[0] - t[e - 4], 2 * this.pos[1] - t[e - 3]]), t;
  }

  function a(t) {
    var e = [t];

    switch (t[0]) {
      case "M":
        return this.pos = this.start = [t[1], t[2]], e;

      case "L":
        t[5] = t[3] = t[1], t[6] = t[4] = t[2], t[1] = this.pos[0], t[2] = this.pos[1];
        break;

      case "Q":
        t[6] = t[4], t[5] = t[3], t[4] = 1 * t[4] / 3 + 2 * t[2] / 3, t[3] = 1 * t[3] / 3 + 2 * t[1] / 3, t[2] = 1 * this.pos[1] / 3 + 2 * t[2] / 3, t[1] = 1 * this.pos[0] / 3 + 2 * t[1] / 3;
        break;

      case "A":
        t = (e = function (t, e) {
          var i,
              a,
              s,
              r,
              n,
              o,
              l,
              h,
              c,
              d,
              g,
              u,
              f,
              p,
              x,
              b,
              m,
              v,
              y,
              w,
              k,
              A,
              S,
              C,
              L,
              P,
              T = Math.abs(e[1]),
              z = Math.abs(e[2]),
              I = e[3] % 360,
              M = e[4],
              E = e[5],
              X = e[6],
              Y = e[7],
              F = new SVG.Point(t),
              R = new SVG.Point(X, Y),
              D = [];
          if (0 === T || 0 === z || F.x === R.x && F.y === R.y) return [["C", F.x, F.y, R.x, R.y, R.x, R.y]];
          i = new SVG.Point((F.x - R.x) / 2, (F.y - R.y) / 2).transform(new SVG.Matrix().rotate(I)), (a = i.x * i.x / (T * T) + i.y * i.y / (z * z)) > 1 && (T *= a = Math.sqrt(a), z *= a);
          s = new SVG.Matrix().rotate(I).scale(1 / T, 1 / z).rotate(-I), F = F.transform(s), R = R.transform(s), r = [R.x - F.x, R.y - F.y], o = r[0] * r[0] + r[1] * r[1], n = Math.sqrt(o), r[0] /= n, r[1] /= n, l = o < 4 ? Math.sqrt(1 - o / 4) : 0, M === E && (l *= -1);
          h = new SVG.Point((R.x + F.x) / 2 + l * -r[1], (R.y + F.y) / 2 + l * r[0]), c = new SVG.Point(F.x - h.x, F.y - h.y), d = new SVG.Point(R.x - h.x, R.y - h.y), g = Math.acos(c.x / Math.sqrt(c.x * c.x + c.y * c.y)), c.y < 0 && (g *= -1);
          u = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)), d.y < 0 && (u *= -1);
          E && g > u && (u += 2 * Math.PI);
          !E && g < u && (u -= 2 * Math.PI);

          for (p = Math.ceil(2 * Math.abs(g - u) / Math.PI), b = [], m = g, f = (u - g) / p, x = 4 * Math.tan(f / 4) / 3, k = 0; k <= p; k++) {
            y = Math.cos(m), v = Math.sin(m), w = new SVG.Point(h.x + y, h.y + v), b[k] = [new SVG.Point(w.x + x * v, w.y - x * y), w, new SVG.Point(w.x - x * v, w.y + x * y)], m += f;
          }

          for (b[0][0] = b[0][1].clone(), b[b.length - 1][2] = b[b.length - 1][1].clone(), s = new SVG.Matrix().rotate(I).scale(T, z).rotate(-I), k = 0, A = b.length; k < A; k++) {
            b[k][0] = b[k][0].transform(s), b[k][1] = b[k][1].transform(s), b[k][2] = b[k][2].transform(s);
          }

          for (k = 1, A = b.length; k < A; k++) {
            S = (w = b[k - 1][2]).x, C = w.y, L = (w = b[k][0]).x, P = w.y, X = (w = b[k][1]).x, Y = w.y, D.push(["C", S, C, L, P, X, Y]);
          }

          return D;
        }(this.pos, t))[0];

    }

    return t[0] = "C", this.pos = [t[5], t[6]], this.reflection = [2 * t[5] - t[3], 2 * t[6] - t[4]], e;
  }

  function s(t, e) {
    if (!1 === e) return !1;

    for (var i = e, a = t.length; i < a; ++i) {
      if ("M" == t[i][0]) return i;
    }

    return !1;
  }

  SVG.extend(SVG.PathArray, {
    morph: function morph(e) {
      for (var i = this.value, a = this.parse(e), r = 0, n = 0, o = !1, l = !1; !1 !== r || !1 !== n;) {
        var h;
        o = s(i, !1 !== r && r + 1), l = s(a, !1 !== n && n + 1), !1 === r && (r = 0 == (h = new SVG.PathArray(c.start).bbox()).height || 0 == h.width ? i.push(i[0]) - 1 : i.push(["M", h.x + h.width / 2, h.y + h.height / 2]) - 1), !1 === n && (n = 0 == (h = new SVG.PathArray(c.dest).bbox()).height || 0 == h.width ? a.push(a[0]) - 1 : a.push(["M", h.x + h.width / 2, h.y + h.height / 2]) - 1);
        var c = t(i, r, o, a, n, l);
        i = i.slice(0, r).concat(c.start, !1 === o ? [] : i.slice(o)), a = a.slice(0, n).concat(c.dest, !1 === l ? [] : a.slice(l)), r = !1 !== o && r + c.start.length, n = !1 !== l && n + c.dest.length;
      }

      return this.value = i, this.destination = new SVG.PathArray(), this.destination.value = a, this;
    }
  });
}(),
/*! svg.draggable.js - v2.2.2 - 2019-01-08
* https://github.com/svgdotjs/svg.draggable.js
* Copyright (c) 2019 Wout Fierens; Licensed MIT */
function () {
  function t(t) {
    t.remember("_draggable", this), this.el = t;
  }

  t.prototype.init = function (t, e) {
    var i = this;
    this.constraint = t, this.value = e, this.el.on("mousedown.drag", function (t) {
      i.start(t);
    }), this.el.on("touchstart.drag", function (t) {
      i.start(t);
    });
  }, t.prototype.transformPoint = function (t, e) {
    var i = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
    return this.p.x = i.clientX - (e || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m);
  }, t.prototype.getBBox = function () {
    var t = this.el.bbox();
    return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t;
  }, t.prototype.start = function (t) {
    if ("click" != t.type && "mousedown" != t.type && "mousemove" != t.type || 1 == (t.which || t.buttons)) {
      var e = this;

      if (this.el.fire("beforedrag", {
        event: t,
        handler: this
      }), !this.el.event().defaultPrevented) {
        t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
        var i,
            a = this.getBBox();
        if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
          case "middle":
            i /= 2;
            break;

          case "start":
            i = 0;
        }
        this.startPoints = {
          point: this.transformPoint(t, i),
          box: a,
          transform: this.el.transform()
        }, SVG.on(window, "mousemove.drag", function (t) {
          e.drag(t);
        }), SVG.on(window, "touchmove.drag", function (t) {
          e.drag(t);
        }), SVG.on(window, "mouseup.drag", function (t) {
          e.end(t);
        }), SVG.on(window, "touchend.drag", function (t) {
          e.end(t);
        }), this.el.fire("dragstart", {
          event: t,
          p: this.startPoints.point,
          m: this.m,
          handler: this
        });
      }
    }
  }, t.prototype.drag = function (t) {
    var e = this.getBBox(),
        i = this.transformPoint(t),
        a = this.startPoints.box.x + i.x - this.startPoints.point.x,
        s = this.startPoints.box.y + i.y - this.startPoints.point.y,
        r = this.constraint,
        n = i.x - this.startPoints.point.x,
        o = i.y - this.startPoints.point.y;
    if (this.el.fire("dragmove", {
      event: t,
      p: i,
      m: this.m,
      handler: this
    }), this.el.event().defaultPrevented) return i;

    if ("function" == typeof r) {
      var l = r.call(this.el, a, s, this.m);
      "boolean" == typeof l && (l = {
        x: l,
        y: l
      }), !0 === l.x ? this.el.x(a) : !1 !== l.x && this.el.x(l.x), !0 === l.y ? this.el.y(s) : !1 !== l.y && this.el.y(l.y);
    } else "object" == _typeof(r) && (null != r.minX && a < r.minX ? n = (a = r.minX) - this.startPoints.box.x : null != r.maxX && a > r.maxX - e.width && (n = (a = r.maxX - e.width) - this.startPoints.box.x), null != r.minY && s < r.minY ? o = (s = r.minY) - this.startPoints.box.y : null != r.maxY && s > r.maxY - e.height && (o = (s = r.maxY - e.height) - this.startPoints.box.y), null != r.snapToGrid && (a -= a % r.snapToGrid, s -= s % r.snapToGrid, n -= n % r.snapToGrid, o -= o % r.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
      x: n,
      y: o
    }, !0) : this.el.move(a, s));

    return i;
  }, t.prototype.end = function (t) {
    var e = this.drag(t);
    this.el.fire("dragend", {
      event: t,
      p: e,
      m: this.m,
      handler: this
    }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
  }, SVG.extend(SVG.Element, {
    draggable: function draggable(e, i) {
      "function" != typeof e && "object" != _typeof(e) || (i = e, e = !0);
      var a = this.remember("_draggable") || new t(this);
      return (e = void 0 === e || e) ? a.init(i || {}, e) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    }
  });
}.call(void 0), function () {
  function t(t) {
    this.el = t, t.remember("_selectHandler", this), this.pointSelection = {
      isSelected: !1
    }, this.rectSelection = {
      isSelected: !1
    }, this.pointsList = {
      lt: [0, 0],
      rt: ["width", 0],
      rb: ["width", "height"],
      lb: [0, "height"],
      t: ["width", 0],
      r: ["width", "height"],
      b: ["width", "height"],
      l: [0, "height"]
    }, this.pointCoord = function (t, e, i) {
      var a = "string" != typeof t ? t : e[t];
      return i ? a / 2 : a;
    }, this.pointCoords = function (t, e) {
      var i = this.pointsList[t];
      return {
        x: this.pointCoord(i[0], e, "t" === t || "b" === t),
        y: this.pointCoord(i[1], e, "r" === t || "l" === t)
      };
    };
  }

  t.prototype.init = function (t, e) {
    var i = this.el.bbox();
    this.options = {};
    var a = this.el.selectize.defaults.points;

    for (var s in this.el.selectize.defaults) {
      this.options[s] = this.el.selectize.defaults[s], void 0 !== e[s] && (this.options[s] = e[s]);
    }

    var r = ["points", "pointsExclude"];

    for (var s in r) {
      var n = this.options[r[s]];
      "string" == typeof n ? n = n.length > 0 ? n.split(/\s*,\s*/i) : [] : "boolean" == typeof n && "points" === r[s] && (n = n ? a : []), this.options[r[s]] = n;
    }

    this.options.points = [a, this.options.points].reduce(function (t, e) {
      return t.filter(function (t) {
        return e.indexOf(t) > -1;
      });
    }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function (t, e) {
      return t.filter(function (t) {
        return e.indexOf(t) < 0;
      });
    }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup();
  }, t.prototype.selectPoints = function (t) {
    return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
  }, t.prototype.getPointArray = function () {
    var t = this.el.bbox();
    return this.el.array().valueOf().map(function (e) {
      return [e[0] - t.x, e[1] - t.y];
    });
  }, t.prototype.drawPoints = function () {
    for (var t = this, e = this.getPointArray(), i = 0, a = e.length; i < a; ++i) {
      var s = function (e) {
        return function (i) {
          (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation();
          var a = i.pageX || i.touches[0].pageX,
              s = i.pageY || i.touches[0].pageY;
          t.el.fire("point", {
            x: a,
            y: s,
            i: e,
            event: i
          });
        };
      }(i),
          r = this.drawPoint(e[i][0], e[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s).on("mousedown", s);

      this.pointSelection.set.add(r);
    }
  }, t.prototype.drawPoint = function (t, e) {
    var i = this.options.pointType;

    switch (i) {
      case "circle":
        return this.drawCircle(t, e);

      case "rect":
        return this.drawRect(t, e);

      default:
        if ("function" == typeof i) return i.call(this, t, e);
        throw new Error("Unknown " + i + " point type!");
    }
  }, t.prototype.drawCircle = function (t, e) {
    return this.nested.circle(this.options.pointSize).center(t, e);
  }, t.prototype.drawRect = function (t, e) {
    return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, e);
  }, t.prototype.updatePointSelection = function () {
    var t = this.getPointArray();
    this.pointSelection.set.each(function (e) {
      this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1]);
    });
  }, t.prototype.updateRectSelection = function () {
    var t = this,
        e = this.el.bbox();

    if (this.rectSelection.set.get(0).attr({
      width: e.width,
      height: e.height
    }), this.options.points.length && this.options.points.map(function (i, a) {
      var s = t.pointCoords(i, e);
      t.rectSelection.set.get(a + 1).center(s.x, s.y);
    }), this.options.rotationPoint) {
      var i = this.rectSelection.set.length();
      this.rectSelection.set.get(i - 1).center(e.width / 2, 20);
    }
  }, t.prototype.selectRect = function (t) {
    var e = this,
        i = this.el.bbox();

    function a(t) {
      return function (i) {
        (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation();
        var a = i.pageX || i.touches[0].pageX,
            s = i.pageY || i.touches[0].pageY;
        e.el.fire(t, {
          x: a,
          y: s,
          event: i
        });
      };
    }

    if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
      this.options.points.map(function (t, s) {
        var r = e.pointCoords(t, i),
            n = e.drawPoint(r.x, r.y).attr("class", e.options.classPoints + "_" + t).on("mousedown", a(t)).on("touchstart", a(t));
        e.rectSelection.set.add(n);
      }), this.rectSelection.set.each(function () {
        this.addClass(e.options.classPoints);
      });
    }

    if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
      var s = function s(t) {
        (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation();
        var i = t.pageX || t.touches[0].pageX,
            a = t.pageY || t.touches[0].pageY;
        e.el.fire("rot", {
          x: i,
          y: a,
          event: t
        });
      },
          r = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s).on("mousedown", s);

      this.rectSelection.set.add(r);
    }
  }, t.prototype.handler = function () {
    var t = this.el.bbox();
    this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
  }, t.prototype.observe = function () {
    var t = this;
    if (MutationObserver) {
      if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function () {
        t.handler();
      }), this.observerInst.observe(this.el.node, {
        attributes: !0
      });else try {
        this.observerInst.disconnect(), delete this.observerInst;
      } catch (t) {}
    } else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function () {
      t.handler();
    });
  }, t.prototype.cleanup = function () {
    !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function () {
      this.remove();
    }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function () {
      this.remove();
    }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
  }, SVG.extend(SVG.Element, {
    selectize: function selectize(e, i) {
      return "object" == _typeof(e) && (i = e, e = !0), (this.remember("_selectHandler") || new t(this)).init(void 0 === e || e, i || {}), this;
    }
  }), SVG.Element.prototype.selectize.defaults = {
    points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
    pointsExclude: [],
    classRect: "svg_select_boundingRect",
    classPoints: "svg_select_points",
    pointSize: 7,
    rotationPoint: !0,
    deepSelect: !1,
    pointType: "circle"
  };
}(), function () {
  (function () {
    function t(t) {
      t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint();
    }

    t.prototype.transformPoint = function (t, e, i) {
      return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m);
    }, t.prototype._extractPosition = function (t) {
      return {
        x: null != t.clientX ? t.clientX : t.touches[0].clientX,
        y: null != t.clientY ? t.clientY : t.touches[0].clientY
      };
    }, t.prototype.init = function (t) {
      var e = this;

      if (this.stop(), "stop" !== t) {
        for (var i in this.options = {}, this.el.resize.defaults) {
          this.options[i] = this.el.resize.defaults[i], void 0 !== t[i] && (this.options[i] = t[i]);
        }

        this.el.on("lt.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("rt.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("rb.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("lb.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("t.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("r.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("b.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("l.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("rot.resize", function (t) {
          e.resize(t || window.event);
        }), this.el.on("point.resize", function (t) {
          e.resize(t || window.event);
        }), this.update();
      }
    }, t.prototype.stop = function () {
      return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
    }, t.prototype.resize = function (t) {
      var e = this;
      this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
        x: window.pageXOffset,
        y: window.pageYOffset
      };

      var i = this._extractPosition(t.detail.event);

      if (this.parameters = {
        type: this.el.type,
        p: this.transformPoint(i.x, i.y),
        x: t.detail.x,
        y: t.detail.y,
        box: this.el.bbox(),
        rotation: this.el.transform().rotation
      }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t.detail.i) {
        var a = this.el.array().valueOf();
        this.parameters.i = t.detail.i, this.parameters.pointCoords = [a[t.detail.i][0], a[t.detail.i][1]];
      }

      switch (t.type) {
        case "lt":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e);

            if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height - i[1] > 0) {
              if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i[0]);
              i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y + i[1]).size(this.parameters.box.width - i[0], this.parameters.box.height - i[1]);
            }
          };

          break;

        case "rt":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e, 2);

            if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height - i[1] > 0) {
              if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i[0]);
              i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).size(this.parameters.box.width + i[0], this.parameters.box.height - i[1]);
            }
          };

          break;

        case "rb":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e, 0);

            if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height + i[1] > 0) {
              if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i[0]);
              i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i[0], this.parameters.box.height + i[1]);
            }
          };

          break;

        case "lb":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e, 1);

            if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height + i[1] > 0) {
              if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i[0]);
              i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).size(this.parameters.box.width - i[0], this.parameters.box.height + i[1]);
            }
          };

          break;

        case "t":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e, 2);

            if (this.parameters.box.height - i[1] > 0) {
              if ("text" === this.parameters.type) return;
              this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).height(this.parameters.box.height - i[1]);
            }
          };

          break;

        case "r":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e, 0);

            if (this.parameters.box.width + i[0] > 0) {
              if ("text" === this.parameters.type) return;
              this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i[0]);
            }
          };

          break;

        case "b":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e, 0);

            if (this.parameters.box.height + i[1] > 0) {
              if ("text" === this.parameters.type) return;
              this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i[1]);
            }
          };

          break;

        case "l":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e, 1);

            if (this.parameters.box.width - i[0] > 0) {
              if ("text" === this.parameters.type) return;
              this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).width(this.parameters.box.width - i[0]);
            }
          };

          break;

        case "rot":
          this.calc = function (t, e) {
            var i = t + this.parameters.p.x,
                a = e + this.parameters.p.y,
                s = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                r = Math.atan2(a - this.parameters.box.y - this.parameters.box.height / 2, i - this.parameters.box.x - this.parameters.box.width / 2),
                n = this.parameters.rotation + 180 * (r - s) / Math.PI + this.options.snapToAngle / 2;
            this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(n - n % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
          };

          break;

        case "point":
          this.calc = function (t, e) {
            var i = this.snapToGrid(t, e, this.parameters.pointCoords[0], this.parameters.pointCoords[1]),
                a = this.el.array().valueOf();
            a[this.parameters.i][0] = this.parameters.pointCoords[0] + i[0], a[this.parameters.i][1] = this.parameters.pointCoords[1] + i[1], this.el.plot(a);
          };

      }

      this.el.fire("resizestart", {
        dx: this.parameters.x,
        dy: this.parameters.y,
        event: t
      }), SVG.on(window, "touchmove.resize", function (t) {
        e.update(t || window.event);
      }), SVG.on(window, "touchend.resize", function () {
        e.done();
      }), SVG.on(window, "mousemove.resize", function (t) {
        e.update(t || window.event);
      }), SVG.on(window, "mouseup.resize", function () {
        e.done();
      });
    }, t.prototype.update = function (t) {
      if (t) {
        var e = this._extractPosition(t),
            i = this.transformPoint(e.x, e.y),
            a = i.x - this.parameters.p.x,
            s = i.y - this.parameters.p.y;

        this.lastUpdateCall = [a, s], this.calc(a, s), this.el.fire("resizing", {
          dx: a,
          dy: s,
          event: t
        });
      } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
    }, t.prototype.done = function () {
      this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
    }, t.prototype.snapToGrid = function (t, e, i, a) {
      var s;
      return void 0 !== a ? s = [(i + t) % this.options.snapToGrid, (a + e) % this.options.snapToGrid] : (i = null == i ? 3 : i, s = [(this.parameters.box.x + t + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (s[0] -= this.options.snapToGrid), e < 0 && (s[1] -= this.options.snapToGrid), t -= Math.abs(s[0]) < this.options.snapToGrid / 2 ? s[0] : s[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(s[1]) < this.options.snapToGrid / 2 ? s[1] : s[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, e, i, a);
    }, t.prototype.constraintToBox = function (t, e, i, a) {
      var s,
          r,
          n = this.options.constraint || {};
      return void 0 !== a ? (s = i, r = a) : (s = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), void 0 !== n.minX && s + t < n.minX && (t = n.minX - s), void 0 !== n.maxX && s + t > n.maxX && (t = n.maxX - s), void 0 !== n.minY && r + e < n.minY && (e = n.minY - r), void 0 !== n.maxY && r + e > n.maxY && (e = n.maxY - r), [t, e];
    }, t.prototype.checkAspectRatio = function (t, e) {
      if (!this.options.saveAspectRatio) return t;
      var i = t.slice(),
          a = this.parameters.box.width / this.parameters.box.height,
          s = this.parameters.box.width + t[0],
          r = this.parameters.box.height - t[1],
          n = s / r;
      return n < a ? (i[1] = s / a - this.parameters.box.height, e && (i[1] = -i[1])) : n > a && (i[0] = this.parameters.box.width - r * a, e && (i[0] = -i[0])), i;
    }, SVG.extend(SVG.Element, {
      resize: function resize(e) {
        return (this.remember("_resizeHandler") || new t(this)).init(e || {}), this;
      }
    }), SVG.Element.prototype.resize.defaults = {
      snapToAngle: .1,
      snapToGrid: 1,
      constraint: {},
      saveAspectRatio: !1
    };
  }).call(this);
}();
!function (t, e) {
  void 0 === e && (e = {});
  var i = e.insertAt;

  if (t && "undefined" != typeof document) {
    var a = document.head || document.getElementsByTagName("head")[0],
        s = document.createElement("style");
    s.type = "text/css", "top" === i && a.firstChild ? a.insertBefore(s, a.firstChild) : a.appendChild(s), s.styleSheet ? s.styleSheet.cssText = t : s.appendChild(document.createTextNode(t));
  }
}('.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-box, .apexcharts-custom-tooltip {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse;\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers>div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers>div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}'), function () {
  function t(t) {
    var e = t.__resizeTriggers__,
        i = e.firstElementChild,
        a = e.lastElementChild,
        s = i ? i.firstElementChild : null;
    a && (a.scrollLeft = a.scrollWidth, a.scrollTop = a.scrollHeight), s && (s.style.width = i.offsetWidth + 1 + "px", s.style.height = i.offsetHeight + 1 + "px"), i && (i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight);
  }

  function e(e) {
    var i = this;
    t(this), this.__resizeRAF__ && r(this.__resizeRAF__), this.__resizeRAF__ = s(function () {
      (function (t) {
        return t.offsetWidth != t.__resizeLast__.width || t.offsetHeight != t.__resizeLast__.height;
      })(i) && (i.__resizeLast__.width = i.offsetWidth, i.__resizeLast__.height = i.offsetHeight, i.__resizeListeners__.forEach(function (t) {
        t.call(e);
      }));
    });
  }

  var i,
      a,
      s = (i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (t) {
    return window.setTimeout(t, 20);
  }, function (t) {
    return i(t);
  }),
      r = (a = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout, function (t) {
    return a(t);
  }),
      n = !1,
      o = "animationstart",
      l = "Webkit Moz O ms".split(" "),
      h = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "),
      c = document.createElement("fakeelement");
  if (void 0 !== c.style.animationName && (n = !0), !1 === n) for (var d = 0; d < l.length; d++) {
    if (void 0 !== c.style[l[d] + "AnimationName"]) {
      o = h[d];
      break;
    }
  }
  window.addResizeListener = function (i, a) {
    i.__resizeTriggers__ || ("static" == getComputedStyle(i).position && (i.style.position = "relative"), i.__resizeLast__ = {}, i.__resizeListeners__ = [], (i.__resizeTriggers__ = document.createElement("div")).className = "resize-triggers", i.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', i.appendChild(i.__resizeTriggers__), t(i), i.addEventListener("scroll", e, !0), o && i.__resizeTriggers__.addEventListener(o, function (e) {
      "resizeanim" == e.animationName && t(i);
    })), i.__resizeListeners__.push(a);
  }, window.removeResizeListener = function (t, i) {
    t && (t.__resizeListeners__.splice(t.__resizeListeners__.indexOf(i), 1), t.__resizeListeners__.length || (t.removeEventListener("scroll", e), t.__resizeTriggers__.parentNode && (t.__resizeTriggers__ = !t.removeChild(t.__resizeTriggers__))));
  };
}(), void 0 === window.Apex && (window.Apex = {});

var Yt = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "initModules",
    value: function value() {
      this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], this.ctx.animations = new p(this.ctx), this.ctx.axes = new J(this.ctx), this.ctx.core = new Et(this.ctx.el, this.ctx), this.ctx.config = new D({}), this.ctx.data = new N(this.ctx), this.ctx.grid = new _(this.ctx), this.ctx.graphics = new b(this.ctx), this.ctx.coreUtils = new y(this.ctx), this.ctx.crosshairs = new Q(this.ctx), this.ctx.events = new Z(this.ctx), this.ctx.exports = new V(this.ctx), this.ctx.localization = new $(this.ctx), this.ctx.options = new S(), this.ctx.responsive = new K(this.ctx), this.ctx.series = new M(this.ctx), this.ctx.theme = new tt(this.ctx), this.ctx.formatters = new W(this.ctx), this.ctx.titleSubtitle = new et(this.ctx), this.ctx.legend = new lt(this.ctx), this.ctx.toolbar = new ht(this.ctx), this.ctx.dimensions = new nt(this.ctx), this.ctx.updateHelpers = new Xt(this.ctx), this.ctx.zoomPanSelection = new ct(this.ctx), this.ctx.w.globals.tooltip = new bt(this.ctx);
    }
  }]), t;
}(),
    Ft = function () {
  function t(i) {
    e(this, t), this.ctx = i, this.w = i.w;
  }

  return a(t, [{
    key: "clear",
    value: function value(t) {
      var e = t.isUpdating;
      this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({
        isUpdating: e
      });
    }
  }, {
    key: "killSVG",
    value: function value(t) {
      t.each(function (t, e) {
        this.removeClass("*"), this.off(), this.stop();
      }, !0), t.ungroup(), t.clear();
    }
  }, {
    key: "clearDomElements",
    value: function value(t) {
      var e = this,
          i = t.isUpdating,
          a = this.w.globals.dom.Paper.node;
      a.parentNode && a.parentNode.parentNode && !i && (a.parentNode.parentNode.style.minHeight = "unset");
      var s = this.w.globals.dom.baseEl;
      s && this.ctx.eventList.forEach(function (t) {
        s.removeEventListener(t, e.ctx.events.documentEvent);
      });
      var r = this.w.globals.dom;
      if (null !== this.ctx.el) for (; this.ctx.el.firstChild;) {
        this.ctx.el.removeChild(this.ctx.el.firstChild);
      }
      this.killSVG(r.Paper), r.Paper.remove(), r.elWrap = null, r.elGraphical = null, r.elAnnotations = null, r.elLegendWrap = null, r.baseEl = null, r.elGridRect = null, r.elGridRectMask = null, r.elGridRectMarkerMask = null, r.elDefs = null;
    }
  }]), t;
}(),
    Rt = function () {
  function t(i, a) {
    e(this, t), this.opts = a, this.ctx = this, this.w = new O(a).init(), this.el = i, this.w.globals.cuid = f.randomId(), this.w.globals.chartID = this.w.config.chart.id ? f.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Yt(this).initModules(), this.create = f.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }

  return a(t, [{
    key: "render",
    value: function value() {
      var t = this;
      return new Promise(function (e, i) {
        if (null !== t.el) {
          void 0 === Apex._chartInstances && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({
            id: t.w.globals.chartID,
            group: t.w.config.chart.group,
            chart: t
          }), t.setLocale(t.w.config.chart.defaultLocale);
          var a = t.w.config.chart.events.beforeMount;
          "function" == typeof a && a(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), window.addResizeListener(t.el.parentNode, t.parentResizeHandler);
          var s = t.create(t.w.config.series, {});
          if (!s) return e(t);
          t.mount(s).then(function () {
            "function" == typeof t.w.config.chart.events.mounted && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), e(s);
          })["catch"](function (t) {
            i(t);
          });
        } else i(new Error("Element not found"));
      });
    }
  }, {
    key: "create",
    value: function value(t, e) {
      var i = this.w;
      new Yt(this).initModules();
      var a = this.w.globals;
      (a.noData = !1, a.animationEnded = !1, this.responsive.checkResponsiveConfig(e), i.config.xaxis.convertedCatToNumeric) && new R(i.config).convertCatToNumericXaxis(i.config, this.ctx);
      if (null === this.el) return a.animationEnded = !0, null;
      if (this.core.setupElements(), "treemap" === i.config.chart.type && (i.config.grid.show = !1, i.config.yaxis[0].show = !1), 0 === a.svgWidth) return a.animationEnded = !0, null;
      var s = y.checkComboSeries(t);
      a.comboCharts = s.comboCharts, a.comboBarCount = s.comboBarCount;
      var r = t.every(function (t) {
        return t.data && 0 === t.data.length;
      });
      (0 === t.length || r) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new P(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a.noData && a.collapsedSeries.length !== a.series.length && !i.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a.axisCharts && (this.core.coreCalculations(), "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i.globals.minX, this.ctx.toolbar.maxX = i.globals.maxX), this.formatters.heatmapLabelFormatters(), this.dimensions.plotCoords();
      var n = this.core.xySettings();
      this.grid.createGridMask();
      var o = this.core.plotChartType(t, n),
          l = new z(this);
      l.bringForward(), i.config.dataLabels.background.enabled && l.dataLabelsBackground(), this.core.shiftGraphPosition();
      var h = {
        plot: {
          left: i.globals.translateX,
          top: i.globals.translateY,
          width: i.globals.gridWidth,
          height: i.globals.gridHeight
        }
      };
      return {
        elGraph: o,
        xyRatios: n,
        elInner: i.globals.dom.elGraphical,
        dimensions: h
      };
    }
  }, {
    key: "mount",
    value: function value() {
      var t = this,
          e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
          i = this,
          a = i.w;
      return new Promise(function (s, r) {
        if (null === i.el) return r(new Error("Not enough data to display or target element not found"));
        (null === e || a.globals.allSeriesCollapsed) && i.series.handleNoData(), "treemap" !== a.config.chart.type && i.axes.drawAxis(a.config.chart.type, e.xyRatios), i.grid = new _(i);
        var n = i.grid.drawGrid();
        i.annotations = new C(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), "back" === a.config.grid.position && n && a.globals.dom.elGraphical.add(n.el);
        var o = new G(t.ctx),
            l = new q(t.ctx);
        if (null !== n && (o.xAxisLabelCorrections(n.xAxisTickWidth), l.setYAxisTextAlignments(), a.config.yaxis.map(function (t, e) {
          -1 === a.globals.ignoreYAxisIndexes.indexOf(e) && l.yAxisTitleRotate(e, t.opposite);
        })), "back" === a.config.annotations.position && (a.globals.dom.Paper.add(a.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()), Array.isArray(e.elGraph)) for (var h = 0; h < e.elGraph.length; h++) {
          a.globals.dom.elGraphical.add(e.elGraph[h]);
        } else a.globals.dom.elGraphical.add(e.elGraph);

        if ("front" === a.config.grid.position && n && a.globals.dom.elGraphical.add(n.el), "front" === a.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(), "front" === a.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(), "front" === a.config.annotations.position && (a.globals.dom.Paper.add(a.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()), !a.globals.noData) {
          if (a.config.tooltip.enabled && !a.globals.noData && i.w.globals.tooltip.drawTooltip(e.xyRatios), a.globals.axisCharts && (a.globals.isXNumeric || a.config.xaxis.convertedCatToNumeric || a.globals.isTimelineBar)) (a.config.chart.zoom.enabled || a.config.chart.selection && a.config.chart.selection.enabled || a.config.chart.pan && a.config.chart.pan.enabled) && i.zoomPanSelection.init({
            xyRatios: e.xyRatios
          });else {
            var c = a.config.chart.toolbar.tools;
            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function (t) {
              c[t] = !1;
            });
          }
          a.config.chart.toolbar.show && !a.globals.allSeriesCollapsed && i.toolbar.createToolbar();
        }

        a.globals.memory.methodsToExec.length > 0 && a.globals.memory.methodsToExec.forEach(function (t) {
          t.method(t.params, !1, t.context);
        }), a.globals.axisCharts || a.globals.noData || i.core.resizeNonAxisCharts(), s(i);
      });
    }
  }, {
    key: "destroy",
    value: function value() {
      window.removeEventListener("resize", this.windowResizeHandler), window.removeResizeListener(this.el.parentNode, this.parentResizeHandler);
      var t = this.w.config.chart.id;
      t && Apex._chartInstances.forEach(function (e, i) {
        e.id === f.escapeString(t) && Apex._chartInstances.splice(i, 1);
      }), new Ft(this.ctx).clear({
        isUpdating: !1
      });
    }
  }, {
    key: "updateOptions",
    value: function value(t) {
      var e = this,
          i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
          a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
          s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
          r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
          n = this.w;
      return n.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map(function (t, i) {
        return e.updateHelpers._extendSeries(t, i);
      })), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), n.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, a, s, r);
    }
  }, {
    key: "updateSeries",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
          e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, e, i);
    }
  }, {
    key: "appendSeries",
    value: function value(t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
          a = this.w.config.series.slice();
      return a.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a, e, i);
    }
  }, {
    key: "appendData",
    value: function value(t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = this;
      i.w.globals.dataChanged = !0, i.series.getPreviousPaths();

      for (var a = i.w.config.series.slice(), s = 0; s < a.length; s++) {
        if (null !== t[s] && void 0 !== t[s]) for (var r = 0; r < t[s].data.length; r++) {
          a[s].data.push(t[s].data[r]);
        }
      }

      return i.w.config.series = a, e && (i.w.globals.initialSeries = f.clone(i.w.config.series)), this.update();
    }
  }, {
    key: "update",
    value: function value(t) {
      var e = this;
      return new Promise(function (i, a) {
        new Ft(e.ctx).clear({
          isUpdating: !0
        });
        var s = e.create(e.w.config.series, t);
        if (!s) return i(e);
        e.mount(s).then(function () {
          "function" == typeof e.w.config.chart.events.updated && e.w.config.chart.events.updated(e, e.w), e.events.fireEvent("updated", [e, e.w]), e.w.globals.isDirty = !0, i(e);
        })["catch"](function (t) {
          a(t);
        });
      });
    }
  }, {
    key: "getSyncedCharts",
    value: function value() {
      var t = this.getGroupedCharts(),
          e = [this];
      return t.length && (e = [], t.forEach(function (t) {
        e.push(t);
      })), e;
    }
  }, {
    key: "getGroupedCharts",
    value: function value() {
      var t = this;
      return Apex._chartInstances.filter(function (t) {
        if (t.group) return !0;
      }).map(function (e) {
        return t.w.config.chart.group === e.group ? e.chart : t;
      });
    }
  }, {
    key: "toggleSeries",
    value: function value(t) {
      return this.series.toggleSeries(t);
    }
  }, {
    key: "showSeries",
    value: function value(t) {
      this.series.showSeries(t);
    }
  }, {
    key: "hideSeries",
    value: function value(t) {
      this.series.hideSeries(t);
    }
  }, {
    key: "resetSeries",
    value: function value() {
      var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
          e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      this.series.resetSeries(t, e);
    }
  }, {
    key: "addEventListener",
    value: function value(t, e) {
      this.events.addEventListener(t, e);
    }
  }, {
    key: "removeEventListener",
    value: function value(t, e) {
      this.events.removeEventListener(t, e);
    }
  }, {
    key: "addXaxisAnnotation",
    value: function value(t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
          a = this;
      i && (a = i), a.annotations.addXaxisAnnotationExternal(t, e, a);
    }
  }, {
    key: "addYaxisAnnotation",
    value: function value(t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
          a = this;
      i && (a = i), a.annotations.addYaxisAnnotationExternal(t, e, a);
    }
  }, {
    key: "addPointAnnotation",
    value: function value(t) {
      var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
          a = this;
      i && (a = i), a.annotations.addPointAnnotationExternal(t, e, a);
    }
  }, {
    key: "clearAnnotations",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0,
          e = this;
      t && (e = t), e.annotations.clearAnnotations(e);
    }
  }, {
    key: "removeAnnotation",
    value: function value(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
          i = this;
      e && (i = e), i.annotations.removeAnnotation(i, t);
    }
  }, {
    key: "getChartArea",
    value: function value() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
    }
  }, {
    key: "getSeriesTotalXRange",
    value: function value(t, e) {
      return this.coreUtils.getSeriesTotalsXRange(t, e);
    }
  }, {
    key: "getHighestValueInSeries",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          e = new U(this.ctx);
      return e.getMinYMaxY(t).highestY;
    }
  }, {
    key: "getLowestValueInSeries",
    value: function value() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
          e = new U(this.ctx);
      return e.getMinYMaxY(t).lowestY;
    }
  }, {
    key: "getSeriesTotal",
    value: function value() {
      return this.w.globals.seriesTotals;
    }
  }, {
    key: "toggleDataPointSelection",
    value: function value(t, e) {
      return this.updateHelpers.toggleDataPointSelection(t, e);
    }
  }, {
    key: "zoomX",
    value: function value(t, e) {
      this.ctx.toolbar.zoomUpdateOptions(t, e);
    }
  }, {
    key: "setLocale",
    value: function value(t) {
      this.localization.setCurrentLocaleValues(t);
    }
  }, {
    key: "dataURI",
    value: function value() {
      return new V(this.ctx).dataURI();
    }
  }, {
    key: "paper",
    value: function value() {
      return this.w.globals.dom.Paper;
    }
  }, {
    key: "_parentResizeCallback",
    value: function value() {
      this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
    }
  }, {
    key: "_windowResize",
    value: function value() {
      var t = this;
      clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function () {
        t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update();
      }, 150);
    }
  }, {
    key: "_windowResizeHandler",
    value: function value() {
      var t = this.w.config.chart.redrawOnWindowResize;
      "function" == typeof t && (t = t()), t && this._windowResize();
    }
  }], [{
    key: "getChartByID",
    value: function value(t) {
      var e = f.escapeString(t),
          i = Apex._chartInstances.filter(function (t) {
        return t.id === e;
      })[0];

      return i && i.chart;
    }
  }, {
    key: "initOnLoad",
    value: function value() {
      for (var e = document.querySelectorAll("[data-apexcharts]"), i = 0; i < e.length; i++) {
        new t(e[i], JSON.parse(e[i].getAttribute("data-options"))).render();
      }
    }
  }, {
    key: "exec",
    value: function value(t, e) {
      var i = this.getChartByID(t);

      if (i) {
        i.w.globals.isExecCalled = !0;
        var a = null;

        if (-1 !== i.publicMethods.indexOf(e)) {
          for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), n = 2; n < s; n++) {
            r[n - 2] = arguments[n];
          }

          a = i[e].apply(i, r);
        }

        return a;
      }
    }
  }, {
    key: "merge",
    value: function value(t, e) {
      return f.extend(t, e);
    }
  }]), t;
}();

module.exports = Rt;

/***/ }),

/***/ "./node_modules/bootstrap/js/src/carousel.js":
/*!***************************************************!*\
  !*** ./node_modules/bootstrap/js/src/carousel.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

var NAME = 'carousel';
var VERSION = '4.6.0';
var DATA_KEY = 'bs.carousel';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME];
var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

var SWIPE_THRESHOLD = 40;
var Default = {
  interval: 5000,
  keyboard: true,
  slide: false,
  pause: 'hover',
  wrap: true,
  touch: true
};
var DefaultType = {
  interval: '(number|boolean)',
  keyboard: 'boolean',
  slide: '(boolean|string)',
  pause: '(string|boolean)',
  wrap: 'boolean',
  touch: 'boolean'
};
var DIRECTION_NEXT = 'next';
var DIRECTION_PREV = 'prev';
var DIRECTION_LEFT = 'left';
var DIRECTION_RIGHT = 'right';
var EVENT_SLIDE = "slide".concat(EVENT_KEY);
var EVENT_SLID = "slid".concat(EVENT_KEY);
var EVENT_KEYDOWN = "keydown".concat(EVENT_KEY);
var EVENT_MOUSEENTER = "mouseenter".concat(EVENT_KEY);
var EVENT_MOUSELEAVE = "mouseleave".concat(EVENT_KEY);
var EVENT_TOUCHSTART = "touchstart".concat(EVENT_KEY);
var EVENT_TOUCHMOVE = "touchmove".concat(EVENT_KEY);
var EVENT_TOUCHEND = "touchend".concat(EVENT_KEY);
var EVENT_POINTERDOWN = "pointerdown".concat(EVENT_KEY);
var EVENT_POINTERUP = "pointerup".concat(EVENT_KEY);
var EVENT_DRAG_START = "dragstart".concat(EVENT_KEY);
var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY).concat(DATA_API_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_CAROUSEL = 'carousel';
var CLASS_NAME_ACTIVE = 'active';
var CLASS_NAME_SLIDE = 'slide';
var CLASS_NAME_RIGHT = 'carousel-item-right';
var CLASS_NAME_LEFT = 'carousel-item-left';
var CLASS_NAME_NEXT = 'carousel-item-next';
var CLASS_NAME_PREV = 'carousel-item-prev';
var CLASS_NAME_POINTER_EVENT = 'pointer-event';
var SELECTOR_ACTIVE = '.active';
var SELECTOR_ACTIVE_ITEM = '.active.carousel-item';
var SELECTOR_ITEM = '.carousel-item';
var SELECTOR_ITEM_IMG = '.carousel-item img';
var SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';
var SELECTOR_INDICATORS = '.carousel-indicators';
var SELECTOR_DATA_SLIDE = '[data-slide], [data-slide-to]';
var SELECTOR_DATA_RIDE = '[data-ride="carousel"]';
var PointerType = {
  TOUCH: 'touch',
  PEN: 'pen'
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Carousel = /*#__PURE__*/function () {
  function Carousel(element, config) {
    _classCallCheck(this, Carousel);

    this._items = null;
    this._interval = null;
    this._activeElement = null;
    this._isPaused = false;
    this._isSliding = false;
    this.touchTimeout = null;
    this.touchStartX = 0;
    this.touchDeltaX = 0;
    this._config = this._getConfig(config);
    this._element = element;
    this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);
    this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
    this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);

    this._addEventListeners();
  } // Getters


  _createClass(Carousel, [{
    key: "next",
    value: // Public
    function next() {
      if (!this._isSliding) {
        this._slide(DIRECTION_NEXT);
      }
    }
  }, {
    key: "nextWhenVisible",
    value: function nextWhenVisible() {
      var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element); // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible

      if (!document.hidden && $element.is(':visible') && $element.css('visibility') !== 'hidden') {
        this.next();
      }
    }
  }, {
    key: "prev",
    value: function prev() {
      if (!this._isSliding) {
        this._slide(DIRECTION_PREV);
      }
    }
  }, {
    key: "pause",
    value: function pause(event) {
      if (!event) {
        this._isPaused = true;
      }

      if (this._element.querySelector(SELECTOR_NEXT_PREV)) {
        _util__WEBPACK_IMPORTED_MODULE_1__["default"].triggerTransitionEnd(this._element);
        this.cycle(true);
      }

      clearInterval(this._interval);
      this._interval = null;
    }
  }, {
    key: "cycle",
    value: function cycle(event) {
      if (!event) {
        this._isPaused = false;
      }

      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }

      if (this._config.interval && !this._isPaused) {
        this._updateInterval();

        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    }
  }, {
    key: "to",
    value: function to(index) {
      var _this = this;

      this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);

      var activeIndex = this._getItemIndex(this._activeElement);

      if (index > this._items.length - 1 || index < 0) {
        return;
      }

      if (this._isSliding) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(EVENT_SLID, function () {
          return _this.to(index);
        });
        return;
      }

      if (activeIndex === index) {
        this.pause();
        this.cycle();
        return;
      }

      var direction = index > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;

      this._slide(direction, this._items[index]);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).off(EVENT_KEY);
      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.removeData(this._element, DATA_KEY);
      this._items = null;
      this._config = null;
      this._element = null;
      this._interval = null;
      this._isPaused = null;
      this._isSliding = null;
      this._activeElement = null;
      this._indicatorsElement = null;
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread({}, Default), config);
      _util__WEBPACK_IMPORTED_MODULE_1__["default"].typeCheckConfig(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_handleSwipe",
    value: function _handleSwipe() {
      var absDeltax = Math.abs(this.touchDeltaX);

      if (absDeltax <= SWIPE_THRESHOLD) {
        return;
      }

      var direction = absDeltax / this.touchDeltaX;
      this.touchDeltaX = 0; // swipe left

      if (direction > 0) {
        this.prev();
      } // swipe right


      if (direction < 0) {
        this.next();
      }
    }
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var _this2 = this;

      if (this._config.keyboard) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_KEYDOWN, function (event) {
          return _this2._keydown(event);
        });
      }

      if (this._config.pause === 'hover') {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_MOUSEENTER, function (event) {
          return _this2.pause(event);
        }).on(EVENT_MOUSELEAVE, function (event) {
          return _this2.cycle(event);
        });
      }

      if (this._config.touch) {
        this._addTouchEventListeners();
      }
    }
  }, {
    key: "_addTouchEventListeners",
    value: function _addTouchEventListeners() {
      var _this3 = this;

      if (!this._touchSupported) {
        return;
      }

      var start = function start(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchStartX = event.originalEvent.clientX;
        } else if (!_this3._pointerEvent) {
          _this3.touchStartX = event.originalEvent.touches[0].clientX;
        }
      };

      var move = function move(event) {
        // ensure swiping with one touch and not pinching
        if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {
          _this3.touchDeltaX = 0;
        } else {
          _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;
        }
      };

      var end = function end(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
        }

        _this3._handleSwipe();

        if (_this3._config.pause === 'hover') {
          // If it's a touch-enabled device, mouseenter/leave are fired as
          // part of the mouse compatibility events on first tap - the carousel
          // would stop cycling until user tapped out of it;
          // here, we listen for touchend, explicitly pause the carousel
          // (as if it's the second time we tap on it, mouseenter compat event
          // is NOT fired) and after a timeout (to allow for mouse compatibility
          // events to fire) we explicitly restart cycling
          _this3.pause();

          if (_this3.touchTimeout) {
            clearTimeout(_this3.touchTimeout);
          }

          _this3.touchTimeout = setTimeout(function (event) {
            return _this3.cycle(event);
          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
        }
      };

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function (e) {
        return e.preventDefault();
      });

      if (this._pointerEvent) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_POINTERDOWN, function (event) {
          return start(event);
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_POINTERUP, function (event) {
          return end(event);
        });

        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_TOUCHSTART, function (event) {
          return start(event);
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_TOUCHMOVE, function (event) {
          return move(event);
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_TOUCHEND, function (event) {
          return end(event);
        });
      }
    }
  }, {
    key: "_keydown",
    value: function _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }

      switch (event.which) {
        case ARROW_LEFT_KEYCODE:
          event.preventDefault();
          this.prev();
          break;

        case ARROW_RIGHT_KEYCODE:
          event.preventDefault();
          this.next();
          break;

        default:
      }
    }
  }, {
    key: "_getItemIndex",
    value: function _getItemIndex(element) {
      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];
      return this._items.indexOf(element);
    }
  }, {
    key: "_getItemByDirection",
    value: function _getItemByDirection(direction, activeElement) {
      var isNextDirection = direction === DIRECTION_NEXT;
      var isPrevDirection = direction === DIRECTION_PREV;

      var activeIndex = this._getItemIndex(activeElement);

      var lastItemIndex = this._items.length - 1;
      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

      if (isGoingToWrap && !this._config.wrap) {
        return activeElement;
      }

      var delta = direction === DIRECTION_PREV ? -1 : 1;
      var itemIndex = (activeIndex + delta) % this._items.length;
      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
    }
  }, {
    key: "_triggerSlideEvent",
    value: function _triggerSlideEvent(relatedTarget, eventDirectionName) {
      var targetIndex = this._getItemIndex(relatedTarget);

      var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));

      var slideEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SLIDE, {
        relatedTarget: relatedTarget,
        direction: eventDirectionName,
        from: fromIndex,
        to: targetIndex
      });
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(slideEvent);
      return slideEvent;
    }
  }, {
    key: "_setActiveIndicatorElement",
    value: function _setActiveIndicatorElement(element) {
      if (this._indicatorsElement) {
        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE));
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(indicators).removeClass(CLASS_NAME_ACTIVE);

        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

        if (nextIndicator) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(nextIndicator).addClass(CLASS_NAME_ACTIVE);
        }
      }
    }
  }, {
    key: "_updateInterval",
    value: function _updateInterval() {
      var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);

      if (!element) {
        return;
      }

      var elementInterval = parseInt(element.getAttribute('data-interval'), 10);

      if (elementInterval) {
        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
        this._config.interval = elementInterval;
      } else {
        this._config.interval = this._config.defaultInterval || this._config.interval;
      }
    }
  }, {
    key: "_slide",
    value: function _slide(direction, element) {
      var _this4 = this;

      var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);

      var activeElementIndex = this._getItemIndex(activeElement);

      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

      var nextElementIndex = this._getItemIndex(nextElement);

      var isCycling = Boolean(this._interval);
      var directionalClassName;
      var orderClassName;
      var eventDirectionName;

      if (direction === DIRECTION_NEXT) {
        directionalClassName = CLASS_NAME_LEFT;
        orderClassName = CLASS_NAME_NEXT;
        eventDirectionName = DIRECTION_LEFT;
      } else {
        directionalClassName = CLASS_NAME_RIGHT;
        orderClassName = CLASS_NAME_PREV;
        eventDirectionName = DIRECTION_RIGHT;
      }

      if (nextElement && jquery__WEBPACK_IMPORTED_MODULE_0___default()(nextElement).hasClass(CLASS_NAME_ACTIVE)) {
        this._isSliding = false;
        return;
      }

      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

      if (slideEvent.isDefaultPrevented()) {
        return;
      }

      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        return;
      }

      this._isSliding = true;

      if (isCycling) {
        this.pause();
      }

      this._setActiveIndicatorElement(nextElement);

      this._activeElement = nextElement;
      var slidEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SLID, {
        relatedTarget: nextElement,
        direction: eventDirectionName,
        from: activeElementIndex,
        to: nextElementIndex
      });

      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_SLIDE)) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(nextElement).addClass(orderClassName);
        _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(nextElement);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(activeElement).addClass(directionalClassName);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(nextElement).addClass(directionalClassName);
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(activeElement);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(activeElement).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, function () {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(nextElement).removeClass("".concat(directionalClassName, " ").concat(orderClassName)).addClass(CLASS_NAME_ACTIVE);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(activeElement).removeClass("".concat(CLASS_NAME_ACTIVE, " ").concat(orderClassName, " ").concat(directionalClassName));
          _this4._isSliding = false;
          setTimeout(function () {
            return jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this4._element).trigger(slidEvent);
          }, 0);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(activeElement).removeClass(CLASS_NAME_ACTIVE);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(nextElement).addClass(CLASS_NAME_ACTIVE);
        this._isSliding = false;
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(slidEvent);
      }

      if (isCycling) {
        this.cycle();
      }
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var data = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY);

        var _config = _objectSpread(_objectSpread({}, Default), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data());

        if (_typeof(config) === 'object') {
          _config = _objectSpread(_objectSpread({}, _config), config);
        }

        var action = typeof config === 'string' ? config : _config.slide;

        if (!data) {
          data = new Carousel(this, _config);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY, data);
        }

        if (typeof config === 'number') {
          data.to(config);
        } else if (typeof action === 'string') {
          if (typeof data[action] === 'undefined') {
            throw new TypeError("No method named \"".concat(action, "\""));
          }

          data[action]();
        } else if (_config.interval && _config.ride) {
          data.pause();
          data.cycle();
        }
      });
    }
  }, {
    key: "_dataApiClickHandler",
    value: function _dataApiClickHandler(event) {
      var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(this);

      if (!selector) {
        return;
      }

      var target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(selector)[0];

      if (!target || !jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).hasClass(CLASS_NAME_CAROUSEL)) {
        return;
      }

      var config = _objectSpread(_objectSpread({}, jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).data()), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data());

      var slideIndex = this.getAttribute('data-slide-to');

      if (slideIndex) {
        config.interval = false;
      }

      Carousel._jQueryInterface.call(jquery__WEBPACK_IMPORTED_MODULE_0___default()(target), config);

      if (slideIndex) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).data(DATA_KEY).to(slideIndex);
      }

      event.preventDefault();
    }
  }]);

  return Carousel;
}();
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);
jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on(EVENT_LOAD_DATA_API, function () {
  var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));

  for (var i = 0, len = carousels.length; i < len; i++) {
    var $carousel = jquery__WEBPACK_IMPORTED_MODULE_0___default()(carousels[i]);

    Carousel._jQueryInterface.call($carousel, $carousel.data());
  }
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = Carousel._jQueryInterface;
jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].Constructor = Carousel;

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].noConflict = function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = JQUERY_NO_CONFLICT;
  return Carousel._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Carousel);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/collapse.js":
/*!***************************************************!*\
  !*** ./node_modules/bootstrap/js/src/collapse.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

var NAME = 'collapse';
var VERSION = '4.6.0';
var DATA_KEY = 'bs.collapse';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME];
var Default = {
  toggle: true,
  parent: ''
};
var DefaultType = {
  toggle: 'boolean',
  parent: '(string|element)'
};
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_COLLAPSE = 'collapse';
var CLASS_NAME_COLLAPSING = 'collapsing';
var CLASS_NAME_COLLAPSED = 'collapsed';
var DIMENSION_WIDTH = 'width';
var DIMENSION_HEIGHT = 'height';
var SELECTOR_ACTIVES = '.show, .collapsing';
var SELECTOR_DATA_TOGGLE = '[data-toggle="collapse"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Collapse = /*#__PURE__*/function () {
  function Collapse(element, config) {
    _classCallCheck(this, Collapse);

    this._isTransitioning = false;
    this._element = element;
    this._config = this._getConfig(config);
    this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#".concat(element.id, "\"],") + "[data-toggle=\"collapse\"][data-target=\"#".concat(element.id, "\"]")));
    var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE));

    for (var i = 0, len = toggleList.length; i < len; i++) {
      var elem = toggleList[i];
      var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(elem);
      var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
        return foundElem === element;
      });

      if (selector !== null && filterElement.length > 0) {
        this._selector = selector;

        this._triggerArray.push(elem);
      }
    }

    this._parent = this._config.parent ? this._getParent() : null;

    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._element, this._triggerArray);
    }

    if (this._config.toggle) {
      this.toggle();
    }
  } // Getters


  _createClass(Collapse, [{
    key: "toggle",
    value: // Public
    function toggle() {
      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: "show",
    value: function show() {
      var _this = this;

      if (this._isTransitioning || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_SHOW)) {
        return;
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function (elem) {
          if (typeof _this._config.parent === 'string') {
            return elem.getAttribute('data-parent') === _this._config.parent;
          }

          return elem.classList.contains(CLASS_NAME_COLLAPSE);
        });

        if (actives.length === 0) {
          actives = null;
        }
      }

      if (actives) {
        activesData = jquery__WEBPACK_IMPORTED_MODULE_0___default()(actives).not(this._selector).data(DATA_KEY);

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SHOW);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      if (actives) {
        Collapse._jQueryInterface.call(jquery__WEBPACK_IMPORTED_MODULE_0___default()(actives).not(this._selector), 'hide');

        if (!activesData) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(actives).data(DATA_KEY, null);
        }
      }

      var dimension = this._getDimension();

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;

      if (this._triggerArray.length) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function complete() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass("".concat(CLASS_NAME_COLLAPSE, " ").concat(CLASS_NAME_SHOW));
        _this._element.style[dimension] = '';

        _this.setTransitioning(false);

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this._element).trigger(EVENT_SHOWN);
      };

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll".concat(capitalizedDimension);
      var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._element);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      this._element.style[dimension] = "".concat(this._element[scrollSize], "px");
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this2 = this;

      if (this._isTransitioning || !jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_SHOW)) {
        return;
      }

      var startEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDE);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = "".concat(this._element.getBoundingClientRect()[dimension], "px");
      _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(this._element);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).addClass(CLASS_NAME_COLLAPSING).removeClass("".concat(CLASS_NAME_COLLAPSE, " ").concat(CLASS_NAME_SHOW));
      var triggerArrayLength = this._triggerArray.length;

      if (triggerArrayLength > 0) {
        for (var i = 0; i < triggerArrayLength; i++) {
          var trigger = this._triggerArray[i];
          var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(trigger);

          if (selector !== null) {
            var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()([].slice.call(document.querySelectorAll(selector)));

            if (!$elem.hasClass(CLASS_NAME_SHOW)) {
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(trigger).addClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', false);
            }
          }
        }
      }

      this.setTransitioning(true);

      var complete = function complete() {
        _this2.setTransitioning(false);

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN);
      };

      this._element.style[dimension] = '';
      var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._element);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
    }
  }, {
    key: "setTransitioning",
    value: function setTransitioning(isTransitioning) {
      this._isTransitioning = isTransitioning;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.removeData(this._element, DATA_KEY);
      this._config = null;
      this._parent = null;
      this._element = null;
      this._triggerArray = null;
      this._isTransitioning = null;
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread({}, Default), config);
      config.toggle = Boolean(config.toggle); // Coerce string values

      _util__WEBPACK_IMPORTED_MODULE_1__["default"].typeCheckConfig(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_getDimension",
    value: function _getDimension() {
      var hasWidth = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(DIMENSION_WIDTH);
      return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;
    }
  }, {
    key: "_getParent",
    value: function _getParent() {
      var _this3 = this;

      var parent;

      if (_util__WEBPACK_IMPORTED_MODULE_1__["default"].isElement(this._config.parent)) {
        parent = this._config.parent; // It's a jQuery object

        if (typeof this._config.parent.jquery !== 'undefined') {
          parent = this._config.parent[0];
        }
      } else {
        parent = document.querySelector(this._config.parent);
      }

      var selector = "[data-toggle=\"collapse\"][data-parent=\"".concat(this._config.parent, "\"]");
      var children = [].slice.call(parent.querySelectorAll(selector));
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(children).each(function (i, element) {
        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
      });
      return parent;
    }
  }, {
    key: "_addAriaAndCollapsedClass",
    value: function _addAriaAndCollapsedClass(element, triggerArray) {
      var isOpen = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).hasClass(CLASS_NAME_SHOW);

      if (triggerArray.length) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
      }
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "_getTargetFromElement",
    value: function _getTargetFromElement(element) {
      var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(element);
      return selector ? document.querySelector(selector) : null;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
        var data = $element.data(DATA_KEY);

        var _config = _objectSpread(_objectSpread(_objectSpread({}, Default), $element.data()), _typeof(config) === 'object' && config ? config : {});

        if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $element.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Collapse;
}();
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
  if (event.currentTarget.tagName === 'A') {
    event.preventDefault();
  }

  var $trigger = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
  var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(this);
  var selectors = [].slice.call(document.querySelectorAll(selector));
  jquery__WEBPACK_IMPORTED_MODULE_0___default()(selectors).each(function () {
    var $target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
    var data = $target.data(DATA_KEY);
    var config = data ? 'toggle' : $trigger.data();

    Collapse._jQueryInterface.call($target, config);
  });
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = Collapse._jQueryInterface;
jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].Constructor = Collapse;

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].noConflict = function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = JQUERY_NO_CONFLICT;
  return Collapse._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Collapse);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/dropdown.js":
/*!***************************************************!*\
  !*** ./node_modules/bootstrap/js/src/dropdown.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */



/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

var NAME = 'dropdown';
var VERSION = '4.6.0';
var DATA_KEY = 'bs.dropdown';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME];
var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

var REGEXP_KEYDOWN = new RegExp("".concat(ARROW_UP_KEYCODE, "|").concat(ARROW_DOWN_KEYCODE, "|").concat(ESCAPE_KEYCODE));
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_CLICK = "click".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var EVENT_KEYDOWN_DATA_API = "keydown".concat(EVENT_KEY).concat(DATA_API_KEY);
var EVENT_KEYUP_DATA_API = "keyup".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_DISABLED = 'disabled';
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_DROPUP = 'dropup';
var CLASS_NAME_DROPRIGHT = 'dropright';
var CLASS_NAME_DROPLEFT = 'dropleft';
var CLASS_NAME_MENURIGHT = 'dropdown-menu-right';
var CLASS_NAME_POSITION_STATIC = 'position-static';
var SELECTOR_DATA_TOGGLE = '[data-toggle="dropdown"]';
var SELECTOR_FORM_CHILD = '.dropdown form';
var SELECTOR_MENU = '.dropdown-menu';
var SELECTOR_NAVBAR_NAV = '.navbar-nav';
var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
var PLACEMENT_TOP = 'top-start';
var PLACEMENT_TOPEND = 'top-end';
var PLACEMENT_BOTTOM = 'bottom-start';
var PLACEMENT_BOTTOMEND = 'bottom-end';
var PLACEMENT_RIGHT = 'right-start';
var PLACEMENT_LEFT = 'left-start';
var Default = {
  offset: 0,
  flip: true,
  boundary: 'scrollParent',
  reference: 'toggle',
  display: 'dynamic',
  popperConfig: null
};
var DefaultType = {
  offset: '(number|string|function)',
  flip: 'boolean',
  boundary: '(string|element)',
  reference: '(string|element)',
  display: 'string',
  popperConfig: '(null|object)'
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Dropdown = /*#__PURE__*/function () {
  function Dropdown(element, config) {
    _classCallCheck(this, Dropdown);

    this._element = element;
    this._popper = null;
    this._config = this._getConfig(config);
    this._menu = this._getMenuElement();
    this._inNavbar = this._detectNavbar();

    this._addEventListeners();
  } // Getters


  _createClass(Dropdown, [{
    key: "toggle",
    value: // Public
    function toggle() {
      if (this._element.disabled || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_DISABLED)) {
        return;
      }

      var isActive = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._menu).hasClass(CLASS_NAME_SHOW);

      Dropdown._clearMenus();

      if (isActive) {
        return;
      }

      this.show(true);
    }
  }, {
    key: "show",
    value: function show() {
      var usePopper = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this._element.disabled || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_DISABLED) || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._menu).hasClass(CLASS_NAME_SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SHOW, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      } // Totally disable Popper for Dropdowns in Navbar


      if (!this._inNavbar && usePopper) {
        /**
         * Check for Popper dependency
         * Popper - https://popper.js.org
         */
        if (typeof popper_js__WEBPACK_IMPORTED_MODULE_1__["default"] === 'undefined') {
          throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
        }

        var referenceElement = this._element;

        if (this._config.reference === 'parent') {
          referenceElement = parent;
        } else if (_util__WEBPACK_IMPORTED_MODULE_2__["default"].isElement(this._config.reference)) {
          referenceElement = this._config.reference; // Check if it's jQuery element

          if (typeof this._config.reference.jquery !== 'undefined') {
            referenceElement = this._config.reference[0];
          }
        } // If boundary is not `scrollParent`, then set position to `static`
        // to allow the menu to "escape" the scroll parent's boundaries
        // https://github.com/twbs/bootstrap/issues/24251


        if (this._config.boundary !== 'scrollParent') {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).addClass(CLASS_NAME_POSITION_STATIC);
        }

        this._popper = new popper_js__WEBPACK_IMPORTED_MODULE_1__["default"](referenceElement, this._menu, this._getPopperConfig());
      } // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


      if ('ontouchstart' in document.documentElement && jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).closest(SELECTOR_NAVBAR_NAV).length === 0) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).children().on('mouseover', null, jquery__WEBPACK_IMPORTED_MODULE_0___default.a.noop);
      }

      this._element.focus();

      this._element.setAttribute('aria-expanded', true);

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._menu).toggleClass(CLASS_NAME_SHOW);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).toggleClass(CLASS_NAME_SHOW).trigger(jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SHOWN, relatedTarget));
    }
  }, {
    key: "hide",
    value: function hide() {
      if (this._element.disabled || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_DISABLED) || !jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._menu).hasClass(CLASS_NAME_SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var hideEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDE, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      if (this._popper) {
        this._popper.destroy();
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._menu).toggleClass(CLASS_NAME_SHOW);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).toggleClass(CLASS_NAME_SHOW).trigger(jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDDEN, relatedTarget));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.removeData(this._element, DATA_KEY);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).off(EVENT_KEY);
      this._element = null;
      this._menu = null;

      if (this._popper !== null) {
        this._popper.destroy();

        this._popper = null;
      }
    }
  }, {
    key: "update",
    value: function update() {
      this._inNavbar = this._detectNavbar();

      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Private

  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var _this = this;

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_CLICK, function (event) {
        event.preventDefault();
        event.stopPropagation();

        _this.toggle();
      });
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).data()), config);
      _util__WEBPACK_IMPORTED_MODULE_2__["default"].typeCheckConfig(NAME, config, this.constructor.DefaultType);
      return config;
    }
  }, {
    key: "_getMenuElement",
    value: function _getMenuElement() {
      if (!this._menu) {
        var parent = Dropdown._getParentFromElement(this._element);

        if (parent) {
          this._menu = parent.querySelector(SELECTOR_MENU);
        }
      }

      return this._menu;
    }
  }, {
    key: "_getPlacement",
    value: function _getPlacement() {
      var $parentDropdown = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element.parentNode);
      var placement = PLACEMENT_BOTTOM; // Handle dropup

      if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {
        placement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {
        placement = PLACEMENT_RIGHT;
      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {
        placement = PLACEMENT_LEFT;
      } else if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._menu).hasClass(CLASS_NAME_MENURIGHT)) {
        placement = PLACEMENT_BOTTOMEND;
      }

      return placement;
    }
  }, {
    key: "_detectNavbar",
    value: function _detectNavbar() {
      return jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).closest('.navbar').length > 0;
    }
  }, {
    key: "_getOffset",
    value: function _getOffset() {
      var _this2 = this;

      var offset = {};

      if (typeof this._config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread(_objectSpread({}, data.offsets), _this2._config.offset(data.offsets, _this2._element) || {});
          return data;
        };
      } else {
        offset.offset = this._config.offset;
      }

      return offset;
    }
  }, {
    key: "_getPopperConfig",
    value: function _getPopperConfig() {
      var popperConfig = {
        placement: this._getPlacement(),
        modifiers: {
          offset: this._getOffset(),
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        }
      }; // Disable Popper if we have a static display

      if (this._config.display === 'static') {
        popperConfig.modifiers.applyStyle = {
          enabled: false
        };
      }

      return _objectSpread(_objectSpread({}, popperConfig), this._config.popperConfig);
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var data = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY);

        var _config = _typeof(config) === 'object' ? config : null;

        if (!data) {
          data = new Dropdown(this, _config);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }, {
    key: "_clearMenus",
    value: function _clearMenus(event) {
      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
        return;
      }

      var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE));

      for (var i = 0, len = toggles.length; i < len; i++) {
        var parent = Dropdown._getParentFromElement(toggles[i]);

        var context = jquery__WEBPACK_IMPORTED_MODULE_0___default()(toggles[i]).data(DATA_KEY);
        var relatedTarget = {
          relatedTarget: toggles[i]
        };

        if (event && event.type === 'click') {
          relatedTarget.clickEvent = event;
        }

        if (!context) {
          continue;
        }

        var dropdownMenu = context._menu;

        if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).hasClass(CLASS_NAME_SHOW)) {
          continue;
        }

        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && jquery__WEBPACK_IMPORTED_MODULE_0___default.a.contains(parent, event.target)) {
          continue;
        }

        var hideEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDE, relatedTarget);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          continue;
        } // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support


        if ('ontouchstart' in document.documentElement) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).children().off('mouseover', null, jquery__WEBPACK_IMPORTED_MODULE_0___default.a.noop);
        }

        toggles[i].setAttribute('aria-expanded', 'false');

        if (context._popper) {
          context._popper.destroy();
        }

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(dropdownMenu).removeClass(CLASS_NAME_SHOW);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).removeClass(CLASS_NAME_SHOW).trigger(jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDDEN, relatedTarget));
      }
    }
  }, {
    key: "_getParentFromElement",
    value: function _getParentFromElement(element) {
      var parent;
      var selector = _util__WEBPACK_IMPORTED_MODULE_2__["default"].getSelectorFromElement(element);

      if (selector) {
        parent = document.querySelector(selector);
      }

      return parent || element.parentNode;
    } // eslint-disable-next-line complexity

  }, {
    key: "_dataApiKeydownHandler",
    value: function _dataApiKeydownHandler(event) {
      // If not input/textarea:
      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
      // If input/textarea:
      //  - If space key => not a dropdown command
      //  - If key is other than escape
      //    - If key is not up or down => not a dropdown command
      //    - If trigger inside the menu => not a dropdown command
      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || jquery__WEBPACK_IMPORTED_MODULE_0___default()(event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
        return;
      }

      if (this.disabled || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).hasClass(CLASS_NAME_DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this);

      var isActive = jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).hasClass(CLASS_NAME_SHOW);

      if (!isActive && event.which === ESCAPE_KEYCODE) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if (!isActive || event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE) {
        if (event.which === ESCAPE_KEYCODE) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent.querySelector(SELECTOR_DATA_TOGGLE)).trigger('focus');
        }

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger('click');
        return;
      }

      var items = [].slice.call(parent.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function (item) {
        return jquery__WEBPACK_IMPORTED_MODULE_0___default()(item).is(':visible');
      });

      if (items.length === 0) {
        return;
      }

      var index = items.indexOf(event.target);

      if (event.which === ARROW_UP_KEYCODE && index > 0) {
        // Up
        index--;
      }

      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
        // Down
        index++;
      }

      if (index < 0) {
        index = 0;
      }

      items[index].focus();
    }
  }]);

  return Dropdown;
}();
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on("".concat(EVENT_CLICK_DATA_API, " ").concat(EVENT_KEYUP_DATA_API), Dropdown._clearMenus).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  event.preventDefault();
  event.stopPropagation();

  Dropdown._jQueryInterface.call(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'toggle');
}).on(EVENT_CLICK_DATA_API, SELECTOR_FORM_CHILD, function (e) {
  e.stopPropagation();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = Dropdown._jQueryInterface;
jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].Constructor = Dropdown;

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].noConflict = function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = JQUERY_NO_CONFLICT;
  return Dropdown._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Dropdown);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/modal.js":
/*!************************************************!*\
  !*** ./node_modules/bootstrap/js/src/modal.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

var NAME = 'modal';
var VERSION = '4.6.0';
var DATA_KEY = 'bs.modal';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME];
var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

var Default = {
  backdrop: true,
  keyboard: true,
  focus: true,
  show: true
};
var DefaultType = {
  backdrop: '(boolean|string)',
  keyboard: 'boolean',
  focus: 'boolean',
  show: 'boolean'
};
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDE_PREVENTED = "hidePrevented".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY);
var EVENT_RESIZE = "resize".concat(EVENT_KEY);
var EVENT_CLICK_DISMISS = "click.dismiss".concat(EVENT_KEY);
var EVENT_KEYDOWN_DISMISS = "keydown.dismiss".concat(EVENT_KEY);
var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss".concat(EVENT_KEY);
var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_SCROLLABLE = 'modal-dialog-scrollable';
var CLASS_NAME_SCROLLBAR_MEASURER = 'modal-scrollbar-measure';
var CLASS_NAME_BACKDROP = 'modal-backdrop';
var CLASS_NAME_OPEN = 'modal-open';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_STATIC = 'modal-static';
var SELECTOR_DIALOG = '.modal-dialog';
var SELECTOR_MODAL_BODY = '.modal-body';
var SELECTOR_DATA_TOGGLE = '[data-toggle="modal"]';
var SELECTOR_DATA_DISMISS = '[data-dismiss="modal"]';
var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
var SELECTOR_STICKY_CONTENT = '.sticky-top';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Modal = /*#__PURE__*/function () {
  function Modal(element, config) {
    _classCallCheck(this, Modal);

    this._config = this._getConfig(config);
    this._element = element;
    this._dialog = element.querySelector(SELECTOR_DIALOG);
    this._backdrop = null;
    this._isShown = false;
    this._isBodyOverflowing = false;
    this._ignoreBackdropClick = false;
    this._isTransitioning = false;
    this._scrollbarWidth = 0;
  } // Getters


  _createClass(Modal, [{
    key: "toggle",
    value: // Public
    function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
  }, {
    key: "show",
    value: function show(relatedTarget) {
      var _this = this;

      if (this._isShown || this._isTransitioning) {
        return;
      }

      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE)) {
        this._isTransitioning = true;
      }

      var showEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SHOW, {
        relatedTarget: relatedTarget
      });
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(showEvent);

      if (this._isShown || showEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = true;

      this._checkScrollbar();

      this._setScrollbar();

      this._adjustDialog();

      this._setEscapeEvent();

      this._setResizeEvent();

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function (event) {
        return _this.hide(event);
      });
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function () {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this._element).one(EVENT_MOUSEUP_DISMISS, function (event) {
          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(event.target).is(_this._element)) {
            _this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this._showElement(relatedTarget);
      });
    }
  }, {
    key: "hide",
    value: function hide(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      if (!this._isShown || this._isTransitioning) {
        return;
      }

      var hideEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDE);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = false;
      var transition = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE);

      if (transition) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).off(EVENT_FOCUSIN);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).removeClass(CLASS_NAME_SHOW);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).off(EVENT_CLICK_DISMISS);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._dialog).off(EVENT_MOUSEDOWN_DISMISS);

      if (transition) {
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._element);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, function (event) {
          return _this2._hideModal(event);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        this._hideModal();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      [window, this._element, this._dialog].forEach(function (htmlElement) {
        return jquery__WEBPACK_IMPORTED_MODULE_0___default()(htmlElement).off(EVENT_KEY);
      });
      /**
       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`
       * Do not move `document` in `htmlElements` array
       * It will remove `EVENT_CLICK_DATA_API` event that should remain
       */

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).off(EVENT_FOCUSIN);
      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.removeData(this._element, DATA_KEY);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._isTransitioning = null;
      this._scrollbarWidth = null;
    }
  }, {
    key: "handleUpdate",
    value: function handleUpdate() {
      this._adjustDialog();
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread({}, Default), config);
      _util__WEBPACK_IMPORTED_MODULE_1__["default"].typeCheckConfig(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_triggerBackdropTransition",
    value: function _triggerBackdropTransition() {
      var _this3 = this;

      var hideEventPrevented = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDE_PREVENTED);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(hideEventPrevented);

      if (hideEventPrevented.isDefaultPrevented()) {
        return;
      }

      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!isModalOverflowing) {
        this._element.style.overflowY = 'hidden';
      }

      this._element.classList.add(CLASS_NAME_STATIC);

      var modalTransitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._dialog);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).off(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, function () {
        _this3._element.classList.remove(CLASS_NAME_STATIC);

        if (!isModalOverflowing) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this3._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, function () {
            _this3._element.style.overflowY = '';
          }).emulateTransitionEnd(_this3._element, modalTransitionDuration);
        }
      }).emulateTransitionEnd(modalTransitionDuration);

      this._element.focus();
    }
  }, {
    key: "_showElement",
    value: function _showElement(relatedTarget) {
      var _this4 = this;

      var transition = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE);
      var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      this._element.setAttribute('role', 'dialog');

      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {
        modalBody.scrollTop = 0;
      } else {
        this._element.scrollTop = 0;
      }

      if (transition) {
        _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(this._element);
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).addClass(CLASS_NAME_SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function transitionComplete() {
        if (_this4._config.focus) {
          _this4._element.focus();
        }

        _this4._isTransitioning = false;
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this4._element).trigger(shownEvent);
      };

      if (transition) {
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._dialog);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._dialog).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
      } else {
        transitionComplete();
      }
    }
  }, {
    key: "_enforceFocus",
    value: function _enforceFocus() {
      var _this5 = this;

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).off(EVENT_FOCUSIN) // Guard against infinite focus loop
      .on(EVENT_FOCUSIN, function (event) {
        if (document !== event.target && _this5._element !== event.target && jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this5._element).has(event.target).length === 0) {
          _this5._element.focus();
        }
      });
    }
  }, {
    key: "_setEscapeEvent",
    value: function _setEscapeEvent() {
      var _this6 = this;

      if (this._isShown) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_KEYDOWN_DISMISS, function (event) {
          if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
            event.preventDefault();

            _this6.hide();
          } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
            _this6._triggerBackdropTransition();
          }
        });
      } else if (!this._isShown) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).off(EVENT_KEYDOWN_DISMISS);
      }
    }
  }, {
    key: "_setResizeEvent",
    value: function _setResizeEvent() {
      var _this7 = this;

      if (this._isShown) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on(EVENT_RESIZE, function (event) {
          return _this7.handleUpdate(event);
        });
      } else {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(EVENT_RESIZE);
      }
    }
  }, {
    key: "_hideModal",
    value: function _hideModal() {
      var _this8 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._element.removeAttribute('role');

      this._isTransitioning = false;

      this._showBackdrop(function () {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).removeClass(CLASS_NAME_OPEN);

        _this8._resetAdjustments();

        _this8._resetScrollbar();

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this8._element).trigger(EVENT_HIDDEN);
      });
    }
  }, {
    key: "_removeBackdrop",
    value: function _removeBackdrop() {
      if (this._backdrop) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).remove();
        this._backdrop = null;
      }
    }
  }, {
    key: "_showBackdrop",
    value: function _showBackdrop(callback) {
      var _this9 = this;

      var animate = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE) ? CLASS_NAME_FADE : '';

      if (this._isShown && this._config.backdrop) {
        this._backdrop = document.createElement('div');
        this._backdrop.className = CLASS_NAME_BACKDROP;

        if (animate) {
          this._backdrop.classList.add(animate);
        }

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).appendTo(document.body);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_CLICK_DISMISS, function (event) {
          if (_this9._ignoreBackdropClick) {
            _this9._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          if (_this9._config.backdrop === 'static') {
            _this9._triggerBackdropTransition();
          } else {
            _this9.hide();
          }
        });

        if (animate) {
          _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(this._backdrop);
        }

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).addClass(CLASS_NAME_SHOW);

        if (!callback) {
          return;
        }

        if (!animate) {
          callback();
          return;
        }

        var backdropTransitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._backdrop);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
      } else if (!this._isShown && this._backdrop) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).removeClass(CLASS_NAME_SHOW);

        var callbackRemove = function callbackRemove() {
          _this9._removeBackdrop();

          if (callback) {
            callback();
          }
        };

        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE)) {
          var _backdropTransitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._backdrop);

          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
        } else {
          callbackRemove();
        }
      } else if (callback) {
        callback();
      }
    } // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------

  }, {
    key: "_adjustDialog",
    value: function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = "".concat(this._scrollbarWidth, "px");
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = "".concat(this._scrollbarWidth, "px");
      }
    }
  }, {
    key: "_resetAdjustments",
    value: function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    }
  }, {
    key: "_checkScrollbar",
    value: function _checkScrollbar() {
      var rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    }
  }, {
    key: "_setScrollbar",
    value: function _setScrollbar() {
      var _this10 = this;

      if (this._isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
        var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT)); // Adjust fixed content padding

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(fixedContent).each(function (index, element) {
          var actualPadding = element.style.paddingRight;
          var calculatedPadding = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('padding-right');
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).data('padding-right', actualPadding).css('padding-right', "".concat(parseFloat(calculatedPadding) + _this10._scrollbarWidth, "px"));
        }); // Adjust sticky content margin

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(stickyContent).each(function (index, element) {
          var actualMargin = element.style.marginRight;
          var calculatedMargin = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('margin-right');
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).data('margin-right', actualMargin).css('margin-right', "".concat(parseFloat(calculatedMargin) - _this10._scrollbarWidth, "px"));
        }); // Adjust body padding

        var actualPadding = document.body.style.paddingRight;
        var calculatedPadding = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).css('padding-right');
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).data('padding-right', actualPadding).css('padding-right', "".concat(parseFloat(calculatedPadding) + this._scrollbarWidth, "px"));
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).addClass(CLASS_NAME_OPEN);
    }
  }, {
    key: "_resetScrollbar",
    value: function _resetScrollbar() {
      // Restore fixed content padding
      var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(fixedContent).each(function (index, element) {
        var padding = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).data('padding-right');
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).removeData('padding-right');
        element.style.paddingRight = padding ? padding : '';
      }); // Restore sticky content

      var elements = [].slice.call(document.querySelectorAll("".concat(SELECTOR_STICKY_CONTENT)));
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(elements).each(function (index, element) {
        var margin = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).data('margin-right');

        if (typeof margin !== 'undefined') {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('margin-right', margin).removeData('margin-right');
        }
      }); // Restore body padding

      var padding = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).data('padding-right');
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).removeData('padding-right');
      document.body.style.paddingRight = padding ? padding : '';
    }
  }, {
    key: "_getScrollbarWidth",
    value: function _getScrollbarWidth() {
      // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY);

        var _config = _objectSpread(_objectSpread(_objectSpread({}, Default), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data()), _typeof(config) === 'object' && config ? config : {});

        if (!data) {
          data = new Modal(this, _config);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      });
    }
  }]);

  return Modal;
}();
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  var _this11 = this;

  var target;
  var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(this);

  if (selector) {
    target = document.querySelector(selector);
  }

  var config = jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).data(DATA_KEY) ? 'toggle' : _objectSpread(_objectSpread({}, jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).data()), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data());

  if (this.tagName === 'A' || this.tagName === 'AREA') {
    event.preventDefault();
  }

  var $target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).one(EVENT_SHOW, function (showEvent) {
    if (showEvent.isDefaultPrevented()) {
      // Only register focus restorer if modal will actually get shown
      return;
    }

    $target.one(EVENT_HIDDEN, function () {
      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this11).is(':visible')) {
        _this11.focus();
      }
    });
  });

  Modal._jQueryInterface.call(jquery__WEBPACK_IMPORTED_MODULE_0___default()(target), config, this);
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = Modal._jQueryInterface;
jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].Constructor = Modal;

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].noConflict = function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = JQUERY_NO_CONFLICT;
  return Modal._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Modal);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/popover.js":
/*!**************************************************!*\
  !*** ./node_modules/bootstrap/js/src/popover.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tooltip */ "./node_modules/bootstrap/js/src/tooltip.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

var NAME = 'popover';
var VERSION = '4.6.0';
var DATA_KEY = 'bs.popover';
var EVENT_KEY = ".".concat(DATA_KEY);
var JQUERY_NO_CONFLICT = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME];
var CLASS_PREFIX = 'bs-popover';
var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)".concat(CLASS_PREFIX, "\\S+"), 'g');

var Default = _objectSpread(_objectSpread({}, _tooltip__WEBPACK_IMPORTED_MODULE_1__["default"].Default), {}, {
  placement: 'right',
  trigger: 'click',
  content: '',
  template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
});

var DefaultType = _objectSpread(_objectSpread({}, _tooltip__WEBPACK_IMPORTED_MODULE_1__["default"].DefaultType), {}, {
  content: '(string|element|function)'
});

var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var SELECTOR_TITLE = '.popover-header';
var SELECTOR_CONTENT = '.popover-body';
var Event = {
  HIDE: "hide".concat(EVENT_KEY),
  HIDDEN: "hidden".concat(EVENT_KEY),
  SHOW: "show".concat(EVENT_KEY),
  SHOWN: "shown".concat(EVENT_KEY),
  INSERTED: "inserted".concat(EVENT_KEY),
  CLICK: "click".concat(EVENT_KEY),
  FOCUSIN: "focusin".concat(EVENT_KEY),
  FOCUSOUT: "focusout".concat(EVENT_KEY),
  MOUSEENTER: "mouseenter".concat(EVENT_KEY),
  MOUSELEAVE: "mouseleave".concat(EVENT_KEY)
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Popover = /*#__PURE__*/function (_Tooltip) {
  _inherits(Popover, _Tooltip);

  var _super = _createSuper(Popover);

  function Popover() {
    _classCallCheck(this, Popover);

    return _super.apply(this, arguments);
  }

  _createClass(Popover, [{
    key: "isWithContent",
    value: // Overrides
    function isWithContent() {
      return this.getTitle() || this._getContent();
    }
  }, {
    key: "addAttachmentClass",
    value: function addAttachmentClass(attachment) {
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.getTipElement()).addClass("".concat(CLASS_PREFIX, "-").concat(attachment));
    }
  }, {
    key: "getTipElement",
    value: function getTipElement() {
      this.tip = this.tip || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.config.template)[0];
      return this.tip;
    }
  }, {
    key: "setContent",
    value: function setContent() {
      var $tip = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.getTipElement()); // We use append for html objects to maintain js events

      this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());

      var content = this._getContent();

      if (typeof content === 'function') {
        content = content.call(this.element);
      }

      this.setElementContent($tip.find(SELECTOR_CONTENT), content);
      $tip.removeClass("".concat(CLASS_NAME_FADE, " ").concat(CLASS_NAME_SHOW));
    } // Private

  }, {
    key: "_getContent",
    value: function _getContent() {
      return this.element.getAttribute('data-content') || this.config.content;
    }
  }, {
    key: "_cleanTipClass",
    value: function _cleanTipClass() {
      var $tip = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    } // Static

  }], [{
    key: "VERSION",
    get: // Getters
    function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "DATA_KEY",
    get: function get() {
      return DATA_KEY;
    }
  }, {
    key: "Event",
    get: function get() {
      return Event;
    }
  }, {
    key: "EVENT_KEY",
    get: function get() {
      return EVENT_KEY;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var data = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY);

        var _config = _typeof(config) === 'object' ? config : null;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Popover(this, _config);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Popover;
}(_tooltip__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = Popover._jQueryInterface;
jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].Constructor = Popover;

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].noConflict = function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = JQUERY_NO_CONFLICT;
  return Popover._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Popover);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/tab.js":
/*!**********************************************!*\
  !*** ./node_modules/bootstrap/js/src/tab.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

var NAME = 'tab';
var VERSION = '4.6.0';
var DATA_KEY = 'bs.tab';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME];
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';
var CLASS_NAME_ACTIVE = 'active';
var CLASS_NAME_DISABLED = 'disabled';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var SELECTOR_DROPDOWN = '.dropdown';
var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
var SELECTOR_ACTIVE = '.active';
var SELECTOR_ACTIVE_UL = '> li > .active';
var SELECTOR_DATA_TOGGLE = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]';
var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
var SELECTOR_DROPDOWN_ACTIVE_CHILD = '> .dropdown-menu .active';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Tab = /*#__PURE__*/function () {
  function Tab(element) {
    _classCallCheck(this, Tab);

    this._element = element;
  } // Getters


  _createClass(Tab, [{
    key: "show",
    value: // Public
    function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_ACTIVE) || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).closest(SELECTOR_NAV_LIST_GROUP)[0];
      var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
        previous = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.makeArray(jquery__WEBPACK_IMPORTED_MODULE_0___default()(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDE, {
        relatedTarget: this._element
      });
      var showEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(previous).trigger(hideEvent);
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = document.querySelector(selector);
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.Event(EVENT_SHOWN, {
          relatedTarget: previous
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(previous).trigger(hiddenEvent);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.removeData(this._element, DATA_KEY);
      this._element = null;
    } // Private

  }, {
    key: "_activate",
    value: function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(container).find(SELECTOR_ACTIVE_UL) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(container).children(SELECTOR_ACTIVE);
      var active = activeElements[0];
      var isTransitioning = callback && active && jquery__WEBPACK_IMPORTED_MODULE_0___default()(active).hasClass(CLASS_NAME_FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active && isTransitioning) {
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(active);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(active).removeClass(CLASS_NAME_SHOW).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    }
  }, {
    key: "_transitionComplete",
    value: function _transitionComplete(element, active, callback) {
      if (active) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(active).removeClass(CLASS_NAME_ACTIVE);
        var dropdownChild = jquery__WEBPACK_IMPORTED_MODULE_0___default()(active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(dropdownChild).removeClass(CLASS_NAME_ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).addClass(CLASS_NAME_ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(element);

      if (element.classList.contains(CLASS_NAME_FADE)) {
        element.classList.add(CLASS_NAME_SHOW);
      }

      if (element.parentNode && jquery__WEBPACK_IMPORTED_MODULE_0___default()(element.parentNode).hasClass(CLASS_NAME_DROPDOWN_MENU)) {
        var dropdownElement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).closest(SELECTOR_DROPDOWN)[0];

        if (dropdownElement) {
          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE));
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(dropdownToggleList).addClass(CLASS_NAME_ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var $this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
        var data = $this.data(DATA_KEY);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Tab;
}();
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  event.preventDefault();

  Tab._jQueryInterface.call(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'show');
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = Tab._jQueryInterface;
jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].Constructor = Tab;

jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME].noConflict = function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn[NAME] = JQUERY_NO_CONFLICT;
  return Tab._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Tab);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/tools/sanitizer.js":
/*!**********************************************************!*\
  !*** ./node_modules/bootstrap/js/src/tools/sanitizer.js ***!
  \**********************************************************/
/*! exports provided: DefaultWhitelist, sanitizeHtml */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultWhitelist", function() { return DefaultWhitelist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeHtml", function() { return sanitizeHtml; });
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): tools/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
var DefaultWhitelist = {
  // Global attributes allowed on any supplied element below.
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
  a: ['target', 'href', 'title', 'rel'],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
/**
 * A pattern that recognizes a commonly useful subset of URLs that are safe.
 *
 * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
 */

var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi;
/**
 * A pattern that matches safe data URLs. Only matches image, video and audio types.
 *
 * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
 */

var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

function allowedAttribute(attr, allowedAttributeList) {
  var attrName = attr.nodeName.toLowerCase();

  if (allowedAttributeList.indexOf(attrName) !== -1) {
    if (uriAttrs.indexOf(attrName) !== -1) {
      return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
    }

    return true;
  }

  var regExp = allowedAttributeList.filter(function (attrRegex) {
    return attrRegex instanceof RegExp;
  }); // Check if a regular expression validates the attribute.

  for (var i = 0, len = regExp.length; i < len; i++) {
    if (attrName.match(regExp[i])) {
      return true;
    }
  }

  return false;
}

function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
  if (unsafeHtml.length === 0) {
    return unsafeHtml;
  }

  if (sanitizeFn && typeof sanitizeFn === 'function') {
    return sanitizeFn(unsafeHtml);
  }

  var domParser = new window.DOMParser();
  var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
  var whitelistKeys = Object.keys(whiteList);
  var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

  var _loop = function _loop(i, len) {
    var el = elements[i];
    var elName = el.nodeName.toLowerCase();

    if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
      el.parentNode.removeChild(el);
      return "continue";
    }

    var attributeList = [].slice.call(el.attributes);
    var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
    attributeList.forEach(function (attr) {
      if (!allowedAttribute(attr, whitelistedAttributes)) {
        el.removeAttribute(attr.nodeName);
      }
    });
  };

  for (var i = 0, len = elements.length; i < len; i++) {
    var _ret = _loop(i, len);

    if (_ret === "continue") continue;
  }

  return createdDocument.body.innerHTML;
}

/***/ }),

/***/ "./node_modules/bootstrap/js/src/tooltip.js":
/*!**************************************************!*\
  !*** ./node_modules/bootstrap/js/src/tooltip.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_sanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools/sanitizer */ "./node_modules/bootstrap/js/src/tools/sanitizer.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */




/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

var NAME = 'tooltip';
var VERSION = '4.6.0';
var DATA_KEY = 'bs.tooltip';
var EVENT_KEY = ".".concat(DATA_KEY);
var JQUERY_NO_CONFLICT = jquery__WEBPACK_IMPORTED_MODULE_1___default.a.fn[NAME];
var CLASS_PREFIX = 'bs-tooltip';
var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)".concat(CLASS_PREFIX, "\\S+"), 'g');
var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
var DefaultType = {
  animation: 'boolean',
  template: 'string',
  title: '(string|element|function)',
  trigger: 'string',
  delay: '(number|object)',
  html: 'boolean',
  selector: '(string|boolean)',
  placement: '(string|function)',
  offset: '(number|string|function)',
  container: '(string|element|boolean)',
  fallbackPlacement: '(string|array)',
  boundary: '(string|element)',
  customClass: '(string|function)',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  whiteList: 'object',
  popperConfig: '(null|object)'
};
var AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left'
};
var Default = {
  animation: true,
  template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
  trigger: 'hover focus',
  title: '',
  delay: 0,
  html: false,
  selector: false,
  placement: 'top',
  offset: 0,
  container: false,
  fallbackPlacement: 'flip',
  boundary: 'scrollParent',
  customClass: '',
  sanitize: true,
  sanitizeFn: null,
  whiteList: _tools_sanitizer__WEBPACK_IMPORTED_MODULE_0__["DefaultWhitelist"],
  popperConfig: null
};
var HOVER_STATE_SHOW = 'show';
var HOVER_STATE_OUT = 'out';
var Event = {
  HIDE: "hide".concat(EVENT_KEY),
  HIDDEN: "hidden".concat(EVENT_KEY),
  SHOW: "show".concat(EVENT_KEY),
  SHOWN: "shown".concat(EVENT_KEY),
  INSERTED: "inserted".concat(EVENT_KEY),
  CLICK: "click".concat(EVENT_KEY),
  FOCUSIN: "focusin".concat(EVENT_KEY),
  FOCUSOUT: "focusout".concat(EVENT_KEY),
  MOUSEENTER: "mouseenter".concat(EVENT_KEY),
  MOUSELEAVE: "mouseleave".concat(EVENT_KEY)
};
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
var SELECTOR_ARROW = '.arrow';
var TRIGGER_HOVER = 'hover';
var TRIGGER_FOCUS = 'focus';
var TRIGGER_CLICK = 'click';
var TRIGGER_MANUAL = 'manual';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Tooltip = /*#__PURE__*/function () {
  function Tooltip(element, config) {
    _classCallCheck(this, Tooltip);

    if (typeof popper_js__WEBPACK_IMPORTED_MODULE_2__["default"] === 'undefined') {
      throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
    } // private


    this._isEnabled = true;
    this._timeout = 0;
    this._hoverState = '';
    this._activeTrigger = {};
    this._popper = null; // Protected

    this.element = element;
    this.config = this._getConfig(config);
    this.tip = null;

    this._setListeners();
  } // Getters


  _createClass(Tooltip, [{
    key: "enable",
    value: // Public
    function enable() {
      this._isEnabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      this._isEnabled = false;
    }
  }, {
    key: "toggleEnabled",
    value: function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.getTipElement()).hasClass(CLASS_NAME_SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      clearTimeout(this._timeout);
      jquery__WEBPACK_IMPORTED_MODULE_1___default.a.removeData(this.element, this.constructor.DATA_KEY);
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).off(this.constructor.EVENT_KEY);
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);

      if (this.tip) {
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.tip).remove();
      }

      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;

      if (this._popper) {
        this._popper.destroy();
      }

      this._popper = null;
      this.element = null;
      this.config = null;
      this.tip = null;
    }
  }, {
    key: "show",
    value: function show() {
      var _this = this;

      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements');
      }

      var showEvent = jquery__WEBPACK_IMPORTED_MODULE_1___default.a.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).trigger(showEvent);
        var shadowRoot = _util__WEBPACK_IMPORTED_MODULE_3__["default"].findShadowRoot(this.element);
        var isInTheDom = jquery__WEBPACK_IMPORTED_MODULE_1___default.a.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return;
        }

        var tip = this.getTipElement();
        var tipId = _util__WEBPACK_IMPORTED_MODULE_3__["default"].getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);
        this.setContent();

        if (this.config.animation) {
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).addClass(CLASS_NAME_FADE);
        }

        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

        var attachment = this._getAttachment(placement);

        this.addAttachmentClass(attachment);

        var container = this._getContainer();

        jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).data(this.constructor.DATA_KEY, this);

        if (!jquery__WEBPACK_IMPORTED_MODULE_1___default.a.contains(this.element.ownerDocument.documentElement, this.tip)) {
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).appendTo(container);
        }

        jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).trigger(this.constructor.Event.INSERTED);
        this._popper = new popper_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.element, tip, this._getPopperConfig(attachment));
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).addClass(CLASS_NAME_SHOW);
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).addClass(this.config.customClass); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(document.body).children().on('mouseover', null, jquery__WEBPACK_IMPORTED_MODULE_1___default.a.noop);
        }

        var complete = function complete() {
          if (_this.config.animation) {
            _this._fixTransition();
          }

          var prevHoverState = _this._hoverState;
          _this._hoverState = null;
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(_this.element).trigger(_this.constructor.Event.SHOWN);

          if (prevHoverState === HOVER_STATE_OUT) {
            _this._leave(null, _this);
          }
        };

        if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.tip).hasClass(CLASS_NAME_FADE)) {
          var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_3__["default"].getTransitionDurationFromElement(this.tip);
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.tip).one(_util__WEBPACK_IMPORTED_MODULE_3__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      }
    }
  }, {
    key: "hide",
    value: function hide(callback) {
      var _this2 = this;

      var tip = this.getTipElement();
      var hideEvent = jquery__WEBPACK_IMPORTED_MODULE_1___default.a.Event(this.constructor.Event.HIDE);

      var complete = function complete() {
        if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        _this2._cleanTipClass();

        _this2.element.removeAttribute('aria-describedby');

        jquery__WEBPACK_IMPORTED_MODULE_1___default()(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

        if (_this2._popper !== null) {
          _this2._popper.destroy();
        }

        if (callback) {
          callback();
        }
      };

      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).removeClass(CLASS_NAME_SHOW); // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(document.body).children().off('mouseover', null, jquery__WEBPACK_IMPORTED_MODULE_1___default.a.noop);
      }

      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;

      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.tip).hasClass(CLASS_NAME_FADE)) {
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_3__["default"].getTransitionDurationFromElement(tip);
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).one(_util__WEBPACK_IMPORTED_MODULE_3__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }

      this._hoverState = '';
    }
  }, {
    key: "update",
    value: function update() {
      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Protected

  }, {
    key: "isWithContent",
    value: function isWithContent() {
      return Boolean(this.getTitle());
    }
  }, {
    key: "addAttachmentClass",
    value: function addAttachmentClass(attachment) {
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.getTipElement()).addClass("".concat(CLASS_PREFIX, "-").concat(attachment));
    }
  }, {
    key: "getTipElement",
    value: function getTipElement() {
      this.tip = this.tip || jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.config.template)[0];
      return this.tip;
    }
  }, {
    key: "setContent",
    value: function setContent() {
      var tip = this.getTipElement();
      this.setElementContent(jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).removeClass("".concat(CLASS_NAME_FADE, " ").concat(CLASS_NAME_SHOW));
    }
  }, {
    key: "setElementContent",
    value: function setElementContent($element, content) {
      if (_typeof(content) === 'object' && (content.nodeType || content.jquery)) {
        // Content is a DOM node or a jQuery
        if (this.config.html) {
          if (!jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text(jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).text());
        }

        return;
      }

      if (this.config.html) {
        if (this.config.sanitize) {
          content = Object(_tools_sanitizer__WEBPACK_IMPORTED_MODULE_0__["sanitizeHtml"])(content, this.config.whiteList, this.config.sanitizeFn);
        }

        $element.html(content);
      } else {
        $element.text(content);
      }
    }
  }, {
    key: "getTitle",
    value: function getTitle() {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
      }

      return title;
    } // Private

  }, {
    key: "_getPopperConfig",
    value: function _getPopperConfig(attachment) {
      var _this3 = this;

      var defaultBsConfig = {
        placement: attachment,
        modifiers: {
          offset: this._getOffset(),
          flip: {
            behavior: this.config.fallbackPlacement
          },
          arrow: {
            element: SELECTOR_ARROW
          },
          preventOverflow: {
            boundariesElement: this.config.boundary
          }
        },
        onCreate: function onCreate(data) {
          if (data.originalPlacement !== data.placement) {
            _this3._handlePopperPlacementChange(data);
          }
        },
        onUpdate: function onUpdate(data) {
          return _this3._handlePopperPlacementChange(data);
        }
      };
      return _objectSpread(_objectSpread({}, defaultBsConfig), this.config.popperConfig);
    }
  }, {
    key: "_getOffset",
    value: function _getOffset() {
      var _this4 = this;

      var offset = {};

      if (typeof this.config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread(_objectSpread({}, data.offsets), _this4.config.offset(data.offsets, _this4.element) || {});
          return data;
        };
      } else {
        offset.offset = this.config.offset;
      }

      return offset;
    }
  }, {
    key: "_getContainer",
    value: function _getContainer() {
      if (this.config.container === false) {
        return document.body;
      }

      if (_util__WEBPACK_IMPORTED_MODULE_3__["default"].isElement(this.config.container)) {
        return jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.config.container);
      }

      return jquery__WEBPACK_IMPORTED_MODULE_1___default()(document).find(this.config.container);
    }
  }, {
    key: "_getAttachment",
    value: function _getAttachment(placement) {
      return AttachmentMap[placement.toUpperCase()];
    }
  }, {
    key: "_setListeners",
    value: function _setListeners() {
      var _this5 = this;

      var triggers = this.config.trigger.split(' ');
      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {
            return _this5.toggle(event);
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;
          var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(_this5.element).on(eventIn, _this5.config.selector, function (event) {
            return _this5._enter(event);
          }).on(eventOut, _this5.config.selector, function (event) {
            return _this5._leave(event);
          });
        }
      });

      this._hideModalHandler = function () {
        if (_this5.element) {
          _this5.hide();
        }
      };

      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);

      if (this.config.selector) {
        this.config = _objectSpread(_objectSpread({}, this.config), {}, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    }
  }, {
    key: "_fixTitle",
    value: function _fixTitle() {
      var titleType = _typeof(this.element.getAttribute('data-original-title'));

      if (this.element.getAttribute('title') || titleType !== 'string') {
        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
        this.element.setAttribute('title', '');
      }
    }
  }, {
    key: "_enter",
    value: function _enter(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
      }

      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(context.getTipElement()).hasClass(CLASS_NAME_SHOW) || context._hoverState === HOVER_STATE_SHOW) {
        context._hoverState = HOVER_STATE_SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HOVER_STATE_SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HOVER_STATE_SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    }
  }, {
    key: "_leave",
    value: function _leave(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HOVER_STATE_OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HOVER_STATE_OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    }
  }, {
    key: "_isWithActiveTrigger",
    value: function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      var dataAttributes = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).data();
      Object.keys(dataAttributes).forEach(function (dataAttr) {
        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
          delete dataAttributes[dataAttr];
        }
      });
      config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), dataAttributes), _typeof(config) === 'object' && config ? config : {});

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      _util__WEBPACK_IMPORTED_MODULE_3__["default"].typeCheckConfig(NAME, config, this.constructor.DefaultType);

      if (config.sanitize) {
        config.template = Object(_tools_sanitizer__WEBPACK_IMPORTED_MODULE_0__["sanitizeHtml"])(config.template, config.whiteList, config.sanitizeFn);
      }

      return config;
    }
  }, {
    key: "_getDelegateConfig",
    value: function _getDelegateConfig() {
      var config = {};

      if (this.config) {
        for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
            config[key] = this.config[key];
          }
        }
      }

      return config;
    }
  }, {
    key: "_cleanTipClass",
    value: function _cleanTipClass() {
      var $tip = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length) {
        $tip.removeClass(tabClass.join(''));
      }
    }
  }, {
    key: "_handlePopperPlacementChange",
    value: function _handlePopperPlacementChange(popperData) {
      this.tip = popperData.instance.popper;

      this._cleanTipClass();

      this.addAttachmentClass(this._getAttachment(popperData.placement));
    }
  }, {
    key: "_fixTransition",
    value: function _fixTransition() {
      var tip = this.getTipElement();
      var initConfigAnimation = this.config.animation;

      if (tip.getAttribute('x-placement') !== null) {
        return;
      }

      jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).removeClass(CLASS_NAME_FADE);
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = initConfigAnimation;
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "DATA_KEY",
    get: function get() {
      return DATA_KEY;
    }
  }, {
    key: "Event",
    get: function get() {
      return Event;
    }
  }, {
    key: "EVENT_KEY",
    get: function get() {
      return EVENT_KEY;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var $element = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this);
        var data = $element.data(DATA_KEY);

        var _config = _typeof(config) === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $element.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Tooltip;
}();
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */


jquery__WEBPACK_IMPORTED_MODULE_1___default.a.fn[NAME] = Tooltip._jQueryInterface;
jquery__WEBPACK_IMPORTED_MODULE_1___default.a.fn[NAME].Constructor = Tooltip;

jquery__WEBPACK_IMPORTED_MODULE_1___default.a.fn[NAME].noConflict = function () {
  jquery__WEBPACK_IMPORTED_MODULE_1___default.a.fn[NAME] = JQUERY_NO_CONFLICT;
  return Tooltip._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Tooltip);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/util.js":
/*!***********************************************!*\
  !*** ./node_modules/bootstrap/js/src/util.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.0): util.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * ------------------------------------------------------------------------
 * Private TransitionEnd Helpers
 * ------------------------------------------------------------------------
 */

var TRANSITION_END = 'transitionend';
var MAX_UID = 1000000;
var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

function toType(obj) {
  if (obj === null || typeof obj === 'undefined') {
    return "".concat(obj);
  }

  return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
}

function getSpecialTransitionEndEvent() {
  return {
    bindType: TRANSITION_END,
    delegateType: TRANSITION_END,
    handle: function handle(event) {
      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(event.target).is(this)) {
        return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
      }

      return undefined;
    }
  };
}

function transitionEndEmulator(duration) {
  var _this = this;

  var called = false;
  jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).one(Util.TRANSITION_END, function () {
    called = true;
  });
  setTimeout(function () {
    if (!called) {
      Util.triggerTransitionEnd(_this);
    }
  }, duration);
  return this;
}

function setTransitionEndSupport() {
  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn.emulateTransitionEnd = transitionEndEmulator;
  jquery__WEBPACK_IMPORTED_MODULE_0___default.a.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
}
/**
 * --------------------------------------------------------------------------
 * Public Util Api
 * --------------------------------------------------------------------------
 */


var Util = {
  TRANSITION_END: 'bsTransitionEnd',
  getUID: function getUID(prefix) {
    do {
      prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
    } while (document.getElementById(prefix));

    return prefix;
  },
  getSelectorFromElement: function getSelectorFromElement(element) {
    var selector = element.getAttribute('data-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href');
      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
    }

    try {
      return document.querySelector(selector) ? selector : null;
    } catch (_) {
      return null;
    }
  },
  getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    var transitionDuration = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('transition-duration');
    var transitionDelay = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('transition-delay');
    var floatTransitionDuration = parseFloat(transitionDuration);
    var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  },
  reflow: function reflow(element) {
    return element.offsetHeight;
  },
  triggerTransitionEnd: function triggerTransitionEnd(element) {
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).trigger(TRANSITION_END);
  },
  supportsTransitionEnd: function supportsTransitionEnd() {
    return Boolean(TRANSITION_END);
  },
  isElement: function isElement(obj) {
    return (obj[0] || obj).nodeType;
  },
  typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
    for (var property in configTypes) {
      if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
        var expectedTypes = configTypes[property];
        var value = config[property];
        var valueType = value && Util.isElement(value) ? 'element' : toType(value);

        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new Error("".concat(componentName.toUpperCase(), ": ") + "Option \"".concat(property, "\" provided type \"").concat(valueType, "\" ") + "but expected type \"".concat(expectedTypes, "\"."));
        }
      }
    }
  },
  findShadowRoot: function findShadowRoot(element) {
    if (!document.documentElement.attachShadow) {
      return null;
    } // Can find the shadow root otherwise it'll return the document


    if (typeof element.getRootNode === 'function') {
      var root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }

    if (element instanceof ShadowRoot) {
      return element;
    } // when we don't find a shadow root


    if (!element.parentNode) {
      return null;
    }

    return Util.findShadowRoot(element.parentNode);
  },
  jQueryDetection: function jQueryDetection() {
    if (typeof jquery__WEBPACK_IMPORTED_MODULE_0___default.a === 'undefined') {
      throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
    }

    var version = jquery__WEBPACK_IMPORTED_MODULE_0___default.a.fn.jquery.split(' ')[0].split('.');
    var minMajor = 1;
    var ltMajor = 2;
    var minMinor = 9;
    var minPatch = 1;
    var maxMajor = 4;

    if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
      throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
    }
  }
};
Util.jQueryDetection();
setTransitionEndSupport();
/* harmony default export */ __webpack_exports__["default"] = (Util);

/***/ }),

/***/ "./node_modules/jquery-highlight/jquery.highlight.js":
/*!***********************************************************!*\
  !*** ./node_modules/jquery-highlight/jquery.highlight.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * jQuery Highlight plugin
 *
 * Based on highlight v3 by Johann Burkard
 * http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
 *
 * Code a little bit refactored and cleaned (in my humble opinion).
 * Most important changes:
 *  - has an option to highlight only entire words (wordsOnly - false by default),
 *  - has an option to be case sensitive (caseSensitive - false by default)
 *  - highlight element tag and class names can be specified in options
 *
 * Usage:
 *   // wrap every occurrence of text 'lorem' in content
 *   // with <span class='highlight'> (default options)
 *   $('#content').highlight('lorem');
 *
 *   // search for and highlight more terms at once
 *   // so you can save some time on traversing DOM
 *   $('#content').highlight(['lorem', 'ipsum']);
 *   $('#content').highlight('lorem ipsum');
 *
 *   // search only for entire word 'lorem'
 *   $('#content').highlight('lorem', { wordsOnly: true });
 *
 *   // search only for the entire word 'C#'
 *   // and make sure that the word boundary can also
 *   // be a 'non-word' character, as well as a regex latin1 only boundary:
 *   $('#content').highlight('C#', { wordsOnly: true , wordsBoundary: '[\\b\\W]' });
 *
 *   // don't ignore case during search of term 'lorem'
 *   $('#content').highlight('lorem', { caseSensitive: true });
 *
 *   // wrap every occurrence of term 'ipsum' in content
 *   // with <em class='important'>
 *   $('#content').highlight('ipsum', { element: 'em', className: 'important' });
 *
 *   // remove default highlight
 *   $('#content').unhighlight();
 *
 *   // remove custom highlight
 *   $('#content').unhighlight({ element: 'em', className: 'important' });
 *
 *
 * Copyright (c) 2009 Bartek Szopka
 *
 * Licensed under MIT license.
 *
 */
(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "jquery")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function (jQuery) {
  jQuery.extend({
    highlight: function highlight(node, re, nodeName, className, callback, ignoreDiacritics) {
      if (node.nodeType === 3) {
        var subject = ignoreDiacritics ? jQuery.removeDiacritcs(node.data) : node.data;
        var match = subject.match(re);

        if (match) {
          // The new highlight Element Node
          var highlight = document.createElement(nodeName || 'span');
          highlight.className = className || 'highlight'; // Note that we use the captured value to find the real index
          // of the match. This is because we do not want to include the matching word boundaries

          var capturePos = node.data.indexOf(match[1], match.index); // Split the node and replace the matching wordnode
          // with the highlighted node

          var wordNode = node.splitText(capturePos);
          wordNode.splitText(match[1].length);
          var wordClone = wordNode.cloneNode(true);
          highlight.appendChild(wordClone);
          wordNode.parentNode.replaceChild(highlight, wordNode);

          if (typeof callback == 'function') {
            callback(highlight);
          }

          return 1; //skip added node in parent
        }
      } else if (node.nodeType === 1 && node.childNodes && // only element nodes that have children
      !/(script|style)/i.test(node.tagName) && // ignore script and style nodes
      !(node.tagName === nodeName.toUpperCase() && node.className === className)) {
        // skip if already highlighted
        for (var i = 0; i < node.childNodes.length; i++) {
          i += jQuery.highlight(node.childNodes[i], re, nodeName, className, callback, ignoreDiacritics);
        }
      }

      return 0;
    },
    removeDiacritcs: function removeDiacritcs(word) {
      return word.replace(/[\u00c0-\u00c6]/g, 'A').replace(/[\u00e0-\u00e6]/g, 'a').replace(/[\u00c7]/g, 'C').replace(/[\u00e7]/g, 'c').replace(/[\u00c8-\u00cb]/g, 'E').replace(/[\u00e8-\u00eb]/g, 'e').replace(/[\u00cc-\u00cf]/g, 'I').replace(/[\u00ec-\u00ef]/g, 'i').replace(/[\u00d1|\u0147]/g, 'N').replace(/[\u00f1|\u0148]/g, 'n').replace(/[\u00d2-\u00d8|\u0150]/g, 'O').replace(/[\u00f2-\u00f8|\u0151]/g, 'o').replace(/[\u0160]/g, 'S').replace(/[\u0161]/g, 's').replace(/[\u00d9-\u00dc]/g, 'U').replace(/[\u00f9-\u00fc]/g, 'u').replace(/[\u00dd]/g, 'Y').replace(/[\u00fd]/g, 'y');
    }
  });

  jQuery.fn.unhighlight = function (options) {
    var settings = {
      className: 'highlight',
      element: 'span'
    };
    jQuery.extend(settings, options);
    return this.find(settings.element + '.' + settings.className).each(function () {
      var parent = this.parentNode;
      parent.replaceChild(this.firstChild, this);
      parent.normalize();
    }).end();
  };

  jQuery.fn.highlight = function (words, options, callback) {
    var settings = {
      className: 'highlight',
      element: 'span',
      caseSensitive: false,
      wordsOnly: false,
      wordsBoundary: '\\b',
      ignoreDiacritics: false
    };
    jQuery.extend(settings, options);

    if (typeof words === 'string') {
      words = [words];
    }

    words = jQuery.grep(words, function (word) {
      return word != '';
    });
    words = jQuery.map(words, function (word) {
      if (settings.ignoreDiacritics) {
        word = jQuery.removeDiacritcs(word);
      }

      return word.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    });

    if (words.length === 0) {
      return this;
    }

    var flag = settings.caseSensitive ? '' : 'i'; // The capture parenthesis will make sure we can match
    // only the matching word

    var pattern = '(' + words.join('|') + ')';

    if (settings.wordsOnly) {
      pattern = (settings.wordsBoundaryStart || settings.wordsBoundary) + pattern + (settings.wordsBoundaryEnd || settings.wordsBoundary);
    }

    var re = new RegExp(pattern, flag);
    return this.each(function () {
      jQuery.highlight(this, re, settings.element, settings.className, callback, settings.ignoreDiacritics);
    });
  };
});

/***/ }),

/***/ "./node_modules/owl.carousel/dist/owl.carousel.js":
/*!********************************************************!*\
  !*** ./node_modules/owl.carousel/dist/owl.carousel.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Owl Carousel v2.3.4
 * Copyright 2013-2018 David Deutsch
 * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
 */

/**
 * Owl carousel
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 * @todo Lazy Load Icon
 * @todo prevent animationend bubling
 * @todo itemsScaleUp
 * @todo Test Zepto
 * @todo stagePadding calculate wrong active classes
 */
;

(function ($, window, document, undefined) {
  /**
   * Creates a carousel.
   * @class The Owl Carousel.
   * @public
   * @param {HTMLElement|jQuery} element - The element to create the carousel for.
   * @param {Object} [options] - The options
   */
  function Owl(element, options) {
    /**
     * Current settings for the carousel.
     * @public
     */
    this.settings = null;
    /**
     * Current options set by the caller including defaults.
     * @public
     */

    this.options = $.extend({}, Owl.Defaults, options);
    /**
     * Plugin element.
     * @public
     */

    this.$element = $(element);
    /**
     * Proxied event handlers.
     * @protected
     */

    this._handlers = {};
    /**
     * References to the running plugins of this carousel.
     * @protected
     */

    this._plugins = {};
    /**
     * Currently suppressed events to prevent them from being retriggered.
     * @protected
     */

    this._supress = {};
    /**
     * Absolute current position.
     * @protected
     */

    this._current = null;
    /**
     * Animation speed in milliseconds.
     * @protected
     */

    this._speed = null;
    /**
     * Coordinates of all items in pixel.
     * @todo The name of this member is missleading.
     * @protected
     */

    this._coordinates = [];
    /**
     * Current breakpoint.
     * @todo Real media queries would be nice.
     * @protected
     */

    this._breakpoint = null;
    /**
     * Current width of the plugin element.
     */

    this._width = null;
    /**
     * All real items.
     * @protected
     */

    this._items = [];
    /**
     * All cloned items.
     * @protected
     */

    this._clones = [];
    /**
     * Merge values of all items.
     * @todo Maybe this could be part of a plugin.
     * @protected
     */

    this._mergers = [];
    /**
     * Widths of all items.
     */

    this._widths = [];
    /**
     * Invalidated parts within the update process.
     * @protected
     */

    this._invalidated = {};
    /**
     * Ordered list of workers for the update process.
     * @protected
     */

    this._pipe = [];
    /**
     * Current state information for the drag operation.
     * @todo #261
     * @protected
     */

    this._drag = {
      time: null,
      target: null,
      pointer: null,
      stage: {
        start: null,
        current: null
      },
      direction: null
    };
    /**
     * Current state information and their tags.
     * @type {Object}
     * @protected
     */

    this._states = {
      current: {},
      tags: {
        'initializing': ['busy'],
        'animating': ['busy'],
        'dragging': ['interacting']
      }
    };
    $.each(['onResize', 'onThrottledResize'], $.proxy(function (i, handler) {
      this._handlers[handler] = $.proxy(this[handler], this);
    }, this));
    $.each(Owl.Plugins, $.proxy(function (key, plugin) {
      this._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin(this);
    }, this));
    $.each(Owl.Workers, $.proxy(function (priority, worker) {
      this._pipe.push({
        'filter': worker.filter,
        'run': $.proxy(worker.run, this)
      });
    }, this));
    this.setup();
    this.initialize();
  }
  /**
   * Default options for the carousel.
   * @public
   */


  Owl.Defaults = {
    items: 3,
    loop: false,
    center: false,
    rewind: false,
    checkVisibility: true,
    mouseDrag: true,
    touchDrag: true,
    pullDrag: true,
    freeDrag: false,
    margin: 0,
    stagePadding: 0,
    merge: false,
    mergeFit: true,
    autoWidth: false,
    startPosition: 0,
    rtl: false,
    smartSpeed: 250,
    fluidSpeed: false,
    dragEndSpeed: false,
    responsive: {},
    responsiveRefreshRate: 200,
    responsiveBaseElement: window,
    fallbackEasing: 'swing',
    slideTransition: '',
    info: false,
    nestedItemSelector: false,
    itemElement: 'div',
    stageElement: 'div',
    refreshClass: 'owl-refresh',
    loadedClass: 'owl-loaded',
    loadingClass: 'owl-loading',
    rtlClass: 'owl-rtl',
    responsiveClass: 'owl-responsive',
    dragClass: 'owl-drag',
    itemClass: 'owl-item',
    stageClass: 'owl-stage',
    stageOuterClass: 'owl-stage-outer',
    grabClass: 'owl-grab'
  };
  /**
   * Enumeration for width.
   * @public
   * @readonly
   * @enum {String}
   */

  Owl.Width = {
    Default: 'default',
    Inner: 'inner',
    Outer: 'outer'
  };
  /**
   * Enumeration for types.
   * @public
   * @readonly
   * @enum {String}
   */

  Owl.Type = {
    Event: 'event',
    State: 'state'
  };
  /**
   * Contains all registered plugins.
   * @public
   */

  Owl.Plugins = {};
  /**
   * List of workers involved in the update process.
   */

  Owl.Workers = [{
    filter: ['width', 'settings'],
    run: function run() {
      this._width = this.$element.width();
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      cache.current = this._items && this._items[this.relative(this._current)];
    }
  }, {
    filter: ['items', 'settings'],
    run: function run() {
      this.$stage.children('.cloned').remove();
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      var margin = this.settings.margin || '',
          grid = !this.settings.autoWidth,
          rtl = this.settings.rtl,
          css = {
        'width': 'auto',
        'margin-left': rtl ? margin : '',
        'margin-right': rtl ? '' : margin
      };
      !grid && this.$stage.children().css(css);
      cache.css = css;
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
          merge = null,
          iterator = this._items.length,
          grid = !this.settings.autoWidth,
          widths = [];
      cache.items = {
        merge: false,
        width: width
      };

      while (iterator--) {
        merge = this._mergers[iterator];
        merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;
        cache.items.merge = merge > 1 || cache.items.merge;
        widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
      }

      this._widths = widths;
    }
  }, {
    filter: ['items', 'settings'],
    run: function run() {
      var clones = [],
          items = this._items,
          settings = this.settings,
          // TODO: Should be computed from number of min width items in stage
      view = Math.max(settings.items * 2, 4),
          size = Math.ceil(items.length / 2) * 2,
          repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
          append = '',
          prepend = '';
      repeat /= 2;

      while (repeat > 0) {
        // Switch to only using appended clones
        clones.push(this.normalize(clones.length / 2, true));
        append = append + items[clones[clones.length - 1]][0].outerHTML;
        clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
        prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
        repeat -= 1;
      }

      this._clones = clones;
      $(append).addClass('cloned').appendTo(this.$stage);
      $(prepend).addClass('cloned').prependTo(this.$stage);
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run() {
      var rtl = this.settings.rtl ? 1 : -1,
          size = this._clones.length + this._items.length,
          iterator = -1,
          previous = 0,
          current = 0,
          coordinates = [];

      while (++iterator < size) {
        previous = coordinates[iterator - 1] || 0;
        current = this._widths[this.relative(iterator)] + this.settings.margin;
        coordinates.push(previous + current * rtl);
      }

      this._coordinates = coordinates;
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run() {
      var padding = this.settings.stagePadding,
          coordinates = this._coordinates,
          css = {
        'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
        'padding-left': padding || '',
        'padding-right': padding || ''
      };
      this.$stage.css(css);
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      var iterator = this._coordinates.length,
          grid = !this.settings.autoWidth,
          items = this.$stage.children();

      if (grid && cache.items.merge) {
        while (iterator--) {
          cache.css.width = this._widths[this.relative(iterator)];
          items.eq(iterator).css(cache.css);
        }
      } else if (grid) {
        cache.css.width = cache.items.width;
        items.css(cache.css);
      }
    }
  }, {
    filter: ['items'],
    run: function run() {
      this._coordinates.length < 1 && this.$stage.removeAttr('style');
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
      cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
      this.reset(cache.current);
    }
  }, {
    filter: ['position'],
    run: function run() {
      this.animate(this.coordinates(this._current));
    }
  }, {
    filter: ['width', 'position', 'items', 'settings'],
    run: function run() {
      var rtl = this.settings.rtl ? 1 : -1,
          padding = this.settings.stagePadding * 2,
          begin = this.coordinates(this.current()) + padding,
          end = begin + this.width() * rtl,
          inner,
          outer,
          matches = [],
          i,
          n;

      for (i = 0, n = this._coordinates.length; i < n; i++) {
        inner = this._coordinates[i - 1] || 0;
        outer = Math.abs(this._coordinates[i]) + padding * rtl;

        if (this.op(inner, '<=', begin) && this.op(inner, '>', end) || this.op(outer, '<', begin) && this.op(outer, '>', end)) {
          matches.push(i);
        }
      }

      this.$stage.children('.active').removeClass('active');
      this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');
      this.$stage.children('.center').removeClass('center');

      if (this.settings.center) {
        this.$stage.children().eq(this.current()).addClass('center');
      }
    }
  }];
  /**
   * Create the stage DOM element
   */

  Owl.prototype.initializeStage = function () {
    this.$stage = this.$element.find('.' + this.settings.stageClass); // if the stage is already in the DOM, grab it and skip stage initialization

    if (this.$stage.length) {
      return;
    }

    this.$element.addClass(this.options.loadingClass); // create stage

    this.$stage = $('<' + this.settings.stageElement + '>', {
      "class": this.settings.stageClass
    }).wrap($('<div/>', {
      "class": this.settings.stageOuterClass
    })); // append stage

    this.$element.append(this.$stage.parent());
  };
  /**
   * Create item DOM elements
   */


  Owl.prototype.initializeItems = function () {
    var $items = this.$element.find('.owl-item'); // if the items are already in the DOM, grab them and skip item initialization

    if ($items.length) {
      this._items = $items.get().map(function (item) {
        return $(item);
      });
      this._mergers = this._items.map(function () {
        return 1;
      });
      this.refresh();
      return;
    } // append content


    this.replace(this.$element.children().not(this.$stage.parent())); // check visibility

    if (this.isVisible()) {
      // update view
      this.refresh();
    } else {
      // invalidate width
      this.invalidate('width');
    }

    this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass);
  };
  /**
   * Initializes the carousel.
   * @protected
   */


  Owl.prototype.initialize = function () {
    this.enter('initializing');
    this.trigger('initialize');
    this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

    if (this.settings.autoWidth && !this.is('pre-loading')) {
      var imgs, nestedSelector, width;
      imgs = this.$element.find('img');
      nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
      width = this.$element.children(nestedSelector).width();

      if (imgs.length && width <= 0) {
        this.preloadAutoWidthImages(imgs);
      }
    }

    this.initializeStage();
    this.initializeItems(); // register event handlers

    this.registerEventHandlers();
    this.leave('initializing');
    this.trigger('initialized');
  };
  /**
   * @returns {Boolean} visibility of $element
   *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to
   *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does
   */


  Owl.prototype.isVisible = function () {
    return this.settings.checkVisibility ? this.$element.is(':visible') : true;
  };
  /**
   * Setups the current settings.
   * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
   * @todo Support for media queries by using `matchMedia` would be nice.
   * @public
   */


  Owl.prototype.setup = function () {
    var viewport = this.viewport(),
        overwrites = this.options.responsive,
        match = -1,
        settings = null;

    if (!overwrites) {
      settings = $.extend({}, this.options);
    } else {
      $.each(overwrites, function (breakpoint) {
        if (breakpoint <= viewport && breakpoint > match) {
          match = Number(breakpoint);
        }
      });
      settings = $.extend({}, this.options, overwrites[match]);

      if (typeof settings.stagePadding === 'function') {
        settings.stagePadding = settings.stagePadding();
      }

      delete settings.responsive; // responsive class

      if (settings.responsiveClass) {
        this.$element.attr('class', this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match));
      }
    }

    this.trigger('change', {
      property: {
        name: 'settings',
        value: settings
      }
    });
    this._breakpoint = match;
    this.settings = settings;
    this.invalidate('settings');
    this.trigger('changed', {
      property: {
        name: 'settings',
        value: this.settings
      }
    });
  };
  /**
   * Updates option logic if necessery.
   * @protected
   */


  Owl.prototype.optionsLogic = function () {
    if (this.settings.autoWidth) {
      this.settings.stagePadding = false;
      this.settings.merge = false;
    }
  };
  /**
   * Prepares an item before add.
   * @todo Rename event parameter `content` to `item`.
   * @protected
   * @returns {jQuery|HTMLElement} - The item container.
   */


  Owl.prototype.prepare = function (item) {
    var event = this.trigger('prepare', {
      content: item
    });

    if (!event.data) {
      event.data = $('<' + this.settings.itemElement + '/>').addClass(this.options.itemClass).append(item);
    }

    this.trigger('prepared', {
      content: event.data
    });
    return event.data;
  };
  /**
   * Updates the view.
   * @public
   */


  Owl.prototype.update = function () {
    var i = 0,
        n = this._pipe.length,
        filter = $.proxy(function (p) {
      return this[p];
    }, this._invalidated),
        cache = {};

    while (i < n) {
      if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
        this._pipe[i].run(cache);
      }

      i++;
    }

    this._invalidated = {};
    !this.is('valid') && this.enter('valid');
  };
  /**
   * Gets the width of the view.
   * @public
   * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
   * @returns {Number} - The width of the view in pixel.
   */


  Owl.prototype.width = function (dimension) {
    dimension = dimension || Owl.Width.Default;

    switch (dimension) {
      case Owl.Width.Inner:
      case Owl.Width.Outer:
        return this._width;

      default:
        return this._width - this.settings.stagePadding * 2 + this.settings.margin;
    }
  };
  /**
   * Refreshes the carousel primarily for adaptive purposes.
   * @public
   */


  Owl.prototype.refresh = function () {
    this.enter('refreshing');
    this.trigger('refresh');
    this.setup();
    this.optionsLogic();
    this.$element.addClass(this.options.refreshClass);
    this.update();
    this.$element.removeClass(this.options.refreshClass);
    this.leave('refreshing');
    this.trigger('refreshed');
  };
  /**
   * Checks window `resize` event.
   * @protected
   */


  Owl.prototype.onThrottledResize = function () {
    window.clearTimeout(this.resizeTimer);
    this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
  };
  /**
   * Checks window `resize` event.
   * @protected
   */


  Owl.prototype.onResize = function () {
    if (!this._items.length) {
      return false;
    }

    if (this._width === this.$element.width()) {
      return false;
    }

    if (!this.isVisible()) {
      return false;
    }

    this.enter('resizing');

    if (this.trigger('resize').isDefaultPrevented()) {
      this.leave('resizing');
      return false;
    }

    this.invalidate('width');
    this.refresh();
    this.leave('resizing');
    this.trigger('resized');
  };
  /**
   * Registers event handlers.
   * @todo Check `msPointerEnabled`
   * @todo #261
   * @protected
   */


  Owl.prototype.registerEventHandlers = function () {
    if ($.support.transition) {
      this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
    }

    if (this.settings.responsive !== false) {
      this.on(window, 'resize', this._handlers.onThrottledResize);
    }

    if (this.settings.mouseDrag) {
      this.$element.addClass(this.options.dragClass);
      this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
      this.$stage.on('dragstart.owl.core selectstart.owl.core', function () {
        return false;
      });
    }

    if (this.settings.touchDrag) {
      this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
      this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
    }
  };
  /**
   * Handles `touchstart` and `mousedown` events.
   * @todo Horizontal swipe threshold as option
   * @todo #261
   * @protected
   * @param {Event} event - The event arguments.
   */


  Owl.prototype.onDragStart = function (event) {
    var stage = null;

    if (event.which === 3) {
      return;
    }

    if ($.support.transform) {
      stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
      stage = {
        x: stage[stage.length === 16 ? 12 : 4],
        y: stage[stage.length === 16 ? 13 : 5]
      };
    } else {
      stage = this.$stage.position();
      stage = {
        x: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,
        y: stage.top
      };
    }

    if (this.is('animating')) {
      $.support.transform ? this.animate(stage.x) : this.$stage.stop();
      this.invalidate('position');
    }

    this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');
    this.speed(0);
    this._drag.time = new Date().getTime();
    this._drag.target = $(event.target);
    this._drag.stage.start = stage;
    this._drag.stage.current = stage;
    this._drag.pointer = this.pointer(event);
    $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));
    $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function (event) {
      var delta = this.difference(this._drag.pointer, this.pointer(event));
      $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

      if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
        return;
      }

      event.preventDefault();
      this.enter('dragging');
      this.trigger('drag');
    }, this));
  };
  /**
   * Handles the `touchmove` and `mousemove` events.
   * @todo #261
   * @protected
   * @param {Event} event - The event arguments.
   */


  Owl.prototype.onDragMove = function (event) {
    var minimum = null,
        maximum = null,
        pull = null,
        delta = this.difference(this._drag.pointer, this.pointer(event)),
        stage = this.difference(this._drag.stage.start, delta);

    if (!this.is('dragging')) {
      return;
    }

    event.preventDefault();

    if (this.settings.loop) {
      minimum = this.coordinates(this.minimum());
      maximum = this.coordinates(this.maximum() + 1) - minimum;
      stage.x = ((stage.x - minimum) % maximum + maximum) % maximum + minimum;
    } else {
      minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
      maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
      pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
      stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
    }

    this._drag.stage.current = stage;
    this.animate(stage.x);
  };
  /**
   * Handles the `touchend` and `mouseup` events.
   * @todo #261
   * @todo Threshold for click event
   * @protected
   * @param {Event} event - The event arguments.
   */


  Owl.prototype.onDragEnd = function (event) {
    var delta = this.difference(this._drag.pointer, this.pointer(event)),
        stage = this._drag.stage.current,
        direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';
    $(document).off('.owl.core');
    this.$element.removeClass(this.options.grabClass);

    if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
      this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
      this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
      this.invalidate('position');
      this.update();
      this._drag.direction = direction;

      if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
        this._drag.target.one('click.owl.core', function () {
          return false;
        });
      }
    }

    if (!this.is('dragging')) {
      return;
    }

    this.leave('dragging');
    this.trigger('dragged');
  };
  /**
   * Gets absolute position of the closest item for a coordinate.
   * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
   * @protected
   * @param {Number} coordinate - The coordinate in pixel.
   * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
   * @return {Number} - The absolute position of the closest item.
   */


  Owl.prototype.closest = function (coordinate, direction) {
    var position = -1,
        pull = 30,
        width = this.width(),
        coordinates = this.coordinates();

    if (!this.settings.freeDrag) {
      // check closest item
      $.each(coordinates, $.proxy(function (index, value) {
        // on a left pull, check on current index
        if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
          position = index; // on a right pull, check on previous index
          // to do so, subtract width from value and set position = index + 1
        } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
          position = index + 1;
        } else if (this.op(coordinate, '<', value) && this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {
          position = direction === 'left' ? index + 1 : index;
        }

        return position === -1;
      }, this));
    }

    if (!this.settings.loop) {
      // non loop boundries
      if (this.op(coordinate, '>', coordinates[this.minimum()])) {
        position = coordinate = this.minimum();
      } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
        position = coordinate = this.maximum();
      }
    }

    return position;
  };
  /**
   * Animates the stage.
   * @todo #270
   * @public
   * @param {Number} coordinate - The coordinate in pixels.
   */


  Owl.prototype.animate = function (coordinate) {
    var animate = this.speed() > 0;
    this.is('animating') && this.onTransitionEnd();

    if (animate) {
      this.enter('animating');
      this.trigger('translate');
    }

    if ($.support.transform3d && $.support.transition) {
      this.$stage.css({
        transform: 'translate3d(' + coordinate + 'px,0px,0px)',
        transition: this.speed() / 1000 + 's' + (this.settings.slideTransition ? ' ' + this.settings.slideTransition : '')
      });
    } else if (animate) {
      this.$stage.animate({
        left: coordinate + 'px'
      }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
    } else {
      this.$stage.css({
        left: coordinate + 'px'
      });
    }
  };
  /**
   * Checks whether the carousel is in a specific state or not.
   * @param {String} state - The state to check.
   * @returns {Boolean} - The flag which indicates if the carousel is busy.
   */


  Owl.prototype.is = function (state) {
    return this._states.current[state] && this._states.current[state] > 0;
  };
  /**
   * Sets the absolute position of the current item.
   * @public
   * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
   * @returns {Number} - The absolute position of the current item.
   */


  Owl.prototype.current = function (position) {
    if (position === undefined) {
      return this._current;
    }

    if (this._items.length === 0) {
      return undefined;
    }

    position = this.normalize(position);

    if (this._current !== position) {
      var event = this.trigger('change', {
        property: {
          name: 'position',
          value: position
        }
      });

      if (event.data !== undefined) {
        position = this.normalize(event.data);
      }

      this._current = position;
      this.invalidate('position');
      this.trigger('changed', {
        property: {
          name: 'position',
          value: this._current
        }
      });
    }

    return this._current;
  };
  /**
   * Invalidates the given part of the update routine.
   * @param {String} [part] - The part to invalidate.
   * @returns {Array.<String>} - The invalidated parts.
   */


  Owl.prototype.invalidate = function (part) {
    if ($.type(part) === 'string') {
      this._invalidated[part] = true;
      this.is('valid') && this.leave('valid');
    }

    return $.map(this._invalidated, function (v, i) {
      return i;
    });
  };
  /**
   * Resets the absolute position of the current item.
   * @public
   * @param {Number} position - The absolute position of the new item.
   */


  Owl.prototype.reset = function (position) {
    position = this.normalize(position);

    if (position === undefined) {
      return;
    }

    this._speed = 0;
    this._current = position;
    this.suppress(['translate', 'translated']);
    this.animate(this.coordinates(position));
    this.release(['translate', 'translated']);
  };
  /**
   * Normalizes an absolute or a relative position of an item.
   * @public
   * @param {Number} position - The absolute or relative position to normalize.
   * @param {Boolean} [relative=false] - Whether the given position is relative or not.
   * @returns {Number} - The normalized position.
   */


  Owl.prototype.normalize = function (position, relative) {
    var n = this._items.length,
        m = relative ? 0 : this._clones.length;

    if (!this.isNumeric(position) || n < 1) {
      position = undefined;
    } else if (position < 0 || position >= n + m) {
      position = ((position - m / 2) % n + n) % n + m / 2;
    }

    return position;
  };
  /**
   * Converts an absolute position of an item into a relative one.
   * @public
   * @param {Number} position - The absolute position to convert.
   * @returns {Number} - The converted position.
   */


  Owl.prototype.relative = function (position) {
    position -= this._clones.length / 2;
    return this.normalize(position, true);
  };
  /**
   * Gets the maximum position for the current item.
   * @public
   * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
   * @returns {Number}
   */


  Owl.prototype.maximum = function (relative) {
    var settings = this.settings,
        maximum = this._coordinates.length,
        iterator,
        reciprocalItemsWidth,
        elementWidth;

    if (settings.loop) {
      maximum = this._clones.length / 2 + this._items.length - 1;
    } else if (settings.autoWidth || settings.merge) {
      iterator = this._items.length;

      if (iterator) {
        reciprocalItemsWidth = this._items[--iterator].width();
        elementWidth = this.$element.width();

        while (iterator--) {
          reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;

          if (reciprocalItemsWidth > elementWidth) {
            break;
          }
        }
      }

      maximum = iterator + 1;
    } else if (settings.center) {
      maximum = this._items.length - 1;
    } else {
      maximum = this._items.length - settings.items;
    }

    if (relative) {
      maximum -= this._clones.length / 2;
    }

    return Math.max(maximum, 0);
  };
  /**
   * Gets the minimum position for the current item.
   * @public
   * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
   * @returns {Number}
   */


  Owl.prototype.minimum = function (relative) {
    return relative ? 0 : this._clones.length / 2;
  };
  /**
   * Gets an item at the specified relative position.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
   */


  Owl.prototype.items = function (position) {
    if (position === undefined) {
      return this._items.slice();
    }

    position = this.normalize(position, true);
    return this._items[position];
  };
  /**
   * Gets an item at the specified relative position.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
   */


  Owl.prototype.mergers = function (position) {
    if (position === undefined) {
      return this._mergers.slice();
    }

    position = this.normalize(position, true);
    return this._mergers[position];
  };
  /**
   * Gets the absolute positions of clones for an item.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
   */


  Owl.prototype.clones = function (position) {
    var odd = this._clones.length / 2,
        even = odd + this._items.length,
        map = function map(index) {
      return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2;
    };

    if (position === undefined) {
      return $.map(this._clones, function (v, i) {
        return map(i);
      });
    }

    return $.map(this._clones, function (v, i) {
      return v === position ? map(i) : null;
    });
  };
  /**
   * Sets the current animation speed.
   * @public
   * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
   * @returns {Number} - The current animation speed in milliseconds.
   */


  Owl.prototype.speed = function (speed) {
    if (speed !== undefined) {
      this._speed = speed;
    }

    return this._speed;
  };
  /**
   * Gets the coordinate of an item.
   * @todo The name of this method is missleanding.
   * @public
   * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
   * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
   */


  Owl.prototype.coordinates = function (position) {
    var multiplier = 1,
        newPosition = position - 1,
        coordinate;

    if (position === undefined) {
      return $.map(this._coordinates, $.proxy(function (coordinate, index) {
        return this.coordinates(index);
      }, this));
    }

    if (this.settings.center) {
      if (this.settings.rtl) {
        multiplier = -1;
        newPosition = position + 1;
      }

      coordinate = this._coordinates[position];
      coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
    } else {
      coordinate = this._coordinates[newPosition] || 0;
    }

    coordinate = Math.ceil(coordinate);
    return coordinate;
  };
  /**
   * Calculates the speed for a translation.
   * @protected
   * @param {Number} from - The absolute position of the start item.
   * @param {Number} to - The absolute position of the target item.
   * @param {Number} [factor=undefined] - The time factor in milliseconds.
   * @returns {Number} - The time in milliseconds for the translation.
   */


  Owl.prototype.duration = function (from, to, factor) {
    if (factor === 0) {
      return 0;
    }

    return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs(factor || this.settings.smartSpeed);
  };
  /**
   * Slides to the specified item.
   * @public
   * @param {Number} position - The position of the item.
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */


  Owl.prototype.to = function (position, speed) {
    var current = this.current(),
        revert = null,
        distance = position - this.relative(current),
        direction = (distance > 0) - (distance < 0),
        items = this._items.length,
        minimum = this.minimum(),
        maximum = this.maximum();

    if (this.settings.loop) {
      if (!this.settings.rewind && Math.abs(distance) > items / 2) {
        distance += direction * -1 * items;
      }

      position = current + distance;
      revert = ((position - minimum) % items + items) % items + minimum;

      if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
        current = revert - distance;
        position = revert;
        this.reset(current);
      }
    } else if (this.settings.rewind) {
      maximum += 1;
      position = (position % maximum + maximum) % maximum;
    } else {
      position = Math.max(minimum, Math.min(maximum, position));
    }

    this.speed(this.duration(current, position, speed));
    this.current(position);

    if (this.isVisible()) {
      this.update();
    }
  };
  /**
   * Slides to the next item.
   * @public
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */


  Owl.prototype.next = function (speed) {
    speed = speed || false;
    this.to(this.relative(this.current()) + 1, speed);
  };
  /**
   * Slides to the previous item.
   * @public
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */


  Owl.prototype.prev = function (speed) {
    speed = speed || false;
    this.to(this.relative(this.current()) - 1, speed);
  };
  /**
   * Handles the end of an animation.
   * @protected
   * @param {Event} event - The event arguments.
   */


  Owl.prototype.onTransitionEnd = function (event) {
    // if css2 animation then event object is undefined
    if (event !== undefined) {
      event.stopPropagation(); // Catch only owl-stage transitionEnd event

      if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
        return false;
      }
    }

    this.leave('animating');
    this.trigger('translated');
  };
  /**
   * Gets viewport width.
   * @protected
   * @return {Number} - The width in pixel.
   */


  Owl.prototype.viewport = function () {
    var width;

    if (this.options.responsiveBaseElement !== window) {
      width = $(this.options.responsiveBaseElement).width();
    } else if (window.innerWidth) {
      width = window.innerWidth;
    } else if (document.documentElement && document.documentElement.clientWidth) {
      width = document.documentElement.clientWidth;
    } else {
      console.warn('Can not detect viewport width.');
    }

    return width;
  };
  /**
   * Replaces the current content.
   * @public
   * @param {HTMLElement|jQuery|String} content - The new content.
   */


  Owl.prototype.replace = function (content) {
    this.$stage.empty();
    this._items = [];

    if (content) {
      content = content instanceof jQuery ? content : $(content);
    }

    if (this.settings.nestedItemSelector) {
      content = content.find('.' + this.settings.nestedItemSelector);
    }

    content.filter(function () {
      return this.nodeType === 1;
    }).each($.proxy(function (index, item) {
      item = this.prepare(item);
      this.$stage.append(item);

      this._items.push(item);

      this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
    }, this));
    this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);
    this.invalidate('items');
  };
  /**
   * Adds an item.
   * @todo Use `item` instead of `content` for the event arguments.
   * @public
   * @param {HTMLElement|jQuery|String} content - The item content to add.
   * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
   */


  Owl.prototype.add = function (content, position) {
    var current = this.relative(this._current);
    position = position === undefined ? this._items.length : this.normalize(position, true);
    content = content instanceof jQuery ? content : $(content);
    this.trigger('add', {
      content: content,
      position: position
    });
    content = this.prepare(content);

    if (this._items.length === 0 || position === this._items.length) {
      this._items.length === 0 && this.$stage.append(content);
      this._items.length !== 0 && this._items[position - 1].after(content);

      this._items.push(content);

      this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
    } else {
      this._items[position].before(content);

      this._items.splice(position, 0, content);

      this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
    }

    this._items[current] && this.reset(this._items[current].index());
    this.invalidate('items');
    this.trigger('added', {
      content: content,
      position: position
    });
  };
  /**
   * Removes an item by its position.
   * @todo Use `item` instead of `content` for the event arguments.
   * @public
   * @param {Number} position - The relative position of the item to remove.
   */


  Owl.prototype.remove = function (position) {
    position = this.normalize(position, true);

    if (position === undefined) {
      return;
    }

    this.trigger('remove', {
      content: this._items[position],
      position: position
    });

    this._items[position].remove();

    this._items.splice(position, 1);

    this._mergers.splice(position, 1);

    this.invalidate('items');
    this.trigger('removed', {
      content: null,
      position: position
    });
  };
  /**
   * Preloads images with auto width.
   * @todo Replace by a more generic approach
   * @protected
   */


  Owl.prototype.preloadAutoWidthImages = function (images) {
    images.each($.proxy(function (i, element) {
      this.enter('pre-loading');
      element = $(element);
      $(new Image()).one('load', $.proxy(function (e) {
        element.attr('src', e.target.src);
        element.css('opacity', 1);
        this.leave('pre-loading');
        !this.is('pre-loading') && !this.is('initializing') && this.refresh();
      }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
    }, this));
  };
  /**
   * Destroys the carousel.
   * @public
   */


  Owl.prototype.destroy = function () {
    this.$element.off('.owl.core');
    this.$stage.off('.owl.core');
    $(document).off('.owl.core');

    if (this.settings.responsive !== false) {
      window.clearTimeout(this.resizeTimer);
      this.off(window, 'resize', this._handlers.onThrottledResize);
    }

    for (var i in this._plugins) {
      this._plugins[i].destroy();
    }

    this.$stage.children('.cloned').remove();
    this.$stage.unwrap();
    this.$stage.children().contents().unwrap();
    this.$stage.children().unwrap();
    this.$stage.remove();
    this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), '')).removeData('owl.carousel');
  };
  /**
   * Operators to calculate right-to-left and left-to-right.
   * @protected
   * @param {Number} [a] - The left side operand.
   * @param {String} [o] - The operator.
   * @param {Number} [b] - The right side operand.
   */


  Owl.prototype.op = function (a, o, b) {
    var rtl = this.settings.rtl;

    switch (o) {
      case '<':
        return rtl ? a > b : a < b;

      case '>':
        return rtl ? a < b : a > b;

      case '>=':
        return rtl ? a <= b : a >= b;

      case '<=':
        return rtl ? a >= b : a <= b;

      default:
        break;
    }
  };
  /**
   * Attaches to an internal event.
   * @protected
   * @param {HTMLElement} element - The event source.
   * @param {String} event - The event name.
   * @param {Function} listener - The event handler to attach.
   * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
   */


  Owl.prototype.on = function (element, event, listener, capture) {
    if (element.addEventListener) {
      element.addEventListener(event, listener, capture);
    } else if (element.attachEvent) {
      element.attachEvent('on' + event, listener);
    }
  };
  /**
   * Detaches from an internal event.
   * @protected
   * @param {HTMLElement} element - The event source.
   * @param {String} event - The event name.
   * @param {Function} listener - The attached event handler to detach.
   * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
   */


  Owl.prototype.off = function (element, event, listener, capture) {
    if (element.removeEventListener) {
      element.removeEventListener(event, listener, capture);
    } else if (element.detachEvent) {
      element.detachEvent('on' + event, listener);
    }
  };
  /**
   * Triggers a public event.
   * @todo Remove `status`, `relatedTarget` should be used instead.
   * @protected
   * @param {String} name - The event name.
   * @param {*} [data=null] - The event data.
   * @param {String} [namespace=carousel] - The event namespace.
   * @param {String} [state] - The state which is associated with the event.
   * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
   * @returns {Event} - The event arguments.
   */


  Owl.prototype.trigger = function (name, data, namespace, state, enter) {
    var status = {
      item: {
        count: this._items.length,
        index: this.current()
      }
    },
        handler = $.camelCase($.grep(['on', name, namespace], function (v) {
      return v;
    }).join('-').toLowerCase()),
        event = $.Event([name, 'owl', namespace || 'carousel'].join('.').toLowerCase(), $.extend({
      relatedTarget: this
    }, status, data));

    if (!this._supress[name]) {
      $.each(this._plugins, function (name, plugin) {
        if (plugin.onTrigger) {
          plugin.onTrigger(event);
        }
      });
      this.register({
        type: Owl.Type.Event,
        name: name
      });
      this.$element.trigger(event);

      if (this.settings && typeof this.settings[handler] === 'function') {
        this.settings[handler].call(this, event);
      }
    }

    return event;
  };
  /**
   * Enters a state.
   * @param name - The state name.
   */


  Owl.prototype.enter = function (name) {
    $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
      if (this._states.current[name] === undefined) {
        this._states.current[name] = 0;
      }

      this._states.current[name]++;
    }, this));
  };
  /**
   * Leaves a state.
   * @param name - The state name.
   */


  Owl.prototype.leave = function (name) {
    $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
      this._states.current[name]--;
    }, this));
  };
  /**
   * Registers an event or state.
   * @public
   * @param {Object} object - The event or state to register.
   */


  Owl.prototype.register = function (object) {
    if (object.type === Owl.Type.Event) {
      if (!$.event.special[object.name]) {
        $.event.special[object.name] = {};
      }

      if (!$.event.special[object.name].owl) {
        var _default = $.event.special[object.name]._default;

        $.event.special[object.name]._default = function (e) {
          if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
            return _default.apply(this, arguments);
          }

          return e.namespace && e.namespace.indexOf('owl') > -1;
        };

        $.event.special[object.name].owl = true;
      }
    } else if (object.type === Owl.Type.State) {
      if (!this._states.tags[object.name]) {
        this._states.tags[object.name] = object.tags;
      } else {
        this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
      }

      this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {
        return $.inArray(tag, this._states.tags[object.name]) === i;
      }, this));
    }
  };
  /**
   * Suppresses events.
   * @protected
   * @param {Array.<String>} events - The events to suppress.
   */


  Owl.prototype.suppress = function (events) {
    $.each(events, $.proxy(function (index, event) {
      this._supress[event] = true;
    }, this));
  };
  /**
   * Releases suppressed events.
   * @protected
   * @param {Array.<String>} events - The events to release.
   */


  Owl.prototype.release = function (events) {
    $.each(events, $.proxy(function (index, event) {
      delete this._supress[event];
    }, this));
  };
  /**
   * Gets unified pointer coordinates from event.
   * @todo #261
   * @protected
   * @param {Event} - The `mousedown` or `touchstart` event.
   * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
   */


  Owl.prototype.pointer = function (event) {
    var result = {
      x: null,
      y: null
    };
    event = event.originalEvent || event || window.event;
    event = event.touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event;

    if (event.pageX) {
      result.x = event.pageX;
      result.y = event.pageY;
    } else {
      result.x = event.clientX;
      result.y = event.clientY;
    }

    return result;
  };
  /**
   * Determines if the input is a Number or something that can be coerced to a Number
   * @protected
   * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
   * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
   */


  Owl.prototype.isNumeric = function (number) {
    return !isNaN(parseFloat(number));
  };
  /**
   * Gets the difference of two vectors.
   * @todo #261
   * @protected
   * @param {Object} - The first vector.
   * @param {Object} - The second vector.
   * @returns {Object} - The difference.
   */


  Owl.prototype.difference = function (first, second) {
    return {
      x: first.x - second.x,
      y: first.y - second.y
    };
  };
  /**
   * The jQuery Plugin for the Owl Carousel
   * @todo Navigation plugin `next` and `prev`
   * @public
   */


  $.fn.owlCarousel = function (option) {
    var args = Array.prototype.slice.call(arguments, 1);
    return this.each(function () {
      var $this = $(this),
          data = $this.data('owl.carousel');

      if (!data) {
        data = new Owl(this, _typeof(option) == 'object' && option);
        $this.data('owl.carousel', data);
        $.each(['next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'], function (i, event) {
          data.register({
            type: Owl.Type.Event,
            name: event
          });
          data.$element.on(event + '.owl.carousel.core', $.proxy(function (e) {
            if (e.namespace && e.relatedTarget !== this) {
              this.suppress([event]);
              data[event].apply(this, [].slice.call(arguments, 1));
              this.release([event]);
            }
          }, data));
        });
      }

      if (typeof option == 'string' && option.charAt(0) !== '_') {
        data[option].apply(data, args);
      }
    });
  };
  /**
   * The constructor for the jQuery Plugin
   * @public
   */


  $.fn.owlCarousel.Constructor = Owl;
})(window.Zepto || window.jQuery, window, document);
/**
 * AutoRefresh Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the auto refresh plugin.
   * @class The Auto Refresh Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var AutoRefresh = function AutoRefresh(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Refresh interval.
     * @protected
     * @type {number}
     */

    this._interval = null;
    /**
     * Whether the element is currently visible or not.
     * @protected
     * @type {Boolean}
     */

    this._visible = null;
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoRefresh) {
          this.watch();
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options); // register event handlers

    this._core.$element.on(this._handlers);
  };
  /**
   * Default options.
   * @public
   */


  AutoRefresh.Defaults = {
    autoRefresh: true,
    autoRefreshInterval: 500
  };
  /**
   * Watches the element.
   */

  AutoRefresh.prototype.watch = function () {
    if (this._interval) {
      return;
    }

    this._visible = this._core.isVisible();
    this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
  };
  /**
   * Refreshes the element.
   */


  AutoRefresh.prototype.refresh = function () {
    if (this._core.isVisible() === this._visible) {
      return;
    }

    this._visible = !this._visible;

    this._core.$element.toggleClass('owl-hidden', !this._visible);

    this._visible && this._core.invalidate('width') && this._core.refresh();
  };
  /**
   * Destroys the plugin.
   */


  AutoRefresh.prototype.destroy = function () {
    var handler, property;
    window.clearInterval(this._interval);

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;
})(window.Zepto || window.jQuery, window, document);
/**
 * Lazy Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the lazy plugin.
   * @class The Lazy Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var Lazy = function Lazy(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Already loaded items.
     * @protected
     * @type {Array.<jQuery>}
     */

    this._loaded = [];
    /**
     * Event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function (e) {
        if (!e.namespace) {
          return;
        }

        if (!this._core.settings || !this._core.settings.lazyLoad) {
          return;
        }

        if (e.property && e.property.name == 'position' || e.type == 'initialized') {
          var settings = this._core.settings,
              n = settings.center && Math.ceil(settings.items / 2) || settings.items,
              i = settings.center && n * -1 || 0,
              position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
              clones = this._core.clones().length,
              load = $.proxy(function (i, v) {
            this.load(v);
          }, this); //TODO: Need documentation for this new option


          if (settings.lazyLoadEager > 0) {
            n += settings.lazyLoadEager; // If the carousel is looping also preload images that are to the "left"

            if (settings.loop) {
              position -= settings.lazyLoadEager;
              n++;
            }
          }

          while (i++ < n) {
            this.load(clones / 2 + this._core.relative(position));
            clones && $.each(this._core.clones(this._core.relative(position)), load);
            position++;
          }
        }
      }, this)
    }; // set the default options

    this._core.options = $.extend({}, Lazy.Defaults, this._core.options); // register event handler

    this._core.$element.on(this._handlers);
  };
  /**
   * Default options.
   * @public
   */


  Lazy.Defaults = {
    lazyLoad: false,
    lazyLoadEager: 0
  };
  /**
   * Loads all resources of an item at the specified position.
   * @param {Number} position - The absolute position of the item.
   * @protected
   */

  Lazy.prototype.load = function (position) {
    var $item = this._core.$stage.children().eq(position),
        $elements = $item && $item.find('.owl-lazy');

    if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
      return;
    }

    $elements.each($.proxy(function (index, element) {
      var $element = $(element),
          image,
          url = window.devicePixelRatio > 1 && $element.attr('data-src-retina') || $element.attr('data-src') || $element.attr('data-srcset');

      this._core.trigger('load', {
        element: $element,
        url: url
      }, 'lazy');

      if ($element.is('img')) {
        $element.one('load.owl.lazy', $.proxy(function () {
          $element.css('opacity', 1);

          this._core.trigger('loaded', {
            element: $element,
            url: url
          }, 'lazy');
        }, this)).attr('src', url);
      } else if ($element.is('source')) {
        $element.one('load.owl.lazy', $.proxy(function () {
          this._core.trigger('loaded', {
            element: $element,
            url: url
          }, 'lazy');
        }, this)).attr('srcset', url);
      } else {
        image = new Image();
        image.onload = $.proxy(function () {
          $element.css({
            'background-image': 'url("' + url + '")',
            'opacity': '1'
          });

          this._core.trigger('loaded', {
            element: $element,
            url: url
          }, 'lazy');
        }, this);
        image.src = url;
      }
    }, this));

    this._loaded.push($item.get(0));
  };
  /**
   * Destroys the plugin.
   * @public
   */


  Lazy.prototype.destroy = function () {
    var handler, property;

    for (handler in this.handlers) {
      this._core.$element.off(handler, this.handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;
})(window.Zepto || window.jQuery, window, document);
/**
 * AutoHeight Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the auto height plugin.
   * @class The Auto Height Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var AutoHeight = function AutoHeight(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    this._previousHeight = null;
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoHeight) {
          this.update();
        }
      }, this),
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position') {
          this.update();
        }
      }, this),
      'loaded.owl.lazy': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoHeight && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
          this.update();
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options); // register event handlers

    this._core.$element.on(this._handlers);

    this._intervalId = null;
    var refThis = this; // These changes have been taken from a PR by gavrochelegnou proposed in #1575
    // and have been made compatible with the latest jQuery version

    $(window).on('load', function () {
      if (refThis._core.settings.autoHeight) {
        refThis.update();
      }
    }); // Autoresize the height of the carousel when window is resized
    // When carousel has images, the height is dependent on the width
    // and should also change on resize

    $(window).resize(function () {
      if (refThis._core.settings.autoHeight) {
        if (refThis._intervalId != null) {
          clearTimeout(refThis._intervalId);
        }

        refThis._intervalId = setTimeout(function () {
          refThis.update();
        }, 250);
      }
    });
  };
  /**
   * Default options.
   * @public
   */


  AutoHeight.Defaults = {
    autoHeight: false,
    autoHeightClass: 'owl-height'
  };
  /**
   * Updates the view.
   */

  AutoHeight.prototype.update = function () {
    var start = this._core._current,
        end = start + this._core.settings.items,
        lazyLoadEnabled = this._core.settings.lazyLoad,
        visible = this._core.$stage.children().toArray().slice(start, end),
        heights = [],
        maxheight = 0;

    $.each(visible, function (index, item) {
      heights.push($(item).height());
    });
    maxheight = Math.max.apply(null, heights);

    if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
      maxheight = this._previousHeight;
    }

    this._previousHeight = maxheight;

    this._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass);
  };

  AutoHeight.prototype.destroy = function () {
    var handler, property;

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] !== 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;
})(window.Zepto || window.jQuery, window, document);
/**
 * Video Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the video plugin.
   * @class The Video Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var Video = function Video(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Cache all video URLs.
     * @protected
     * @type {Object}
     */

    this._videos = {};
    /**
     * Current playing item.
     * @protected
     * @type {jQuery}
     */

    this._playing = null;
    /**
     * All event handlers.
     * @todo The cloned content removale is too late
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace) {
          this._core.register({
            type: 'state',
            name: 'playing',
            tags: ['interacting']
          });
        }
      }, this),
      'resize.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
          e.preventDefault();
        }
      }, this),
      'refreshed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.is('resizing')) {
          this._core.$stage.find('.cloned .owl-video-frame').remove();
        }
      }, this),
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name === 'position' && this._playing) {
          this.stop();
        }
      }, this),
      'prepared.owl.carousel': $.proxy(function (e) {
        if (!e.namespace) {
          return;
        }

        var $element = $(e.content).find('.owl-video');

        if ($element.length) {
          $element.css('display', 'none');
          this.fetch($element, $(e.content));
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, Video.Defaults, this._core.options); // register event handlers

    this._core.$element.on(this._handlers);

    this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function (e) {
      this.play(e);
    }, this));
  };
  /**
   * Default options.
   * @public
   */


  Video.Defaults = {
    video: false,
    videoHeight: false,
    videoWidth: false
  };
  /**
   * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
   * @protected
   * @param {jQuery} target - The target containing the video data.
   * @param {jQuery} item - The item containing the video.
   */

  Video.prototype.fetch = function (target, item) {
    var type = function () {
      if (target.attr('data-vimeo-id')) {
        return 'vimeo';
      } else if (target.attr('data-vzaar-id')) {
        return 'vzaar';
      } else {
        return 'youtube';
      }
    }(),
        id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
        width = target.attr('data-width') || this._core.settings.videoWidth,
        height = target.attr('data-height') || this._core.settings.videoHeight,
        url = target.attr('href');

    if (url) {
      /*
      		Parses the id's out of the following urls (and probably more):
      		https://www.youtube.com/watch?v=:id
      		https://youtu.be/:id
      		https://vimeo.com/:id
      		https://vimeo.com/channels/:channel/:id
      		https://vimeo.com/groups/:group/videos/:id
      		https://app.vzaar.com/videos/:id
      			Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
      */
      id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

      if (id[3].indexOf('youtu') > -1) {
        type = 'youtube';
      } else if (id[3].indexOf('vimeo') > -1) {
        type = 'vimeo';
      } else if (id[3].indexOf('vzaar') > -1) {
        type = 'vzaar';
      } else {
        throw new Error('Video URL not supported.');
      }

      id = id[6];
    } else {
      throw new Error('Missing video URL.');
    }

    this._videos[url] = {
      type: type,
      id: id,
      width: width,
      height: height
    };
    item.attr('data-video', url);
    this.thumbnail(target, this._videos[url]);
  };
  /**
   * Creates video thumbnail.
   * @protected
   * @param {jQuery} target - The target containing the video data.
   * @param {Object} info - The video info object.
   * @see `fetch`
   */


  Video.prototype.thumbnail = function (target, video) {
    var tnLink,
        icon,
        path,
        dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',
        customTn = target.find('img'),
        srcType = 'src',
        lazyClass = '',
        settings = this._core.settings,
        create = function create(path) {
      icon = '<div class="owl-video-play-icon"></div>';

      if (settings.lazyLoad) {
        tnLink = $('<div/>', {
          "class": 'owl-video-tn ' + lazyClass,
          "srcType": path
        });
      } else {
        tnLink = $('<div/>', {
          "class": "owl-video-tn",
          "style": 'opacity:1;background-image:url(' + path + ')'
        });
      }

      target.after(tnLink);
      target.after(icon);
    }; // wrap video content into owl-video-wrapper div


    target.wrap($('<div/>', {
      "class": "owl-video-wrapper",
      "style": dimensions
    }));

    if (this._core.settings.lazyLoad) {
      srcType = 'data-src';
      lazyClass = 'owl-lazy';
    } // custom thumbnail


    if (customTn.length) {
      create(customTn.attr(srcType));
      customTn.remove();
      return false;
    }

    if (video.type === 'youtube') {
      path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
      create(path);
    } else if (video.type === 'vimeo') {
      $.ajax({
        type: 'GET',
        url: '//vimeo.com/api/v2/video/' + video.id + '.json',
        jsonp: 'callback',
        dataType: 'jsonp',
        success: function success(data) {
          path = data[0].thumbnail_large;
          create(path);
        }
      });
    } else if (video.type === 'vzaar') {
      $.ajax({
        type: 'GET',
        url: '//vzaar.com/api/videos/' + video.id + '.json',
        jsonp: 'callback',
        dataType: 'jsonp',
        success: function success(data) {
          path = data.framegrab_url;
          create(path);
        }
      });
    }
  };
  /**
   * Stops the current video.
   * @public
   */


  Video.prototype.stop = function () {
    this._core.trigger('stop', null, 'video');

    this._playing.find('.owl-video-frame').remove();

    this._playing.removeClass('owl-video-playing');

    this._playing = null;

    this._core.leave('playing');

    this._core.trigger('stopped', null, 'video');
  };
  /**
   * Starts the current video.
   * @public
   * @param {Event} event - The event arguments.
   */


  Video.prototype.play = function (event) {
    var target = $(event.target),
        item = target.closest('.' + this._core.settings.itemClass),
        video = this._videos[item.attr('data-video')],
        width = video.width || '100%',
        height = video.height || this._core.$stage.height(),
        html,
        iframe;

    if (this._playing) {
      return;
    }

    this._core.enter('playing');

    this._core.trigger('play', null, 'video');

    item = this._core.items(this._core.relative(item.index()));

    this._core.reset(item.index());

    html = $('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>');
    html.attr('height', height);
    html.attr('width', width);

    if (video.type === 'youtube') {
      html.attr('src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id);
    } else if (video.type === 'vimeo') {
      html.attr('src', '//player.vimeo.com/video/' + video.id + '?autoplay=1');
    } else if (video.type === 'vzaar') {
      html.attr('src', '//view.vzaar.com/' + video.id + '/player?autoplay=true');
    }

    iframe = $(html).wrap('<div class="owl-video-frame" />').insertAfter(item.find('.owl-video'));
    this._playing = item.addClass('owl-video-playing');
  };
  /**
   * Checks whether an video is currently in full screen mode or not.
   * @todo Bad style because looks like a readonly method but changes members.
   * @protected
   * @returns {Boolean}
   */


  Video.prototype.isInFullScreen = function () {
    var element = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
    return element && $(element).parent().hasClass('owl-video-frame');
  };
  /**
   * Destroys the plugin.
   */


  Video.prototype.destroy = function () {
    var handler, property;

    this._core.$element.off('click.owl.video');

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Video = Video;
})(window.Zepto || window.jQuery, window, document);
/**
 * Animate Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the animate plugin.
   * @class The Navigation Plugin
   * @param {Owl} scope - The Owl Carousel
   */
  var Animate = function Animate(scope) {
    this.core = scope;
    this.core.options = $.extend({}, Animate.Defaults, this.core.options);
    this.swapping = true;
    this.previous = undefined;
    this.next = undefined;
    this.handlers = {
      'change.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name == 'position') {
          this.previous = this.core.current();
          this.next = e.property.value;
        }
      }, this),
      'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function (e) {
        if (e.namespace) {
          this.swapping = e.type == 'translated';
        }
      }, this),
      'translate.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
          this.swap();
        }
      }, this)
    };
    this.core.$element.on(this.handlers);
  };
  /**
   * Default options.
   * @public
   */


  Animate.Defaults = {
    animateOut: false,
    animateIn: false
  };
  /**
   * Toggles the animation classes whenever an translations starts.
   * @protected
   * @returns {Boolean|undefined}
   */

  Animate.prototype.swap = function () {
    if (this.core.settings.items !== 1) {
      return;
    }

    if (!$.support.animation || !$.support.transition) {
      return;
    }

    this.core.speed(0);
    var left,
        clear = $.proxy(this.clear, this),
        previous = this.core.$stage.children().eq(this.previous),
        next = this.core.$stage.children().eq(this.next),
        incoming = this.core.settings.animateIn,
        outgoing = this.core.settings.animateOut;

    if (this.core.current() === this.previous) {
      return;
    }

    if (outgoing) {
      left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
      previous.one($.support.animation.end, clear).css({
        'left': left + 'px'
      }).addClass('animated owl-animated-out').addClass(outgoing);
    }

    if (incoming) {
      next.one($.support.animation.end, clear).addClass('animated owl-animated-in').addClass(incoming);
    }
  };

  Animate.prototype.clear = function (e) {
    $(e.target).css({
      'left': ''
    }).removeClass('animated owl-animated-out owl-animated-in').removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut);
    this.core.onTransitionEnd();
  };
  /**
   * Destroys the plugin.
   * @public
   */


  Animate.prototype.destroy = function () {
    var handler, property;

    for (handler in this.handlers) {
      this.core.$element.off(handler, this.handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;
})(window.Zepto || window.jQuery, window, document);
/**
 * Autoplay Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author Artus Kolanowski
 * @author David Deutsch
 * @author Tom De Caluwé
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the autoplay plugin.
   * @class The Autoplay Plugin
   * @param {Owl} scope - The Owl Carousel
   */
  var Autoplay = function Autoplay(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * The autoplay timeout id.
     * @type {Number}
     */

    this._call = null;
    /**
     * Depending on the state of the plugin, this variable contains either
     * the start time of the timer or the current timer value if it's
     * paused. Since we start in a paused state we initialize the timer
     * value.
     * @type {Number}
     */

    this._time = 0;
    /**
     * Stores the timeout currently used.
     * @type {Number}
     */

    this._timeout = 0;
    /**
     * Indicates whenever the autoplay is paused.
     * @type {Boolean}
     */

    this._paused = true;
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name === 'settings') {
          if (this._core.settings.autoplay) {
            this.play();
          } else {
            this.stop();
          }
        } else if (e.namespace && e.property.name === 'position' && this._paused) {
          // Reset the timer. This code is triggered when the position
          // of the carousel was changed through user interaction.
          this._time = 0;
        }
      }, this),
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoplay) {
          this.play();
        }
      }, this),
      'play.owl.autoplay': $.proxy(function (e, t, s) {
        if (e.namespace) {
          this.play(t, s);
        }
      }, this),
      'stop.owl.autoplay': $.proxy(function (e) {
        if (e.namespace) {
          this.stop();
        }
      }, this),
      'mouseover.owl.autoplay': $.proxy(function () {
        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
          this.pause();
        }
      }, this),
      'mouseleave.owl.autoplay': $.proxy(function () {
        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
          this.play();
        }
      }, this),
      'touchstart.owl.core': $.proxy(function () {
        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
          this.pause();
        }
      }, this),
      'touchend.owl.core': $.proxy(function () {
        if (this._core.settings.autoplayHoverPause) {
          this.play();
        }
      }, this)
    }; // register event handlers

    this._core.$element.on(this._handlers); // set default options


    this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
  };
  /**
   * Default options.
   * @public
   */


  Autoplay.Defaults = {
    autoplay: false,
    autoplayTimeout: 5000,
    autoplayHoverPause: false,
    autoplaySpeed: false
  };
  /**
   * Transition to the next slide and set a timeout for the next transition.
   * @private
   * @param {Number} [speed] - The animation speed for the animations.
   */

  Autoplay.prototype._next = function (speed) {
    this._call = window.setTimeout($.proxy(this._next, this, speed), this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read());

    if (this._core.is('interacting') || document.hidden) {
      return;
    }

    this._core.next(speed || this._core.settings.autoplaySpeed);
  };
  /**
   * Reads the current timer value when the timer is playing.
   * @public
   */


  Autoplay.prototype.read = function () {
    return new Date().getTime() - this._time;
  };
  /**
   * Starts the autoplay.
   * @public
   * @param {Number} [timeout] - The interval before the next animation starts.
   * @param {Number} [speed] - The animation speed for the animations.
   */


  Autoplay.prototype.play = function (timeout, speed) {
    var elapsed;

    if (!this._core.is('rotating')) {
      this._core.enter('rotating');
    }

    timeout = timeout || this._core.settings.autoplayTimeout; // Calculate the elapsed time since the last transition. If the carousel
    // wasn't playing this calculation will yield zero.

    elapsed = Math.min(this._time % (this._timeout || timeout), timeout);

    if (this._paused) {
      // Start the clock.
      this._time = this.read();
      this._paused = false;
    } else {
      // Clear the active timeout to allow replacement.
      window.clearTimeout(this._call);
    } // Adjust the origin of the timer to match the new timeout value.


    this._time += this.read() % timeout - elapsed;
    this._timeout = timeout;
    this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);
  };
  /**
   * Stops the autoplay.
   * @public
   */


  Autoplay.prototype.stop = function () {
    if (this._core.is('rotating')) {
      // Reset the clock.
      this._time = 0;
      this._paused = true;
      window.clearTimeout(this._call);

      this._core.leave('rotating');
    }
  };
  /**
   * Pauses the autoplay.
   * @public
   */


  Autoplay.prototype.pause = function () {
    if (this._core.is('rotating') && !this._paused) {
      // Pause the clock.
      this._time = this.read();
      this._paused = true;
      window.clearTimeout(this._call);
    }
  };
  /**
   * Destroys the plugin.
   */


  Autoplay.prototype.destroy = function () {
    var handler, property;
    this.stop();

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;
})(window.Zepto || window.jQuery, window, document);
/**
 * Navigation Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  'use strict';
  /**
   * Creates the navigation plugin.
   * @class The Navigation Plugin
   * @param {Owl} carousel - The Owl Carousel.
   */

  var Navigation = function Navigation(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Indicates whether the plugin is initialized or not.
     * @protected
     * @type {Boolean}
     */

    this._initialized = false;
    /**
     * The current paging indexes.
     * @protected
     * @type {Array}
     */

    this._pages = [];
    /**
     * All DOM elements of the user interface.
     * @protected
     * @type {Object}
     */

    this._controls = {};
    /**
     * Markup for an indicator.
     * @protected
     * @type {Array.<String>}
     */

    this._templates = [];
    /**
     * The carousel element.
     * @type {jQuery}
     */

    this.$element = this._core.$element;
    /**
     * Overridden methods of the carousel.
     * @protected
     * @type {Object}
     */

    this._overrides = {
      next: this._core.next,
      prev: this._core.prev,
      to: this._core.to
    };
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'prepared.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.push('<div class="' + this._core.settings.dotClass + '">' + $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
        }
      }, this),
      'added.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.splice(e.position, 0, this._templates.pop());
        }
      }, this),
      'remove.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.splice(e.position, 1);
        }
      }, this),
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name == 'position') {
          this.draw();
        }
      }, this),
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace && !this._initialized) {
          this._core.trigger('initialize', null, 'navigation');

          this.initialize();
          this.update();
          this.draw();
          this._initialized = true;

          this._core.trigger('initialized', null, 'navigation');
        }
      }, this),
      'refreshed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._initialized) {
          this._core.trigger('refresh', null, 'navigation');

          this.update();
          this.draw();

          this._core.trigger('refreshed', null, 'navigation');
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, Navigation.Defaults, this._core.options); // register event handlers

    this.$element.on(this._handlers);
  };
  /**
   * Default options.
   * @public
   * @todo Rename `slideBy` to `navBy`
   */


  Navigation.Defaults = {
    nav: false,
    navText: ['<span aria-label="' + 'Previous' + '">&#x2039;</span>', '<span aria-label="' + 'Next' + '">&#x203a;</span>'],
    navSpeed: false,
    navElement: 'button type="button" role="presentation"',
    navContainer: false,
    navContainerClass: 'owl-nav',
    navClass: ['owl-prev', 'owl-next'],
    slideBy: 1,
    dotClass: 'owl-dot',
    dotsClass: 'owl-dots',
    dots: true,
    dotsEach: false,
    dotsData: false,
    dotsSpeed: false,
    dotsContainer: false
  };
  /**
   * Initializes the layout of the plugin and extends the carousel.
   * @protected
   */

  Navigation.prototype.initialize = function () {
    var override,
        settings = this._core.settings; // create DOM structure for relative navigation

    this._controls.$relative = (settings.navContainer ? $(settings.navContainer) : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');
    this._controls.$previous = $('<' + settings.navElement + '>').addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on('click', $.proxy(function (e) {
      this.prev(settings.navSpeed);
    }, this));
    this._controls.$next = $('<' + settings.navElement + '>').addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on('click', $.proxy(function (e) {
      this.next(settings.navSpeed);
    }, this)); // create DOM structure for absolute navigation

    if (!settings.dotsData) {
      this._templates = [$('<button role="button">').addClass(settings.dotClass).append($('<span>')).prop('outerHTML')];
    }

    this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer) : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

    this._controls.$absolute.on('click', 'button', $.proxy(function (e) {
      var index = $(e.target).parent().is(this._controls.$absolute) ? $(e.target).index() : $(e.target).parent().index();
      e.preventDefault();
      this.to(index, settings.dotsSpeed);
    }, this));
    /*$el.on('focusin', function() {
    	$(document).off(".carousel");
    		$(document).on('keydown.carousel', function(e) {
    		if(e.keyCode == 37) {
    			$el.trigger('prev.owl')
    		}
    		if(e.keyCode == 39) {
    			$el.trigger('next.owl')
    		}
    	});
    });*/
    // override public methods of the carousel


    for (override in this._overrides) {
      this._core[override] = $.proxy(this[override], this);
    }
  };
  /**
   * Destroys the plugin.
   * @protected
   */


  Navigation.prototype.destroy = function () {
    var handler, control, property, override, settings;
    settings = this._core.settings;

    for (handler in this._handlers) {
      this.$element.off(handler, this._handlers[handler]);
    }

    for (control in this._controls) {
      if (control === '$relative' && settings.navContainer) {
        this._controls[control].html('');
      } else {
        this._controls[control].remove();
      }
    }

    for (override in this.overides) {
      this._core[override] = this._overrides[override];
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };
  /**
   * Updates the internal state.
   * @protected
   */


  Navigation.prototype.update = function () {
    var i,
        j,
        k,
        lower = this._core.clones().length / 2,
        upper = lower + this._core.items().length,
        maximum = this._core.maximum(true),
        settings = this._core.settings,
        size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;

    if (settings.slideBy !== 'page') {
      settings.slideBy = Math.min(settings.slideBy, settings.items);
    }

    if (settings.dots || settings.slideBy == 'page') {
      this._pages = [];

      for (i = lower, j = 0, k = 0; i < upper; i++) {
        if (j >= size || j === 0) {
          this._pages.push({
            start: Math.min(maximum, i - lower),
            end: i - lower + size - 1
          });

          if (Math.min(maximum, i - lower) === maximum) {
            break;
          }

          j = 0, ++k;
        }

        j += this._core.mergers(this._core.relative(i));
      }
    }
  };
  /**
   * Draws the user interface.
   * @todo The option `dotsData` wont work.
   * @protected
   */


  Navigation.prototype.draw = function () {
    var difference,
        settings = this._core.settings,
        disabled = this._core.items().length <= settings.items,
        index = this._core.relative(this._core.current()),
        loop = settings.loop || settings.rewind;

    this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

    if (settings.nav) {
      this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));

      this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
    }

    this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

    if (settings.dots) {
      difference = this._pages.length - this._controls.$absolute.children().length;

      if (settings.dotsData && difference !== 0) {
        this._controls.$absolute.html(this._templates.join(''));
      } else if (difference > 0) {
        this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
      } else if (difference < 0) {
        this._controls.$absolute.children().slice(difference).remove();
      }

      this._controls.$absolute.find('.active').removeClass('active');

      this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
    }
  };
  /**
   * Extends event data.
   * @protected
   * @param {Event} event - The event object which gets thrown.
   */


  Navigation.prototype.onTrigger = function (event) {
    var settings = this._core.settings;
    event.page = {
      index: $.inArray(this.current(), this._pages),
      count: this._pages.length,
      size: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)
    };
  };
  /**
   * Gets the current page position of the carousel.
   * @protected
   * @returns {Number}
   */


  Navigation.prototype.current = function () {
    var current = this._core.relative(this._core.current());

    return $.grep(this._pages, $.proxy(function (page, index) {
      return page.start <= current && page.end >= current;
    }, this)).pop();
  };
  /**
   * Gets the current succesor/predecessor position.
   * @protected
   * @returns {Number}
   */


  Navigation.prototype.getPosition = function (successor) {
    var position,
        length,
        settings = this._core.settings;

    if (settings.slideBy == 'page') {
      position = $.inArray(this.current(), this._pages);
      length = this._pages.length;
      successor ? ++position : --position;
      position = this._pages[(position % length + length) % length].start;
    } else {
      position = this._core.relative(this._core.current());
      length = this._core.items().length;
      successor ? position += settings.slideBy : position -= settings.slideBy;
    }

    return position;
  };
  /**
   * Slides to the next item or page.
   * @public
   * @param {Number} [speed=false] - The time in milliseconds for the transition.
   */


  Navigation.prototype.next = function (speed) {
    $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
  };
  /**
   * Slides to the previous item or page.
   * @public
   * @param {Number} [speed=false] - The time in milliseconds for the transition.
   */


  Navigation.prototype.prev = function (speed) {
    $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
  };
  /**
   * Slides to the specified item or page.
   * @public
   * @param {Number} position - The position of the item or page.
   * @param {Number} [speed] - The time in milliseconds for the transition.
   * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
   */


  Navigation.prototype.to = function (position, speed, standard) {
    var length;

    if (!standard && this._pages.length) {
      length = this._pages.length;
      $.proxy(this._overrides.to, this._core)(this._pages[(position % length + length) % length].start, speed);
    } else {
      $.proxy(this._overrides.to, this._core)(position, speed);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;
})(window.Zepto || window.jQuery, window, document);
/**
 * Hash Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  'use strict';
  /**
   * Creates the hash plugin.
   * @class The Hash Plugin
   * @param {Owl} carousel - The Owl Carousel
   */

  var Hash = function Hash(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Hash index for the items.
     * @protected
     * @type {Object}
     */

    this._hashes = {};
    /**
     * The carousel element.
     * @type {jQuery}
     */

    this.$element = this._core.$element;
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.startPosition === 'URLHash') {
          $(window).trigger('hashchange.owl.navigation');
        }
      }, this),
      'prepared.owl.carousel': $.proxy(function (e) {
        if (e.namespace) {
          var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

          if (!hash) {
            return;
          }

          this._hashes[hash] = e.content;
        }
      }, this),
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name === 'position') {
          var current = this._core.items(this._core.relative(this._core.current())),
              hash = $.map(this._hashes, function (item, hash) {
            return item === current ? hash : null;
          }).join();

          if (!hash || window.location.hash.slice(1) === hash) {
            return;
          }

          window.location.hash = hash;
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, Hash.Defaults, this._core.options); // register the event handlers

    this.$element.on(this._handlers); // register event listener for hash navigation

    $(window).on('hashchange.owl.navigation', $.proxy(function (e) {
      var hash = window.location.hash.substring(1),
          items = this._core.$stage.children(),
          position = this._hashes[hash] && items.index(this._hashes[hash]);

      if (position === undefined || position === this._core.current()) {
        return;
      }

      this._core.to(this._core.relative(position), false, true);
    }, this));
  };
  /**
   * Default options.
   * @public
   */


  Hash.Defaults = {
    URLhashListener: false
  };
  /**
   * Destroys the plugin.
   * @public
   */

  Hash.prototype.destroy = function () {
    var handler, property;
    $(window).off('hashchange.owl.navigation');

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;
})(window.Zepto || window.jQuery, window, document);
/**
 * Support Plugin
 *
 * @version 2.3.4
 * @author Vivid Planet Software GmbH
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  var style = $('<support>').get(0).style,
      prefixes = 'Webkit Moz O ms'.split(' '),
      events = {
    transition: {
      end: {
        WebkitTransition: 'webkitTransitionEnd',
        MozTransition: 'transitionend',
        OTransition: 'oTransitionEnd',
        transition: 'transitionend'
      }
    },
    animation: {
      end: {
        WebkitAnimation: 'webkitAnimationEnd',
        MozAnimation: 'animationend',
        OAnimation: 'oAnimationEnd',
        animation: 'animationend'
      }
    }
  },
      tests = {
    csstransforms: function csstransforms() {
      return !!test('transform');
    },
    csstransforms3d: function csstransforms3d() {
      return !!test('perspective');
    },
    csstransitions: function csstransitions() {
      return !!test('transition');
    },
    cssanimations: function cssanimations() {
      return !!test('animation');
    }
  };

  function test(property, prefixed) {
    var result = false,
        upper = property.charAt(0).toUpperCase() + property.slice(1);
    $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function (i, property) {
      if (style[property] !== undefined) {
        result = prefixed ? property : true;
        return false;
      }
    });
    return result;
  }

  function prefixed(property) {
    return test(property, true);
  }

  if (tests.csstransitions()) {
    /* jshint -W053 */
    $.support.transition = new String(prefixed('transition'));
    $.support.transition.end = events.transition.end[$.support.transition];
  }

  if (tests.cssanimations()) {
    /* jshint -W053 */
    $.support.animation = new String(prefixed('animation'));
    $.support.animation.end = events.animation.end[$.support.animation];
  }

  if (tests.csstransforms()) {
    /* jshint -W053 */
    $.support.transform = new String(prefixed('transform'));
    $.support.transform3d = tests.csstransforms3d();
  }
})(window.Zepto || window.jQuery, window, document);

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }

  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }

    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/

var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */


function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  } // NOTE: 1 DOM access here


  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */


function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }

  return element.parentNode || element.host;
}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */


function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;

    case '#document':
      return element.body;
  } // Firefox want us to check `-x` and `-y` variations as well


  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */


function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */

function isIE(version) {
  if (version === 11) {
    return isIE11;
  }

  if (version === 10) {
    return isIE10;
  }

  return isIE11 || isIE10;
}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  } // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...


  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }

  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */


function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */


function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  } // Here we make sure to give as "start" the element that comes first in the DOM


  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1; // Get common ancestor container

  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  } // one of the nodes is inside shadowDOM, find which one


  var element1root = getRoot(element1);

  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */


function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */


function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */


function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */


function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */


function getBoundingClientRect(element) {
  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11

  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  }; // subtract scrollbar size from sizes

  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons

  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.

  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };
  return getClientRect(offset);
}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */


function isFixed(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }

  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }

  var parentNode = getParentNode(element);

  if (!parentNode) {
    return false;
  }

  return isFixed(parentNode);
}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */


function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }

  var el = element.parentElement;

  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }

  return el || document.documentElement;
}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */


function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

  var boundaries = {
    top: 0,
    left: 0
  };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;

    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));

      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  } // Add paddings


  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return width * height;
}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split('-')[1];
  return computedPlacement + (variation ? '-' + variation : '');
}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */


function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */


function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */


function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */


function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0]; // Get popper node sizes

  var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  }; // depending by the popper placement we have to compute its offsets slightly differently

  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  } // use `filter` to obtain the same behavior of `find`


  return arr.filter(check)[0];
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  } // use `find` + `indexOf` if `findIndex` isn't supported


  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */


function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }

    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */


function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  }; // compute reference element offsets

  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed; // compute the popper offsets

  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

  data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback

  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */


function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */


function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;

    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }

  return null;
}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */


function destroy() {
  this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it

  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }

  return this;
}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */


function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, {
    passive: true
  });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }

  scrollParents.push(target);
}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, {
    passive: true
  }); // Scroll event listener on scroll parents

  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */


function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  }); // Reset state

  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */


function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */


function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = ''; // add unit if the value is numeric and is one of the following

    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }

    element.style[prop] = styles[prop] + unit;
  });
}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];

    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */


function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element

  setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */


function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations

  setStyles(popper, {
    position: options.positionFixed ? 'fixed' : 'absolute'
  });
  return options;
}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */


function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;

  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }

  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed

  var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.

  var left = void 0,
      top = void 0;

  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }

  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }

  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  } // Attributes


  var attributes = {
    'x-placement': data.placement
  }; // Update `data` attributes, styles and arrowStyles

  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */


function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';

    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }

  return isRequired;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function arrow(data, options) {
  var _data$offsets$arrow; // arrow depends on keepTogether in order to work


  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len]; //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //
  // top/left side

  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  } // bottom/right side


  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available

  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  return data;
}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */


function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }

  return variation;
}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */


var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

var validPlacements = placements.slice(3);
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */

function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;

    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;

    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;

    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future

      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }

  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */


function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2]; // If it's not a number it's an operator, I guess

  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;

    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;

      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;

    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }

    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */


function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one

  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  }); // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space

  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  } // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.


  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []) // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  }); // Loop trough the offsets arrays and execute the operations

  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */


function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var basePlacement = placement.split('-')[0];
  var offsets = void 0;

  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken

  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  } // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself


  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification

  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];
  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed

  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];

      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }

      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];

      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }

      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;
    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */


var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: offset,

    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: preventOverflow,

    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],

    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: arrow,

    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: flip,

    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',

    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',

    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,

    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,

    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,

    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: computeStyle,

    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,

    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',

    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: applyStyle,

    /** @prop {Function} */
    onLoad: applyStyleOnLoad,

    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */

var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};
/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */
// Utils
// Methods

var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    }; // make update() debounced, so that it only runs at most once-per-tick


    this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

    this.options = _extends({}, Popper.Defaults, options); // init state

    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    }; // get reference and popper elements (allow jQuery wrappers)

    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    }); // Refactoring modifiers' list (Object => Array)

    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    }) // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    }); // fire the first update to position the popper in the right place

    this.update();
    var eventsEnabled = this.options.eventsEnabled;

    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  } // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
/* harmony default export */ __webpack_exports__["default"] = (Popper);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/wow.js/dist/wow.js":
/*!*****************************************!*\
  !*** ./node_modules/wow.js/dist/wow.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _class, _temp;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function isIn(needle, haystack) {
    return haystack.indexOf(needle) >= 0;
  }

  function extend(custom, defaults) {
    for (var key in defaults) {
      if (custom[key] == null) {
        var value = defaults[key];
        custom[key] = value;
      }
    }

    return custom;
  }

  function isMobile(agent) {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);
  }

  function createEvent(event) {
    var bubble = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
    var cancel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
    var detail = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
    var customEvent = void 0;

    if (document.createEvent != null) {
      // W3C DOM
      customEvent = document.createEvent('CustomEvent');
      customEvent.initCustomEvent(event, bubble, cancel, detail);
    } else if (document.createEventObject != null) {
      // IE DOM < 9
      customEvent = document.createEventObject();
      customEvent.eventType = event;
    } else {
      customEvent.eventName = event;
    }

    return customEvent;
  }

  function emitEvent(elem, event) {
    if (elem.dispatchEvent != null) {
      // W3C DOM
      elem.dispatchEvent(event);
    } else if (event in (elem != null)) {
      elem[event]();
    } else if ('on' + event in (elem != null)) {
      elem['on' + event]();
    }
  }

  function addEvent(elem, event, fn) {
    if (elem.addEventListener != null) {
      // W3C DOM
      elem.addEventListener(event, fn, false);
    } else if (elem.attachEvent != null) {
      // IE DOM
      elem.attachEvent('on' + event, fn);
    } else {
      // fallback
      elem[event] = fn;
    }
  }

  function removeEvent(elem, event, fn) {
    if (elem.removeEventListener != null) {
      // W3C DOM
      elem.removeEventListener(event, fn, false);
    } else if (elem.detachEvent != null) {
      // IE DOM
      elem.detachEvent('on' + event, fn);
    } else {
      // fallback
      delete elem[event];
    }
  }

  function getInnerHeight() {
    if ('innerHeight' in window) {
      return window.innerHeight;
    }

    return document.documentElement.clientHeight;
  } // Minimalistic WeakMap shim, just in case.


  var WeakMap = window.WeakMap || window.MozWeakMap || function () {
    function WeakMap() {
      _classCallCheck(this, WeakMap);

      this.keys = [];
      this.values = [];
    }

    _createClass(WeakMap, [{
      key: 'get',
      value: function get(key) {
        for (var i = 0; i < this.keys.length; i++) {
          var item = this.keys[i];

          if (item === key) {
            return this.values[i];
          }
        }

        return undefined;
      }
    }, {
      key: 'set',
      value: function set(key, value) {
        for (var i = 0; i < this.keys.length; i++) {
          var item = this.keys[i];

          if (item === key) {
            this.values[i] = value;
            return this;
          }
        }

        this.keys.push(key);
        this.values.push(value);
        return this;
      }
    }]);

    return WeakMap;
  }(); // Dummy MutationObserver, to avoid raising exceptions.


  var MutationObserver = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver || (_temp = _class = function () {
    function MutationObserver() {
      _classCallCheck(this, MutationObserver);

      if (typeof console !== 'undefined' && console !== null) {
        console.warn('MutationObserver is not supported by your browser.');
        console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.');
      }
    }

    _createClass(MutationObserver, [{
      key: 'observe',
      value: function observe() {}
    }]);

    return MutationObserver;
  }(), _class.notSupported = true, _temp); // getComputedStyle shim, from http://stackoverflow.com/a/21797294

  var getComputedStyle = window.getComputedStyle || function getComputedStyle(el) {
    var getComputedStyleRX = /(\-([a-z]){1})/g;
    return {
      getPropertyValue: function getPropertyValue(prop) {
        if (prop === 'float') {
          prop = 'styleFloat';
        }

        if (getComputedStyleRX.test(prop)) {
          prop.replace(getComputedStyleRX, function (_, _char) {
            return _char.toUpperCase();
          });
        }

        var currentStyle = el.currentStyle;
        return (currentStyle != null ? currentStyle[prop] : void 0) || null;
      }
    };
  };

  var WOW = function () {
    function WOW() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      _classCallCheck(this, WOW);

      this.defaults = {
        boxClass: 'wow',
        animateClass: 'animated',
        offset: 0,
        mobile: true,
        live: true,
        callback: null,
        scrollContainer: null
      };

      this.animate = function animateFactory() {
        if ('requestAnimationFrame' in window) {
          return function (callback) {
            return window.requestAnimationFrame(callback);
          };
        }

        return function (callback) {
          return callback();
        };
      }();

      this.vendors = ['moz', 'webkit'];
      this.start = this.start.bind(this);
      this.resetAnimation = this.resetAnimation.bind(this);
      this.scrollHandler = this.scrollHandler.bind(this);
      this.scrollCallback = this.scrollCallback.bind(this);
      this.scrolled = true;
      this.config = extend(options, this.defaults);

      if (options.scrollContainer != null) {
        this.config.scrollContainer = document.querySelector(options.scrollContainer);
      } // Map of elements to animation names:


      this.animationNameCache = new WeakMap();
      this.wowEvent = createEvent(this.config.boxClass);
    }

    _createClass(WOW, [{
      key: 'init',
      value: function init() {
        this.element = window.document.documentElement;

        if (isIn(document.readyState, ['interactive', 'complete'])) {
          this.start();
        } else {
          addEvent(document, 'DOMContentLoaded', this.start);
        }

        this.finished = [];
      }
    }, {
      key: 'start',
      value: function start() {
        var _this = this;

        this.stopped = false;
        this.boxes = [].slice.call(this.element.querySelectorAll('.' + this.config.boxClass));
        this.all = this.boxes.slice(0);

        if (this.boxes.length) {
          if (this.disabled()) {
            this.resetStyle();
          } else {
            for (var i = 0; i < this.boxes.length; i++) {
              var box = this.boxes[i];
              this.applyStyle(box, true);
            }
          }
        }

        if (!this.disabled()) {
          addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);
          addEvent(window, 'resize', this.scrollHandler);
          this.interval = setInterval(this.scrollCallback, 50);
        }

        if (this.config.live) {
          var mut = new MutationObserver(function (records) {
            for (var j = 0; j < records.length; j++) {
              var record = records[j];

              for (var k = 0; k < record.addedNodes.length; k++) {
                var node = record.addedNodes[k];

                _this.doSync(node);
              }
            }

            return undefined;
          });
          mut.observe(document.body, {
            childList: true,
            subtree: true
          });
        }
      }
    }, {
      key: 'stop',
      value: function stop() {
        this.stopped = true;
        removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);
        removeEvent(window, 'resize', this.scrollHandler);

        if (this.interval != null) {
          clearInterval(this.interval);
        }
      }
    }, {
      key: 'sync',
      value: function sync() {
        if (MutationObserver.notSupported) {
          this.doSync(this.element);
        }
      }
    }, {
      key: 'doSync',
      value: function doSync(element) {
        if (typeof element === 'undefined' || element === null) {
          element = this.element;
        }

        if (element.nodeType !== 1) {
          return;
        }

        element = element.parentNode || element;
        var iterable = element.querySelectorAll('.' + this.config.boxClass);

        for (var i = 0; i < iterable.length; i++) {
          var box = iterable[i];

          if (!isIn(box, this.all)) {
            this.boxes.push(box);
            this.all.push(box);

            if (this.stopped || this.disabled()) {
              this.resetStyle();
            } else {
              this.applyStyle(box, true);
            }

            this.scrolled = true;
          }
        }
      }
    }, {
      key: 'show',
      value: function show(box) {
        this.applyStyle(box);
        box.className = box.className + ' ' + this.config.animateClass;

        if (this.config.callback != null) {
          this.config.callback(box);
        }

        emitEvent(box, this.wowEvent);
        addEvent(box, 'animationend', this.resetAnimation);
        addEvent(box, 'oanimationend', this.resetAnimation);
        addEvent(box, 'webkitAnimationEnd', this.resetAnimation);
        addEvent(box, 'MSAnimationEnd', this.resetAnimation);
        return box;
      }
    }, {
      key: 'applyStyle',
      value: function applyStyle(box, hidden) {
        var _this2 = this;

        var duration = box.getAttribute('data-wow-duration');
        var delay = box.getAttribute('data-wow-delay');
        var iteration = box.getAttribute('data-wow-iteration');
        return this.animate(function () {
          return _this2.customStyle(box, hidden, duration, delay, iteration);
        });
      }
    }, {
      key: 'resetStyle',
      value: function resetStyle() {
        for (var i = 0; i < this.boxes.length; i++) {
          var box = this.boxes[i];
          box.style.visibility = 'visible';
        }

        return undefined;
      }
    }, {
      key: 'resetAnimation',
      value: function resetAnimation(event) {
        if (event.type.toLowerCase().indexOf('animationend') >= 0) {
          var target = event.target || event.srcElement;
          target.className = target.className.replace(this.config.animateClass, '').trim();
        }
      }
    }, {
      key: 'customStyle',
      value: function customStyle(box, hidden, duration, delay, iteration) {
        if (hidden) {
          this.cacheAnimationName(box);
        }

        box.style.visibility = hidden ? 'hidden' : 'visible';

        if (duration) {
          this.vendorSet(box.style, {
            animationDuration: duration
          });
        }

        if (delay) {
          this.vendorSet(box.style, {
            animationDelay: delay
          });
        }

        if (iteration) {
          this.vendorSet(box.style, {
            animationIterationCount: iteration
          });
        }

        this.vendorSet(box.style, {
          animationName: hidden ? 'none' : this.cachedAnimationName(box)
        });
        return box;
      }
    }, {
      key: 'vendorSet',
      value: function vendorSet(elem, properties) {
        for (var name in properties) {
          if (properties.hasOwnProperty(name)) {
            var value = properties[name];
            elem['' + name] = value;

            for (var i = 0; i < this.vendors.length; i++) {
              var vendor = this.vendors[i];
              elem['' + vendor + name.charAt(0).toUpperCase() + name.substr(1)] = value;
            }
          }
        }
      }
    }, {
      key: 'vendorCSS',
      value: function vendorCSS(elem, property) {
        var style = getComputedStyle(elem);
        var result = style.getPropertyCSSValue(property);

        for (var i = 0; i < this.vendors.length; i++) {
          var vendor = this.vendors[i];
          result = result || style.getPropertyCSSValue('-' + vendor + '-' + property);
        }

        return result;
      }
    }, {
      key: 'animationName',
      value: function animationName(box) {
        var aName = void 0;

        try {
          aName = this.vendorCSS(box, 'animation-name').cssText;
        } catch (error) {
          // Opera, fall back to plain property value
          aName = getComputedStyle(box).getPropertyValue('animation-name');
        }

        if (aName === 'none') {
          return ''; // SVG/Firefox, unable to get animation name?
        }

        return aName;
      }
    }, {
      key: 'cacheAnimationName',
      value: function cacheAnimationName(box) {
        // https://bugzilla.mozilla.org/show_bug.cgi?id=921834
        // box.dataset is not supported for SVG elements in Firefox
        return this.animationNameCache.set(box, this.animationName(box));
      }
    }, {
      key: 'cachedAnimationName',
      value: function cachedAnimationName(box) {
        return this.animationNameCache.get(box);
      }
    }, {
      key: 'scrollHandler',
      value: function scrollHandler() {
        this.scrolled = true;
      }
    }, {
      key: 'scrollCallback',
      value: function scrollCallback() {
        if (this.scrolled) {
          this.scrolled = false;
          var results = [];

          for (var i = 0; i < this.boxes.length; i++) {
            var box = this.boxes[i];

            if (box) {
              if (this.isVisible(box)) {
                this.show(box);
                continue;
              }

              results.push(box);
            }
          }

          this.boxes = results;

          if (!this.boxes.length && !this.config.live) {
            this.stop();
          }
        }
      }
    }, {
      key: 'offsetTop',
      value: function offsetTop(element) {
        // SVG elements don't have an offsetTop in Firefox.
        // This will use their nearest parent that has an offsetTop.
        // Also, using ('offsetTop' of element) causes an exception in Firefox.
        while (element.offsetTop === undefined) {
          element = element.parentNode;
        }

        var top = element.offsetTop;

        while (element.offsetParent) {
          element = element.offsetParent;
          top += element.offsetTop;
        }

        return top;
      }
    }, {
      key: 'isVisible',
      value: function isVisible(box) {
        var offset = box.getAttribute('data-wow-offset') || this.config.offset;
        var viewTop = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset;
        var viewBottom = viewTop + Math.min(this.element.clientHeight, getInnerHeight()) - offset;
        var top = this.offsetTop(box);
        var bottom = top + box.clientHeight;
        return top <= viewBottom && bottom >= viewTop;
      }
    }, {
      key: 'disabled',
      value: function disabled() {
        return !this.config.mobile && isMobile(navigator.userAgent);
      }
    }]);

    return WOW;
  }();

  exports["default"] = WOW;
  module.exports = exports['default'];
});

/***/ }),

/***/ "./src/js/components/content.js":
/*!**************************************!*\
  !*** ./src/js/components/content.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* eslint-disable */

/* eslint-enable */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  // Maori language class to add lang type
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('.maori').attr('lang', 'mi');
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('.nonvisual-indicator').addClass('sr-only').removeClass('nonvisual-indicator');
});

/***/ }),

/***/ "./src/js/components/form.js":
/*!***********************************!*\
  !*** ./src/js/components/form.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* eslint-disable */

/* eslint-enable */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('input.number').on('keyup', function () {
    var value = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).val();
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).val(value.replace(/[a-zA-Z]/g, ''));
  });
  /**
   * Apply a Bootstrap 3 form structure context to the jQuery validator plugin in userforms
   */

  jquery__WEBPACK_IMPORTED_MODULE_0___default()('.userform, .comments-holder-container form').each(function () {
    if (typeof jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).validate === 'function') {
      var validatorSettings = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).validate().settings;

      validatorSettings.highlight = function (element) {
        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).prop('type') === 'checkbox' || jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).prop('type') === 'radio') {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).parents('.form-group').find('.form-check input').addClass('is-invalid');
        } else {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).addClass('is-invalid');
        }

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).closest('.form-group').addClass('has-error');
      };

      validatorSettings.unhighlight = function (element) {
        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).prop('type') === 'checkbox' || jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).prop('type') === 'radio') {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).parents('.form-group').find('.form-check input').removeClass('is-invalid');
        } else {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).removeClass('is-invalid');
        }

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).closest('.form-group').removeClass('has-error');
      };

      validatorSettings.errorElement = 'span';
      validatorSettings.errorClass = 'invalid-feedback';

      validatorSettings.errorPlacement = function (error, element) {
        if (element.parent('.input-group').length || element.prop('type') === 'checkbox' || element.prop('type') === 'radio') {
          // Handle lists of checkboxes/radios by looking for all children
          error.insertAfter(element.parents('.form-group:first').children().last());
        } else {
          error.insertAfter(element);
        }
      };
    }
  }); // Comments Module - Accesibility for Replies

  var $commentReplyLink = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.comment-reply-link');
  $commentReplyLink.click(function () {
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('aria-expanded', function (i, val) {
      return val !== 'true';
    });
  });
});

/***/ }),

/***/ "./src/js/components/img.js":
/*!**********************************!*\
  !*** ./src/js/components/img.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* eslint-disable */

/* eslint-enable */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('#main img').addClass('img-responsive');
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('#main div .captionImage.right').removeClass('right').addClass('pull-right');
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('#main div .captionImage.left').removeClass('left').addClass('pull-left');
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('#main div .captionImage.center').removeClass('center').addClass('center-block');
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('#main img.center').removeClass('center').addClass('center-block');
});

/***/ }),

/***/ "./src/js/components/mods.js":
/*!***********************************!*\
  !*** ./src/js/components/mods.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var owl_carousel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! owl.carousel */ "./node_modules/owl.carousel/dist/owl.carousel.js");
/* harmony import */ var owl_carousel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(owl_carousel__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var wow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wow.js */ "./node_modules/wow.js/dist/wow.js");
/* harmony import */ var wow_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(wow_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var apexcharts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! apexcharts */ "./node_modules/apexcharts/dist/apexcharts.common.js");
/* harmony import */ var apexcharts__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(apexcharts__WEBPACK_IMPORTED_MODULE_3__);
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
/* eslint-disable */






/* harmony default export */ __webpack_exports__["default"] = (function () {
  var hasManyFormFieldValueObj = {},
      hasOneFormFieldValueObj = {};
  var getFormFirstMonth = [];
  jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
    initializeDocument();
  });

  function initializeDocument() {
    //Section Settings
    sectionBanner();
    sectionCarousel();
    animation(); //Dashboard Settings

    dataTables();
    tableActionBtn(); //DatePicker

    datePickerSettings(); //Dashboard

    populateDashboardWhenPageLoads();
    dropdownPeriodSelector();
    dropdownModuleSelector(); //Form

    moduleForm();
    removeFieldError(); //dropdownEthnicity();
    //Admin Front-end

    adminDataTables();
  }

  function animation() {
    var wow = new wow_js__WEBPACK_IMPORTED_MODULE_2___default.a({
      offset: 300,
      // distance to the element when triggering the animation (default is 0)
      mobile: true,
      animateClass: 'animate__animated',
      // animation css class (default is animated)
      live: true,
      // act on asynchronously loaded content (default is true)
      callback: function callback(section) {//section.classList.add('tex');
      },
      scrollContainer: null // optional scroll container selector, otherwise use window

    });
    wow.init();
  }

  function sectionBanner() {
    var sliderBanner = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.SliderBanner');

    if (sliderBanner.length > 0) {
      sliderBanner.find('.owl-carousel').owlCarousel({
        items: 1,
        dots: false
      });
    }
  }

  function sectionCarousel() {
    var carousel = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#Carousel');

    if (carousel.length > 0) {
      carousel.owlCarousel({
        items: 4,
        loop: true,
        nav: true,
        lazy: true
      });
    }
  }

  function dataTables() {
    var dataTable,
        table = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#datatable');

    if (table.length > 0) {
      dataTable = table.DataTable({
        "columnDefs": [{
          "targets": 0,
          "data": null,
          "orderable": false,
          "className": 'details-control',
          "defaultContent": ' '
        }]
      });
      jquery__WEBPACK_IMPORTED_MODULE_0___default()('#datatable tbody').on('click', 'td.details-control', function () {
        var tr = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest('tr');
        var row = dataTable.row(tr);

        if (row.child.isShown()) {
          // This row is already open - close it
          row.child.hide();
          tr.removeClass('shown');
        } else {
          // Open this row
          row.child(dataTableFormat(row.data()), 'p-0').show();
          tr.addClass('shown');
        }
      });
    }
  }

  function dataTableFormat(rowData) {
    var div = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div/>').addClass('loading child-table').text('Loading...');
    callAPIEndpoint('ajax/populateTableRowDetails', 'POST', 'id=' + rowData[1], function (result) {
      if (!result.error) {
        var data = result.data;
        console.log(data);

        if (data.length > 0) {
          var arrangedLabel = [];
          var arrangeData = [];
          var table = '<table class="child-infoTable" cellpadding="5" cellspacing="0" border="0" style="padding-left:50px;">';
          var ctr = 1;
          data.forEach(function (i) {
            //let id   = i.id;
            var name = i.name;
            var responses = i.responses;

            if (ctr === 1) {
              table += '<tr><td><p class="response-title">#</p></td>';
              responses.forEach(function (i) {
                var label = i.label;
                table += '<td><p class="response-title">' + label + '</p></td>';
                arrangedLabel.push(label);
              });
            }

            table += '<tr><td class="item-title"><p class="response-data">' + name + '</p></td>'; //Arrange responses

            responses.forEach(function (i) {
              var label = i.label;
              var response = i.response;
              var ind = arrangedLabel.indexOf(label);
              arrangeData[ind] = response;
            }); //Arranged result

            if (arrangeData.length > 0) {
              arrangeData.forEach(function (i) {
                var response = i;

                if (Array.isArray(response)) {
                  table += '<td><p class="response-data">';
                  response.forEach(function (i) {
                    table += i.name + '<br><b>' + i.subresponse + '</b><br>';
                  });
                  table += '</td>';
                } else {
                  table += '<td><p class="response-data">' + response + '</p></td>';
                }
              });
            }

            table += '<td><button class="tbl-action-btn" data-type="edit-row" data-id="' + data.id + '"><i class="fad fa-file-edit"></i></button></td>';
            table += '</tr>';
            ctr = ctr + 1;
          });
          table += '</table>';
          div.html(table);
        } else {
          var _table = '<table class="child-infoTable" cellpadding="5" cellspacing="0" border="0" style="padding-left:50px;">' + '<tr><td><p class="mb-0 medium">No data available in table</p></td>' + '</table>';

          div.html(_table);
        }
      } else {
        var _table2 = '<table class="child-infoTable" cellpadding="5" cellspacing="0" border="0" style="padding-left:50px;">' + '<tr><td><p class="mb-0">No data available in table</p></td>' + '</table>';

        div.html(_table2);
      }
    });
    return div;
  }

  function tableActionBtn() {
    var table = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#datatable');
    var btnAction = table.find('.tbl-action-btn');
    btnAction.click(function () {
      var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('data-id');
      var moduleID = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('data-module-id');
      var actionType = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('data-type');

      if (actionType === 'edit-row') {
        callAPIEndpoint('ajax/addEntryToExistingSubmission', 'POST', 'id=' + id + '&moduleID=' + moduleID, function (result) {
          if (!result.error) {
            if (result.data.length > 0) {
              var data = result.data;

              var _moduleForm = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#moduleForm');

              var recordCount = 10 - data[2].record_count;

              _moduleForm.find('#limit').val(recordCount);

              _moduleForm.find('.modal-nav button').each(function (i) {
                if (i !== 0) {
                  if (i > recordCount) {
                    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).addClass('disabled');
                  }
                }
              });
            }
          }
        });
      }
    });
  }

  function createForm(result, moduleID) {
    var data = result.data;
    var moduleDetails = data[1];
    var recordCount = data[2].record_count;
    var ctr = 10 - recordCount;
    var modal = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.addEntry-modal');
    var modalNav = modal.find('.modal-nav');
    var modalBody = modal.find('.modal-body');
    modalBody.empty();

    if (recordCount < 10) {//Alert all fields are filled-up!
    }

    var splitStartDate = moduleDetails.start.split('-');
    var splitEndDate = moduleDetails.end.split('-');
    var sortedStartDate = splitStartDate[2] + '/' + splitStartDate[1] + '/' + splitStartDate[0];
    var sortedEndDate = splitEndDate[2] + '/' + splitEndDate[1] + '/' + splitEndDate[0];
    var modalNavContent = '';
    var modalBodyContent = '<div class="container">' + '<div class="row">' + '<div class="col-md-12">' + '<div class="modal-title text-center theme-text">' + '<h1 tabindex="-1" id="moduleFormModalLabel">Module: ' + moduleDetails.name + '</h1>' + '<p>' + moduleDetails.type + '</p>' + '<p class="mb-md-5"><small>' + sortedStartDate + ' - ' + sortedEndDate + '</small></p>' + '<input type="hidden" class="start-period" name="start-period" value="' + sortedStartDate + '">' + '<input type="hidden" class="end-period" name="end-period" value="' + sortedEndDate + '">' + '<input type="hidden" class="module-id" name="module-id" value="' + moduleID + '" id="module-id">' + '</div>' + '</div>';
    modalBodyContent += '<div class="col-md-12">';
    data[0].forEach(function (i) {
      var id = i.id;
      var form = i.formType;
      var fields = i.fields;

      if (form === 'single') {
        modalBodyContent += fieldType(id, fields, form);
      } else {
        for (var limit = 1; limit < ctr; limit++) {
          modalBodyContent += fieldType(id, fields, form, limit);
        }
      }
    });
    modalBodyContent += '</div>';
    modalBodyContent += '</div>' + '</div>';
    modalBody.append(modalBodyContent);
  }

  function fieldType(id, fields, form, pos) {
    var formType = 'multiple-form',
        fieldItem = '';
    if (form === 'single') formType = 'single-form active';
    fieldItem += '<div class="form-container module-form ' + formType + '">';
    fields.forEach(function (field) {
      var extraFields = field.extras;
      var marginBottom = 'mb-4';
      if (field.type === 'Separator') marginBottom = '';
      fieldItem += '<div class="form-group row ' + marginBottom + '" data-type="' + field.type + '">';

      if (field.type !== 'Title' && field.type !== 'Text' && field.type !== 'Separator') {
        fieldItem += '<label class="form-label col-sm-12 mb-md-3">' + field.label + '</label>';
      }

      fieldItem += '<div class="col-md-12">';

      if (field.type === 'Title') {
        fieldItem += '<div class="form-title"><span>' + field.name + '</span></div>';
      }

      if (field.type === 'Text') {
        fieldItem += '<div class="form-freetext">' + field.content + '</div>';
      }

      if (field.type === 'Separator') {
        fieldItem += '<hr>';
      }

      if (field.type === 'Textbox') {
        fieldItem += '<input type="text" class="form-control"><div class="invalid-feedback">Please provide a valid input.</div>';
      }

      if (field.type === 'UserAccount') {
        var user = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.profile--name span').text();
        fieldItem += '<input type="text" class="form-control" value="' + user + '" disabled>';
      }

      if (field.type === 'Date') {
        fieldItem += '<input type="text" class="form-control" name="singledatepicker"><div class="invalid-feedback">Please provide a valid input.</div>';
      }

      if (field.type === 'RadioButton') {
        fieldItem += '<div class="radio-selector" tabindex="-1">';

        if (extraFields) {
          extraFields.forEach(function (item) {
            fieldItem += '<div class="radio-item">' + '<input type="radio" name="' + field.id + '' + pos + '-mcs" value="' + item.name + '" class="styled-radio" id="radio-' + item.id + '' + pos + '">' + '<label for="radio-' + item.id + '' + pos + '" class="styled-radio--label">' + '<span><svg width="12px" height="9px" viewbox="0 0 12 9"><polyline points="1 5 4 8 11 1"></polyline></svg></span>' + '<span>' + item.name + '</span>' + '</label>' + '</div>';
          });
        }

        fieldItem += '</div>';
      }

      if (field.type === 'Dropdown') {
        fieldItem += '<div class="dropdown-selector">';
      }

      fieldItem += '</div>';
      fieldItem += '</div>';
    });
    fieldItem += '<div class="action-btn text-right mt-5">' + '<button class="btn btn-close mr-2" data-dismiss="modal" aria-label="Close"><span class="">Close</span></button>' + '<button class="btn btn-primary btn-modal btn-next" data-type="next"><span class="mr-3">Next</span><i class="fad fa-long-arrow-right fa-lg"></i></button>' + '</div>';
    fieldItem += '</div>';
    return fieldItem;
  }

  function datePickerSettings() {
    var datePickerField = jquery__WEBPACK_IMPORTED_MODULE_0___default()('input[name="singledatepicker"]');

    if (datePickerField.length > 0) {
      datePickerField.daterangepicker({
        singleDatePicker: true,
        locale: {
          format: 'DD/MM/YYYY'
        }
      });
    }
  }

  function moduleForm() {
    var moduleForm = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#moduleForm');

    if (moduleForm.length > 0) {
      var modalHeaderNav = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.modal-nav');
      var modalFormSubmit = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#alert-modal');
      modalHeaderNav.find('button').click(function () {
        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).hasClass('finished')) {
          var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('id');
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).siblings('button').removeClass('active');
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).addClass('active');
          moduleForm.find('.module-form').each(function (i) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).removeClass('active');

            if (id === 'start' && i === 0) {
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).addClass('active');
            }

            if (id === i) {
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).addClass('active');
            }
          });
        }
      });
      moduleForm.find('.action-btn .btn-modal').click(function () {
        var parentElement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).parent('.action-btn').parent('.module-form.active');
        var btnType = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('data-type');

        if (btnType === 'next' || btnType === 'submit-ready') {
          if (validateModuleFormFields()) {
            if (btnType === 'next') {
              var nextElement = parentElement.addClass('finished').removeClass('active').next();
              nextElement.addClass('active'); //modalHeaderNav

              modalHeaderNav.find('button.active').removeClass('active').addClass('finished').next().addClass('active');
              jquery__WEBPACK_IMPORTED_MODULE_0___default()('.modal-title h1').focus();
            } else {
              //submission modal
              modalFormSubmit.modal('show');
            }
          }
        }

        if (btnType === 'back') {
          parentElement.removeClass('active').prev().addClass('active');
          modalHeaderNav.find('button.active').removeClass('active').prev().addClass('active');
        }
      });
      modalFormSubmit.find('.action-btn .btn-modal').click(function () {
        var btnType = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('data-type');

        if (btnType === 'submit') {
          modalFormSubmit.find('button').addClass('disabled').attr("disabled", true);
          modalFormSubmit.find('.modal-body').append('' + '<div class="text-center">\n' + '  <div class="spinner-border text-primary" role="status">\n' + '    <span class="sr-only">Loading...</span>\n' + '  </div>\n' + '</div>');
          setTimeout(function () {
            moduleFormSubmission();
          }, 1000);
        }
      }); //Ethnicity

      moduleForm.find('.module-form').each(function () {
        var dropdown = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('.dropdown-ethnicity');
        dropdown.on('show.bs.dropdown', function () {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()('.dropdown-menu', this).find('.dropdown-item').click(function () {
            var selector = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('span');
            dropdown.find('.dropdown-toggle span').text(selector.text()).attr('data-id', selector.data('id'));
          });
        });
      });
    }
  }

  function validateModuleFormFields() {
    var isValid = true;
    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.module-form.active').find('.form-group').each(function () {
      var formField = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
      var fieldType = formField.data('type');

      if (fieldType === 'Date') {
        if (!dateValidator(formField, fieldType)) {
          isValid = false;
        }
      } else {
        if (!validateFields(formField, fieldType)) {
          isValid = false;
        }
      }
    });
    return isValid;
  }

  function validateFields(formField, fieldType) {
    var isValid = true;

    if (fieldType === 'UserAccount' || fieldType === 'Textbox') {
      var field = formField.find('.form-control');

      if (!field.val()) {
        field.addClass('is-invalid error-shake').focus();
        setTimeout(function () {
          field.removeClass('error-shake');
        }, 1000);
        isValid = false;
      }
    }

    if (fieldType === 'RadioButton') {
      var selector = formField.find('.radio-selector');
      var radioFields = selector.find('input[type="radio"]:checked');

      if (radioFields.length < 1) {
        selector.addClass('has-error error-shake').focus();
        setTimeout(function () {
          selector.removeClass('error-shake');
        }, 1000);
        isValid = false;
      } else {
        selector.removeClass('has-error');
      }
    }

    if (fieldType === 'Checkbox') {
      var _selector = formField.find('.checkbox-selector');

      var checkboxFields = _selector.find('input[type="checkbox"]:checked');

      if (checkboxFields.length < 1) {
        _selector.addClass('has-error error-shake').focus();

        setTimeout(function () {
          _selector.removeClass('error-shake');
        }, 1000);
        isValid = false;
      } else {
        _selector.removeClass('has-error');
      }
    }

    if (fieldType === 'MultipleTextbox') {
      var greaterNum = [];
      var multiTextbox = formField.find('.multiple-textbox .textbox-item');

      if (multiTextbox.attr('data-type') === 'compare') {
        multiTextbox.each(function () {
          var formElement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
          var field = formElement.find('.form-control');

          if (!field.val()) {
            field.addClass('is-invalid error-shake').focus();
            field.next('.invalid-feedback').text('Please provide a valid input.');
            setTimeout(function () {
              field.removeClass('error-shake');
            }, 1000);
            isValid = false;
          } else {
            if (field.attr('data-type') === 'isGreaterThan') {
              greaterNum.push(field.val());
            } else {
              if (parseInt(field.val()) > parseInt(greaterNum[0])) {
                field.addClass('is-invalid error-shake').focus();
                field.next('.invalid-feedback').text('Input number should be less than ' + greaterNum[0]);
                setTimeout(function () {
                  field.removeClass('error-shake');
                }, 1000);
                isValid = false;
              }
            }
          }
        });
      } else {
        multiTextbox.each(function () {
          var formElement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
          var field = formElement.find('.form-control');

          if (!field.val()) {
            field.addClass('is-invalid error-shake').focus();
            setTimeout(function () {
              field.removeClass('error-shake');
            }, 1000);
            isValid = false;
          }
        });
      }
    }

    return isValid;
  }

  function dateValidator(formField, fieldType) {
    var isValid = true;

    if (fieldType === 'Date') {
      var field = formField.find('.form-control');
      var dateValParts = field.val().split("/");
      var dateVal = new Date(+dateValParts[2], dateValParts[1] - 1, 1);
      var startDateParts = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.start-period').val().split("/");
      var periodStartDate = new Date(+startDateParts[2], startDateParts[1] - 1, +startDateParts[0]);
      var endDateParts = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.end-period').val().split("/");
      var periodEndDate = new Date(+endDateParts[2], endDateParts[1] - 1, +endDateParts[0]);

      if (dateVal < periodStartDate || dateVal > periodEndDate) {
        field.addClass('is-invalid error-shake').focus();
        field.next('.invalid-feedback').text('Selected dispensing date is out of range with your current module period.');
        setTimeout(function () {
          field.removeClass('error-shake');
        }, 1000);
        isValid = false;
      } else {
        var month = dateValParts[1];
        var moduleID = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#module-id').val();

        if (getFormFirstMonth.length < 1) {
          //Check date exist in member's submission
          callAPIEndpoint('ajax/checkModuleFormDateExist', 'POST', 'moduleID=' + moduleID + '&month=' + month, function (result) {
            if (result.error !== true) {
              getFormFirstMonth.push(month);
            } else {
              field.addClass('is-invalid error-shake').focus();
              field.next('.invalid-feedback').text(result.message);
              setTimeout(function () {
                field.removeClass('error-shake');
              }, 1000);
              isValid = false;
            }
          });
        } else {
          console.log(month);
          console.log(getFormFirstMonth[0]);

          if (getFormFirstMonth[0] !== month) {
            // Check form selected dispensing date ("Month") is the same as other forms.
            field.addClass('is-invalid error-shake').focus();
            field.next('.invalid-feedback').text('Selected dispensing date "month" should be the same with other forms dispensing date.');
            setTimeout(function () {
              field.removeClass('error-shake');
            }, 1000);
            isValid = false;
          }
        }
      }

      return isValid;
    }
  }

  function removeFieldError() {
    var moduleForm = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#moduleForm');

    if (moduleForm.length > 0) {
      var checkbox = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.styled-checkbox');
      var radio = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.styled-radio');
      var inputText = jquery__WEBPACK_IMPORTED_MODULE_0___default()('input[type="text"].form-control');
      var inputNumber = jquery__WEBPACK_IMPORTED_MODULE_0___default()('input[type="number"].form-control');
      var singleDate = jquery__WEBPACK_IMPORTED_MODULE_0___default()('input[name="singledatepicker"].form-control');
      var textArea = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.form-textarea'); //checkbox

      if (checkbox) {
        checkbox.click(function () {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).parent('.checkbox-item').parent('.checkbox-selector').removeClass('has-error');
        });
      } //radio


      if (radio) {
        radio.click(function () {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).parent('.radio-item').parent('.radio-selector').removeClass('has-error');
        });
      } //textfield


      if (inputText) {
        inputText.keydown(function () {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).removeClass('is-invalid');
        });
      } //textfield number


      if (inputNumber) {
        inputNumber.keydown(function () {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).removeClass('is-invalid');
        });
      } //date


      if (singleDate) {
        singleDate.change(function () {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).removeClass('is-invalid');
        });
      } //textarea


      if (textArea) {
        textArea.keydown(function () {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).removeClass('is-invalid');
        });
      }
    }
  }

  function moduleFormSubmission() {
    var formModuleID = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#module-id').val();
    var pho = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.pho').val();
    var practiceID = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.practiceID').val();
    var moduleForms = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.module-form');
    var hasOneFormValueStorage = [];
    moduleForms.each(function (i) {
      var hasManyFormValueStorage = [];
      var form = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);

      if (form.hasClass('finished') || form.hasClass('active')) {
        var FormFields = form.find('.form-group');
        FormFields.each(function () {
          var field = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
          var fieldType = field.attr('data-type');
          var fieldLabel = field.find('.form-label').text();
          var fieldLabelID = field.find('.form-label').data('id');
          /*
            User account, Textbox, Textarea & Date
           */

          if (fieldType === 'UserAccount' || fieldType === 'Textbox' || fieldType === 'Date' || fieldType === 'Textarea') {
            var fieldValue = field.find('.form-control');

            if (form.hasClass('single-form')) {
              hasOneFormValueStorage.push(fieldValue.val());
            }

            if (form.hasClass('multiple-form')) {
              hasManyFormValueStorage.push([fieldLabelID, fieldLabel, fieldValue.val()]);
            }
          }
          /*
            Ethnicity & Dropdown
          */


          if (fieldType === 'Ethnicity' || fieldType === 'Dropdown') {
            var _fieldValue = field.find('.dropdown-selector .dropdown-toggle span');

            if (form.hasClass('single-form')) {
              hasOneFormValueStorage.push(_fieldValue.text());
            }

            if (form.hasClass('multiple-form')) {
              hasManyFormValueStorage.push([fieldLabelID, fieldLabel, _fieldValue.text()]);
            }
          }
          /*
            Radio Button
          */


          if (fieldType === 'RadioButton') {
            var radioItems = field.find('.radio-selector .radio-item');
            radioItems.each(function () {
              var fieldValue = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('input[type="radio"]:checked').val();

              if (fieldValue) {
                if (form.hasClass('single-form')) {
                  hasOneFormValueStorage.push(fieldValue.text());
                }

                if (form.hasClass('multiple-form')) {
                  hasManyFormValueStorage.push([fieldLabelID, fieldLabel, fieldValue]);
                }
              }
            });
          }
          /*
            Checkbox
          */


          if (fieldType === 'CheckBox') {
            var checkboxItems = field.find('.checkbox-selector .checkbox-item');
            checkboxItems.each(function () {
              var fieldValue = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('input[type="checkbox"]:checked').val();

              if (fieldValue) {
                if (form.hasClass('single-form')) {
                  hasOneFormValueStorage.push(fieldValue.text());
                }

                if (form.hasClass('multiple-form')) {
                  hasManyFormValueStorage.push([fieldLabelID, fieldLabel, fieldValue]);
                }
              }
            });
          }
          /*
            Multiple Textbox
          */


          if (fieldType === 'MultipleTextbox') {
            var textboxItem = field.find('.multiple-textbox');
            var textboxArray = [];
            textboxItem.find('.textbox-item').each(function () {
              var textboxLabel = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('label').text();
              var textboxVal = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('.form-control');
              textboxArray.push([textboxLabel, textboxVal.val()]);
            });

            if (form.hasClass('multiple-form')) {
              hasManyFormValueStorage.push([fieldLabelID, fieldLabel, textboxArray]);
            }
          }
        });
        hasOneFormFieldValueObj = hasOneFormValueStorage;

        if (form.hasClass('multiple-form')) {
          hasManyFormFieldValueObj[i] = hasManyFormValueStorage;
        }
      }
    });
    var strHasOneFormVal = JSON.stringify(hasOneFormFieldValueObj);
    var strHasManyFormVal = JSON.stringify(hasManyFormFieldValueObj);
    callAPIEndpoint('ajax/submitModuleForm', 'POST', 'formModuleID=' + formModuleID + '&practiceID=' + practiceID + '&pho=' + pho + '&hasOneFormValues=' + encodeURIComponent(strHasOneFormVal) + '&hasManyFormValues=' + encodeURIComponent(strHasManyFormVal), function (result) {
      console.log(result);

      if (!result.error) {
        setTimeout(function () {
          location.reload();
        }, 100);
      } else {
        console.log('Error caught on Form Submission: ' + result.error);
      }
    });
  }

  function dropdownPeriodSelector() {
    var periodSelector = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.period-selector');

    if (periodSelector.length > 0) {
      periodSelector.on('show.bs.dropdown', function () {
        var ctr = 0;
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.dropdown-menu', this).find('.dropdown-item').click(function () {
          if (ctr <= 0) {
            var selector = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('span');
            periodSelector.find('.dropdown-toggle span').text(selector.text()).attr('data-id', selector.attr('data-id')).attr('data-period-id', selector.attr('data-period-id')); //Change Dashboard Period

            var periodRange = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.datepicker-range');
            var startDate = selector.attr('data-period-start');
            var endDate = selector.attr('data-period-end');
            periodRange.val(startDate + ' - ' + endDate);
            callAPIEndpoint('ajax/populateDashboardByPeriod', 'POST', 'id=' + selector.attr('data-id') + '&periodID=' + selector.attr('data-period-id'), function (result) {
              console.log(result);
              setDropdownModuleSelector(result);
            });
          }

          ctr = ctr + 1;
        });
      });
    }
  }

  function setDropdownModuleSelector(result) {
    var data = result.data;
    var moduleSelector = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.module-selector');
    var dropdownToggle = moduleSelector.find('.dropdown-toggle');
    var dropdownMenu = moduleSelector.find('.dropdown-menu');
    var firstMenuItem = dropdownMenu.find('.dropdown-item').first();
    var lastMenuItem = dropdownMenu.find('.dropdown-item').last();
    dropdownToggle.find('span').text(data.clinicalmodule).attr({
      'data-id': data.clinicalmoduleid,
      'data-moduletype-id': 1
    });
    dropdownToggle.find('i').attr('class', data.clinicalmoduleIcon);
    firstMenuItem.find('span').text(data.clinicalmodule).attr({
      'data-id': data.clinicalmoduleid,
      'data-moduletype-id': 1
    });
    firstMenuItem.find('i').attr('class', data.clinicalmoduleIcon);

    if (data.prescribingindicator) {
      lastMenuItem.find('span').text(data.prescribingindicator).attr({
        'data-id': data.prescribingindicatorid,
        'data-moduletype-id': 2
      });
      lastMenuItem.find('i').attr('class', data.prescribingindicatorIcon);
    }

    var dashboard = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.dashboard-section');
    var dashboardItem = '';
    callAPIEndpoint('ajax/populateDashboard', 'POST', 'moduleTypeID=1' + '&moduleID=' + data.clinicalmoduleid, function (result) {
      console.log(result);

      if (!result.error) {
        if (result.data.length > 0) {
          setDashboardItem(result);
        } else {
          dashboard.empty();
          dashboardItem += '<div class="col-md-12 pb-3 pt-3 dashboard-section--item"><h5 class="text-center">No data has been found!</h5></div>';
          dashboard.append(dashboardItem);
        }
      } else {
        dashboard.empty();
      }
    });
  }

  function dropdownModuleSelector() {
    var dashboardHeader = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.dashboard-header');

    if (dashboardHeader.length > 0) {
      var dropdown = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.module-selector');
      dropdown.on('show.bs.dropdown', function () {
        var ctr = 0;
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('.dropdown-menu', this).find('.dropdown-item').click(function (i) {
          if (ctr <= 0) {
            var selectedModule = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
            var selectedModuleSpan = selectedModule.find('span');
            var dropdownBtn = dropdown.find('.dropdown-toggle');
            var moduleID = selectedModuleSpan.attr('data-id');
            var moduleTypeID = selectedModuleSpan.attr('data-moduletype-id');
            dropdownBtn.find('span').text(selectedModuleSpan.text()).attr({
              'data-id': moduleID,
              'data-moduletype-id': moduleTypeID
            });
            dropdownBtn.find('i').attr('class', selectedModule.find('i').attr('class'));
            callAPIEndpoint('ajax/populateDashboard', 'POST', 'moduleTypeID=' + moduleTypeID + '&moduleID=' + moduleID, function (result) {
              console.log(result);

              if (!result.error) {
                if (result.data.length > 0) {
                  setDashboardItem(result);
                } else {
                  console.log('Alert: No data found!');
                }
              }
            });
          }

          ctr = ctr + 1;
        });
      });
    }
  }

  function setDashboardItem(result) {
    var dashboard = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.dashboard-section'); //if dashboard exist in Page

    var dashboardItem = '';
    var data = result.data;
    dashboard.empty();

    if (dashboard.length > 0) {
      data.forEach(function (i) {
        dashboardItem += '<div class="col-md-6 pb-3 pt-3 dashboard-section--item" data-title="' + i.name + '" data-id="' + i.id + '">' + '<div class="card">' + '<div class="card-header">' + '<div class="card-title">' + i.name + '</div>' + '</div>' + '<div class="body">' + '<div class="chart-container" id="chart-id' + i.id + '"></div>' + '</div>' + '</div>' + '</div>';
      });
      dashboard.append(dashboardItem);
      setTimeout(function () {
        populateDashboardWhenPageLoads();
      }, 100);
    }
  }

  function populateDashboardWhenPageLoads() {
    var moduleSelector = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.module-selector #module-items span');
    var moduleID = moduleSelector.attr('data-id');
    var moduleTypeID = moduleSelector.attr('data-moduletype-id');
    var dashboard = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.dashboard-section'); //if dashboard exist in Page

    if (dashboard.length > 0) {
      dashboard.find('.dashboard-section--item').each(function () {
        var dashboardItemId = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).attr('data-id');
        callAPIEndpoint('ajax/populateDashboardItem', 'POST', 'dashboardItemId=' + dashboardItemId + '&moduleTypeID=' + moduleTypeID + '&moduleID=' + moduleID, function (result) {
          if (!result.error) {
            if (result.data.length) {
              setTimeout(function () {
                populateChart(dashboardItemId, result.data);
              }, 100);
            }
          } else {
            console.log('Error caught: ' + result.error);
          }
        });
      });
    }
  }

  function dateConverter(date) {
    var dateParts = date.split("/");
    return new Date(+dateParts[2], dateParts[1] - 1, +dateParts[0]);
  }

  function populateChart(id, output) {
    var data = output;
    var arrayObj = {},
        sortedResponses = [];
    var userType = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.profile .profile--name').data('user-type');
    data.forEach(function (item) {
      var dataArray = item[0],
          moduleType = item[1];
      var dateObject = Object.keys(dataArray);
      var ordered = {};
      dateObject.sort(function (a, b) {
        return dateConverter(a) - dateConverter(b);
      }).forEach(function (key) {
        ordered[key] = dataArray[key];
      });
      var dates = Object.keys(ordered);
      dates.forEach(function (i) {
        var responses = ordered[i];

        if (userType === 'General Practice') {
          if (moduleType === 'Clinical Module') {
            var count = {};

            if (responses.includes('N/A') || responses.includes('Yes')) {
              responses.forEach(function (i) {
                if (i !== 'No') {
                  count['Yes&N/A'] = (count['Yes&N/A'] || 0) + 10;
                } else {
                  count[i] = (count[i] || 0) + 10;
                }
              });

              if (!responses.includes('No')) {
                count['No'] = 0;
              }
            } else {
              count['Yes&N/A'] = 0;

              if (responses.includes('No')) {
                responses.forEach(function (i) {
                  count[i] = (count[i] || 0) + 10;
                });
              } else {
                count['No'] = 0;
              }
            }

            arrayObj[i] = count;
          } else {
            //Prescribing Indicator
            arrayObj[i] = responses[0];
          }
        } else {
          // Pharmacy
          if (moduleType === 'Clinical Module') {
            var _count = {};

            if (responses.includes('N/A') || responses.includes('No')) {
              responses.forEach(function (i) {
                if (i !== 'Yes') {
                  _count['No'] = (_count['No'] || 0) + 10;
                } else {
                  _count[i] = (_count[i] || 0) + 10;
                }
              });

              if (!responses.includes('Yes')) {
                _count['Yes'] = 0;
              }
            } else {
              _count['No'] = 0;

              if (responses.include('Yes')) {
                responses.forEach(function (i) {
                  _count[i] = (_count[i] || 0) + 10;
                });
              } else {
                _count['Yes'] = 0;
              }
            }

            arrayObj[i] = _count;
          } else {
            //Prescribing Indicator
            arrayObj[i] = responses[0];
          }
        }
      });

      for (var _i = 0, _Object$entries = Object.entries(arrayObj); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        var sortedDateIndex = dates.indexOf(key);
        sortedResponses[sortedDateIndex] = value;
      }

      if (sortedResponses.length) {
        generateChart(id, dates, sortedResponses, moduleType);
      }
    });
  }

  function generateChart(id, dates, responses, type) {
    var result = {};
    var data = [];

    for (var i = 0; i < responses.length; i++) {
      var obj = responses[i];

      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (result[key]) {
            result[key].push(obj[key]);
          } else {
            result[key] = [obj[key]];
          }
        }
      }
    }

    var ctr = 0;

    var _formatter,
        max,
        getHighestNum = 20;

    var names = Object.keys(result);
    names.forEach(function (i) {
      if (ctr === 0) {
        getHighestNum = Math.max.apply(null, result[i]);
      }

      if (type === 'Clinical Module') {
        if (i === 'No') {
          data[1] = {
            'name': i,
            'data': result[i]
          };
        } else {
          data[0] = {
            'name': i,
            'data': result[i]
          };
        }
      } else {
        data.push({
          'name': i,
          'data': result[i]
        });
      }

      ctr = ctr + 1;
    });

    if (type === 'Clinical Module') {
      max = 100;
      _formatter = '%';
    } else {
      max = getHighestNum;
      _formatter = '';
    }

    var options = {
      chart: {
        type: 'line'
      },
      stroke: {
        curve: 'smooth'
      },
      markers: {
        size: 3
      },
      series: data,
      xaxis: {
        categories: dates,
        type: "category"
      },
      yaxis: {
        min: 0,
        max: max,
        type: 'numeric',
        tickAmount: 5,
        labels: {
          formatter: function formatter(value) {
            return value.toFixed(0) + _formatter;
          }
        }
      }
    };
    var chart = new apexcharts__WEBPACK_IMPORTED_MODULE_3___default.a(document.querySelector("#chart-id" + id), options);
    chart.render();
  }

  function adminDataTables() {
    var adminPage = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.AdminPage');

    if (adminPage.length > 0) {
      var filters = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.table-filters');
      var filterItem = filters.find('.filter-item');
      filterItem.on('show.bs.dropdown', function () {
        var thisDropdown = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
        var dropdownType = thisDropdown.attr('data-type');
        var dropdownMenu = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.dropdown-menu', this);
        var ctr = 0;
        dropdownMenu.find('.dropdown-item').click(function () {
          if (ctr <= 0) {
            var btnSpan = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).find('span');
            thisDropdown.find('.dropdown-toggle span').text(btnSpan.text()).attr('data-id', btnSpan.attr('data-id'));
            callAPIEndpoint('ajax/get' + dropdownType, 'POST', 'id=' + btnSpan.attr('data-id'), function (result) {
              console.log(result);

              if (!result.error) {
                var data = result.data;

                if (data.length > 0) {
                  if (dropdownType !== 'module') {
                    appendDropdown(filterItem, dropdownType, data);
                  } else {
                    generateAdminDataTables(data);
                  }
                }
              }
            });
          }

          ctr = ctr + 1;
        });
      });
    }
  }

  function appendDropdown(filterItem, dropdownType, data) {
    filterItem.each(function () {
      var dropdownFilter = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);

      if (dropdownType === 'memberType') {
        if (dropdownFilter.attr('data-type') === 'period') {
          dropdownItem(dropdownFilter, data);
        }
      }

      if (dropdownType === 'period') {
        if (dropdownFilter.attr('data-type') === 'module') {
          dropdownItem(dropdownFilter, data);
        }
      }
    });
  }

  function dropdownItem(dropdown, data) {
    var dropdownItem = '';
    data.forEach(function (i) {
      dropdownItem += '<a class="dropdown-item" role="button"><span data-id="' + i.id + '">' + i.name + '</span></a>';
    });
    dropdown.find('.dropdown-menu').empty().append(dropdownItem);
  }

  function generateAdminDataTables(data) {
    var mainHeader = [{
      'data': 'Module',
      'name': 'Module'
    }, {
      'data': 'PracticeID',
      'name': 'PracticeID'
    }, {
      'data': 'PHO',
      'name': 'PHO'
    }];
    var extraHeader = Object.values(data[1]);
    var setTableHeader = mainHeader.concat(extraHeader);
    var bodyContent = [],
        tableBody = data[0];
    var tableName = '#tableAdmin';
    var tableContainer = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.table-container');
    /**
     * Reset DataTables
     */

    tableContainer.empty();
    tableContainer.append('<table id="tableAdmin" class="display nowrap" style="width: 100%;"><thead><tr></tr></thead><tbody><tr></tr></tbody></table>');
    tableBody.forEach(function (i) {
      var extraResponses = {};
      var responses = Object.values(i.responses);

      for (var index = 0; index < responses.length; index++) {
        if (index > 1) {
          //This excludes Dispensing Date[0] and Ethnicity[1]
          var responseKey = Object.keys(responses[index]);
          extraResponses[responseKey] = responses[index][responseKey];
        }
      }

      var mainResponses = {
        'Module': i.Module,
        'PracticeID': i.PracticeID,
        'PHO': i.PHO,
        'Review_Date': responses[0],
        'Ethnicity': responses[1]
      };
      bodyContent.push(Object.assign(mainResponses, extraResponses));
    });
    jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(setTableHeader, function (k, colObj) {
      var str = '<th>' + colObj.name + '</th>';
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(str).appendTo(tableName + '>thead>tr');
    });

    bodyContent.render = function (data, type, row) {
      return '<h4>' + data + '</h4>';
    };

    jquery__WEBPACK_IMPORTED_MODULE_0___default()(tableName).DataTable({
      "data": bodyContent,
      "columns": setTableHeader,
      dom: 'Bflrtip',
      buttons: [{
        extend: 'csv',
        text: '<i class="fal fa-arrow-circle-down"></i> <span class="ml-1">Export to CSV</span>'
      }],
      "fnInitComplete": function fnInitComplete() {
        // Event handler to be fired when rendering is complete (Turn off Loading gif for example)
        console.log('Datatable rendering complete');
      }
    });
  }

  function callAPIEndpoint(endpoint, method, postData, callback) {
    var test = true;
    var httpRequest = new XMLHttpRequest();
    httpRequest.open(method, endpoint, true);

    httpRequest.onreadystatechange = function () {
      if (httpRequest.readyState === 4) {
        if (httpRequest.status === 200) {
          if (callback) {
            callback(JSON.parse(httpRequest.response));
          }
        }
      }
    };

    if (postData) {
      if (test) {
        postData += '&test=1';
      }

      httpRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      httpRequest.send(postData);
    } else {
      httpRequest.send(null);
    }
  }
});
/* eslint-enable */

/***/ }),

/***/ "./src/js/components/navigation.js":
/*!*****************************************!*\
  !*** ./src/js/components/navigation.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* eslint-disable */

/* eslint-enable */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var Dropdown = jquery__WEBPACK_IMPORTED_MODULE_0___default()('nav .dropdown');
  /**
   * Close dropdown, by default Bootstrap leaves it open. Also hide any child
   * menus with aria-hidden.
   */

  var closeMenu = function closeMenu() {
    // Close dropdown, by default Bootstrap leaves it open
    Dropdown.removeClass('open').find('.navbar-touch-caret').attr('aria-expanded', false).find('.fa-caret-up').toggleClass('fa-caret-up fa-caret-down');
    Dropdown.find('.dropdown-menu').attr('aria-hidden', true);
  };
  /**
   * Trigger a menu item to be "opened" or expanded
   */


  var openMenu = function openMenu($elem) {
    closeMenu();
    $elem.addClass('open');
    $elem.find('.navbar-touch-caret').attr('aria-expanded', true).find('.fa-caret-down').toggleClass('fa-caret-down fa-caret-up');
    $elem.find('.dropdown-menu').attr('aria-hidden', false);
  };
  /**
   * If screen width is Desktop return true. 768px according to Bootstrap @media queries,
   * but can be overridden by adding data-grid-float-breakpoint-width="1234" to your <body>
   * tag to override this.
   *
   * @returns {Boolean}
   */


  var isDesktop = function isDesktop() {
    var maxWidth = jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').data('grid-float-breakpoint-width') || 768;
    return jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).width() > maxWidth || false;
  };
  /**
   * Handle the "hover" events to open and close the dropdown menus, and some keyboard
   * behaviours, such as "Esc" to close the menu, and spacebar and down key to open it.
   *
   * These keypress handlers differ from the others lower down in that these apply only
   * to navigation elements that have a dropdown menu associated.
   */


  Dropdown.hover(function handleOpenMenu() {
    if (isDesktop()) {
      openMenu(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));
    }
  }, function () {
    if (isDesktop()) {
      closeMenu();
    }
  }).keydown(function (event) {
    switch (event.keyCode) {
      case 13:
        // Enter key
        closeMenu();
        break;

      case 32:
      case 40:
        // Space bar and "down" key
        // Stop the default behaviour (e.g. scrolling down)
        event.preventDefault();
        openMenu(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this));
        break;

      case 27:
        // ESC
        closeMenu();
        break;

      default:
        break;
    }
  });
  /**
   * Handler for key press events on navigation items - this allows the left and right
   * arrow keys to navigate through the lists.
   *
   * These handlers are for all navigation items, not just those with a dropdown associated.
   * NOTE: Be careful if adding new handlers here - be aware that they the previous handler
   * may also be fired, creating race conditions.
   */

  jquery__WEBPACK_IMPORTED_MODULE_0___default()('nav .nav-item').keydown(function (event) {
    var $next = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).next().find('a');
    var $prev = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).prev().find('a');

    switch (event.keyCode) {
      case 39:
        // forward [>]
        if ($next.length) {
          $next.focus();
          closeMenu();
        }

        break;

      case 37:
        // backward [<]
        if ($prev.length) {
          $prev.focus();
          closeMenu();
        }

        break;

      default:
        break;
    }
  });
});

/***/ }),

/***/ "./src/js/components/search.js":
/*!*************************************!*\
  !*** ./src/js/components/search.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* eslint-disable */

/* eslint-enable */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('article[data-highlight]').each(function () {
    var text = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data('highlight');
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).highlight(text, {
      element: 'mark',
      className: 'highlight'
    });
  });
});

/***/ }),

/***/ "./src/js/components/sitemap.js":
/*!**************************************!*\
  !*** ./src/js/components/sitemap.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* eslint-disable */

/* eslint-enable */

/* harmony default export */ __webpack_exports__["default"] = (function () {
  /**
   * Return a cache identifier for storing sitemap data in local storage
   */
  function getCacheId(pageId) {
    return "sitemap-cache-".concat(pageId);
  }
  /**
   * Sets some data to the sitemap for the given page
   */


  function setSitemapData(pageId, data) {
    jquery__WEBPACK_IMPORTED_MODULE_0___default()("#children-".concat(pageId)).html(data);
  }
  /**
   * Given a page ID and some sitemap data, load it into the DOM. Will load from
   * the local cache if available.
   */


  function loadSitemap(pageId) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var sitemapData = data; // Attempt to load from cache

    if (data === null && typeof Storage !== 'undefined' && sessionStorage.getItem(getCacheId(pageId)) !== null) {
      sitemapData = sessionStorage.getItem(getCacheId(pageId));
    }

    setSitemapData(pageId, sitemapData);
  }
  /**
   * Constructs a loading animation and sets it to the sitemap data
   */


  function setLoadingMessage($self, pageId) {
    var loadingMessage = $self.data('loading-message');
    setSitemapData(pageId, "<div class=\"sitemap-loading\">\n        <i class=\"fa fa-spinner fa-pulse\" aria-hidden=\"true\"></i>\n        <span class=\"sr-only\">".concat(loadingMessage, "</span>\n      </div>"));
  }
  /**
   * Check for a cached copy of the sitemap data for the requested page, and return
   * whether or not to perform an AJAX request
   */


  function getPerformAjaxRequest($self, pageId) {
    if (typeof Storage !== 'undefined') {
      if (sessionStorage.getItem(getCacheId(pageId)) !== null) {
        loadSitemap(pageId);
        return false;
      }
    }

    setLoadingMessage($self, pageId);
    return true;
  }
  /**
   * Toggle the state of the sitemap section button, either expanded or collapsed
   */


  function toggleButton($button) {
    $button.toggleClass('collapsed').attr('aria-expanded', function (i, val) {
      return val !== 'true';
    });
    var $screenReader = $button.find('.sr-only');
    var screenReaderText = $screenReader.text();
    var screenReaderDataText = $screenReader.attr('data-collapse-text');
    $button.find('.toggleIco').toggleClass('fa-minus fa-plus'); // Toggle text and data-collapse-text

    $screenReader.text(screenReaderDataText);
    $screenReader.attr('data-collapse-text', screenReaderText);
  }

  jquery__WEBPACK_IMPORTED_MODULE_0___default()('.sitemap-page').on('click', 'a.sitemap__collapse-action', function (e) {
    e.preventDefault(); // @todo: Remove passing of reference to $(this) as per AirBnB style guide

    var $self = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
    var pageId = $self.data('page-id');
    toggleButton($self);
    jquery__WEBPACK_IMPORTED_MODULE_0___default.a.ajax({
      cache: true,
      url: "".concat(window.location.pathname, "/page/").concat(pageId),
      beforeSend: function beforeSend() {
        return getPerformAjaxRequest($self, pageId);
      },
      success: function success(data) {
        // Cache so we don't need to perform this AJAX request again
        if (typeof Storage !== 'undefined') {
          sessionStorage.setItem(getCacheId(pageId), data);
        }

        loadSitemap(pageId, data);
      }
    });
  });
  /**
   * Remove the aria-selected attributes that the paypal/bootstrap-accessibility
   * plugin adds to all sitemap toggle anchors.
   */

  jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
    jquery__WEBPACK_IMPORTED_MODULE_0___default()('.sitemap__collapse-action').removeAttr('aria-selected');
  });
});

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var bootstrap_js_src_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap/js/src/util */ "./node_modules/bootstrap/js/src/util.js");
/* harmony import */ var bootstrap_js_src_collapse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap/js/src/collapse */ "./node_modules/bootstrap/js/src/collapse.js");
/* harmony import */ var bootstrap_js_src_dropdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bootstrap/js/src/dropdown */ "./node_modules/bootstrap/js/src/dropdown.js");
/* harmony import */ var bootstrap_js_src_carousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bootstrap/js/src/carousel */ "./node_modules/bootstrap/js/src/carousel.js");
/* harmony import */ var bootstrap_js_src_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bootstrap/js/src/tooltip */ "./node_modules/bootstrap/js/src/tooltip.js");
/* harmony import */ var bootstrap_js_src_popover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bootstrap/js/src/popover */ "./node_modules/bootstrap/js/src/popover.js");
/* harmony import */ var bootstrap_js_src_modal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bootstrap/js/src/modal */ "./node_modules/bootstrap/js/src/modal.js");
/* harmony import */ var bootstrap_js_src_tab__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bootstrap/js/src/tab */ "./node_modules/bootstrap/js/src/tab.js");
/* harmony import */ var jquery_highlight_jquery_highlight__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jquery-highlight/jquery.highlight */ "./node_modules/jquery-highlight/jquery.highlight.js");
/* harmony import */ var jquery_highlight_jquery_highlight__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jquery_highlight_jquery_highlight__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _components_navigation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/navigation */ "./src/js/components/navigation.js");
/* harmony import */ var _components_content__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/content */ "./src/js/components/content.js");
/* harmony import */ var _components_sitemap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/sitemap */ "./src/js/components/sitemap.js");
/* harmony import */ var _components_search__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/search */ "./src/js/components/search.js");
/* harmony import */ var _components_form__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/form */ "./src/js/components/form.js");
/* harmony import */ var _components_img__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/img */ "./src/js/components/img.js");
/* harmony import */ var _components_mods__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/mods */ "./src/js/components/mods.js");
// Define globally exposed module objects

/* eslint-disable */
// Define dependency imports








 // Define local components






 //Custom local components


Object(_components_navigation__WEBPACK_IMPORTED_MODULE_9__["default"])();
Object(_components_content__WEBPACK_IMPORTED_MODULE_10__["default"])();
Object(_components_sitemap__WEBPACK_IMPORTED_MODULE_11__["default"])();
Object(_components_search__WEBPACK_IMPORTED_MODULE_12__["default"])();
Object(_components_form__WEBPACK_IMPORTED_MODULE_13__["default"])();
Object(_components_img__WEBPACK_IMPORTED_MODULE_14__["default"])();
Object(_components_mods__WEBPACK_IMPORTED_MODULE_15__["default"])();
/* eslint-enable */

/***/ }),

/***/ "./src/scss/editor.scss":
/*!******************************!*\
  !*** ./src/scss/editor.scss ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/scss/main.scss":
/*!****************************!*\
  !*** ./src/scss/main.scss ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 0:
/*!**************************************************************************!*\
  !*** multi ./src/js/main.js ./src/scss/main.scss ./src/scss/editor.scss ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! C:\xampp\htdocs\sip-devapp\themes\starter\src\js\main.js */"./src/js/main.js");
__webpack_require__(/*! C:\xampp\htdocs\sip-devapp\themes\starter\src\scss\main.scss */"./src/scss/main.scss");
module.exports = __webpack_require__(/*! C:\xampp\htdocs\sip-devapp\themes\starter\src\scss\editor.scss */"./src/scss/editor.scss");


/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ })

/******/ });